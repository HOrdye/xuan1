<template>
  <div class="tarot-page min-h-screen bg-gradient-to-br from-indigo-900 via-purple-900 to-pink-900">
    <!-- Background effects -->
    <div class="stars-background">
      <div class="stars" v-for="n in 50" :key="n" 
           :style="{ 
             left: Math.random() * 100 + '%', 
             top: Math.random() * 100 + '%',
             animationDelay: Math.random() * 3 + 's'
           }">â­</div>
    </div>

    <div class="container mx-auto px-4 py-8 relative z-10">
      <!-- Header -->
      <div class="text-center mb-12">
        <h1 class="text-5xl font-bold text-white mb-4 mystical-glow">ğŸ”® å¡”ç½—å åœ ğŸ”®</h1>
        <p class="text-xl text-purple-200">æ¢ç´¢å‘½è¿çš„ç¥ç§˜é¢çº±ï¼Œè†å¬å¿ƒçµçš„æ™ºæ…§ä¹‹å£°</p>
      </div>

      <!-- Stage 1: Intro & Question Input -->
      <div v-if="currentStage === 'intro'" class="max-w-4xl mx-auto">
        <div class="bg-black/30 backdrop-blur-md rounded-3xl p-8 border border-purple-500/30 shadow-2xl">
          <div class="text-center mb-8">
            <div class="text-6xl mb-6 animate-pulse">ğŸŒŸ</div>
            <h2 class="text-3xl font-bold text-white mb-4">æ¬¢è¿æ¥åˆ°ç¥ç§˜çš„å¡”ç½—ä¸–ç•Œ</h2>
            <p class="text-lg text-purple-200 mb-6 leading-relaxed">
              å¡”ç½—ç‰Œæ˜¯å¤è€çš„æ™ºæ…§ç»“æ™¶ï¼Œèƒ½å¤Ÿå¸®åŠ©æ‚¨æ¢ç´¢å†…å¿ƒæ·±å¤„çš„ç­”æ¡ˆã€‚<br>
              åœ¨å¼€å§‹å åœä¹‹å‰ï¼Œè¯·é™ä¸‹å¿ƒæ¥ï¼Œä¸“æ³¨äºæ‚¨æƒ³è¦äº†è§£çš„é—®é¢˜ã€‚
            </p>
          </div>

          <div class="mb-8">
            <div class="mb-6">
              <div class="text-center mb-4">
                <h3 class="text-lg font-medium text-purple-200 mb-2">ğŸ’« é«˜é¢‘é—®é¢˜å¼¹å¹•</h3>
                <p class="text-sm text-purple-300">ç‚¹å‡»é£˜è¿‡çš„é—®é¢˜å¯å¿«é€Ÿå¡«å……</p>
              </div>
              <div 
                ref="barrageArea"
                class="barrage-area relative w-full h-32 overflow-hidden bg-white/5 rounded-xl border border-purple-400/30 shadow-inner"
              ></div>
            </div>
            
            <label class="block text-white text-lg font-medium mb-4">
              ğŸ’­ è¯·è¾“å…¥æ‚¨æƒ³è¦å’¨è¯¢çš„é—®é¢˜ï¼ˆå¯é€‰ï¼‰
            </label>
            <textarea 
              ref="questionInput"
              v-model="userQuestion"
              placeholder="ä¾‹å¦‚ï¼šæˆ‘çš„äº‹ä¸šå‘å±•å¦‚ä½•ï¼Ÿæˆ‘çš„æ„Ÿæƒ…è¿åŠ¿æ€æ ·ï¼Ÿæˆ‘åº”è¯¥å¦‚ä½•é¢å¯¹å½“å‰çš„å›°å¢ƒï¼Ÿ"
              class="w-full h-32 px-4 py-3 bg-white/10 border border-purple-400/50 rounded-lg text-white placeholder-purple-300 focus:outline-none focus:border-purple-400 focus:ring-2 focus:ring-purple-400/50 resize-none"
            ></textarea>
          </div>

          <div class="text-center">
            <button 
              @click="goToSpreadSelection" 
              class="bg-gradient-to-r from-purple-600 to-pink-600 text-white text-xl font-bold py-4 px-12 rounded-full shadow-lg hover:shadow-2xl transform hover:scale-105 transition-all duration-300 mystical-glow"
            >
              ğŸ´ é€‰æ‹©ç‰Œé˜µ
            </button>
          </div>
        </div>
      </div>

      <!-- Stage 1.5: Spread Selection -->
      <div v-if="currentStage === 'spreadSelection'" class="max-w-6xl mx-auto">
        <div class="bg-black/30 backdrop-blur-md rounded-3xl p-8 border border-purple-500/30 shadow-2xl">
          <div class="text-center mb-12">
            <div class="text-5xl mb-6 animate-pulse">ğŸ”®</div>
            <h2 class="text-3xl font-bold text-white mb-4">é€‰æ‹©æ‚¨çš„ä¸“å±ç‰Œé˜µ</h2>
            <p class="text-lg text-purple-200 mb-8">æ¯ä¸ªç‰Œé˜µéƒ½æœ‰å…¶ç‹¬ç‰¹çš„æ™ºæ…§ä¸å¯ç¤ºï¼Œè¯·æ ¹æ®æ‚¨çš„é—®é¢˜é€‰æ‹©æœ€é€‚åˆçš„ç‰Œé˜µ</p>
          </div>

          <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-8">
            <div 
              v-for="(spread) in classicSpreads" 
              :key="spread.name"
              class="spread-card cursor-pointer transform transition-all duration-300 hover:scale-105 hover:-translate-y-2"
              :class="{ 'selected': selectedSpread?.name === spread.name }"
              @click="selectSpread(spread)"
            >
              <div class="bg-gradient-to-br from-purple-800/50 to-indigo-900/50 backdrop-blur-sm rounded-2xl p-6 border border-purple-400/30 shadow-xl h-full flex flex-col">
                <div class="text-center mb-4">
                  <div class="text-4xl mb-3">{{ getSpreadIcon(spread.name) }}</div>
                  <h3 class="text-xl font-bold text-white mb-2">{{ spread.chineseName }}</h3>
                  <div class="text-sm text-purple-300 mb-4">{{ spread.positions.length }}å¼ ç‰Œ</div>
                </div>
                <div class="bg-gradient-to-r from-yellow-400/20 to-orange-400/20 rounded-xl p-4 mb-4 border border-yellow-400/40">
                  <div class="text-center">
                    <div class="text-yellow-200 text-sm font-bold mb-2 flex items-center justify-center">
                      <span class="mr-2">â­</span>
                      <span>æœ€æ“…é•¿è§£å†³</span>
                    </div>
                    <div class="text-yellow-100 text-base font-semibold">{{ spread.bestFor[0] }}</div>
                  </div>
                </div>
                <p class="text-xs text-purple-400 text-white opacity-80 leading-relaxed break-words mt-auto pt-3 border-t border-purple-500/20">
                  {{ spread.description }}
                </p>
              </div>
            </div>
          </div>

          <div class="flex justify-center space-x-6 mt-12">
            <button @click="goBackToIntro" class="bg-gray-600 hover:bg-gray-700 text-white text-lg font-medium py-3 px-8 rounded-full transition-colors duration-300">
              â† è¿”å›
            </button>
            <button @click="startReading" :disabled="!selectedSpread" class="bg-gradient-to-r from-purple-600 to-pink-600 text-white text-lg font-bold py-3 px-12 rounded-full shadow-lg hover:shadow-2xl transform hover:scale-105 transition-all duration-300 mystical-glow disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none">
              ğŸ´ å¼€å§‹å åœ
            </button>
          </div>
        </div>
      </div>

      <!-- Shuffling Animation -->
      <div v-if="currentStage === 'shuffling'" class="max-w-4xl mx-auto text-center relative overflow-hidden">
        <div class="bg-black/30 backdrop-blur-md rounded-3xl p-12 border border-purple-500/30 shadow-2xl relative">
          <div class="absolute inset-0 pointer-events-none overflow-hidden rounded-3xl">
            <div v-for="n in 8" :key="n" class="floating-card absolute opacity-20" :style="getFloatingCardStyle(n)">
              <div class="floating-card-back" :style="cardBackStyle"></div>
            </div>
          </div>
          <div class="relative z-10">
            <div class="text-6xl mb-6 animate-pulse">ğŸŒ€</div>
            <h2 class="text-3xl font-bold text-white mb-4">æ­£åœ¨æ´—ç‰Œ...</h2>
            <p class="text-lg text-purple-200 mb-8">è¯·ä¸“æ³¨äºæ‚¨çš„é—®é¢˜ï¼Œè®©å®‡å®™çš„èƒ½é‡æµå…¥ç‰Œä¸­</p>
            <div class="mystical-progress-container mb-8">
              <div class="mystical-progress-bar"></div>
            </div>
          </div>
        </div>
      </div>

      <!-- Drawing Stage -->
      <div v-if="currentStage === 'drawing'" class="max-w-6xl mx-auto">
        <div class="bg-black/30 backdrop-blur-md rounded-3xl p-8 border border-purple-500/30 shadow-2xl">
          <div class="text-center mb-8">
            <h2 class="text-3xl font-bold text-white mb-4">âœ¨ é€‰æ‹©æ‚¨çš„å‘½è¿ä¹‹ç‰Œ</h2>
            <p class="text-lg text-purple-200 mb-6">è¯·ç”¨å¿ƒæ„Ÿå—ï¼Œç‚¹å‡»ä¸‹æ–¹çš„ç‰Œæ¥æŠ½å–æ‚¨çš„{{ selectedSpread?.positions.length }}å¼ ç‰Œ</p>
            <p class="text-purple-300">å·²æŠ½å–: {{ drawnCards.length }} / {{ selectedSpread?.positions.length }}</p>
          </div>

          <div class="deck-spread flex justify-center items-center mb-8 flex-wrap gap-4">
            <div v-for="item in displayedDeck" :key="item.id" class="deck-card cursor-pointer transform transition-all duration-500 hover:scale-110 hover:-translate-y-4" :class="{ 'drawn': item.drawn }" @click="drawCard(item)">
              <div class="w-24 h-36 rounded-lg shadow-lg border border-purple-400/50 overflow-hidden">
                <div class="card-back w-full h-full" :style="cardBackStyle"></div>
              </div>
            </div>
          </div>

          <div class="drawn-positions mt-12">
            <div class="grid gap-4 justify-center" :class="getCardLayoutClass(positions.length)">
              <div v-for="(_position, index) in positions" :key="index" class="position-slot">
                <div class="text-center mb-2">
                  <h3 class="text-base font-bold text-white mb-2">{{ positions[index] }}</h3>
                </div>
                <div class="card-slot w-28 h-40 mx-auto rounded-lg border-2 border-dashed border-purple-400/50 flex items-center justify-center" :class="{ 'filled': drawnCards[index] }">
                  <div v-if="!drawnCards[index]" class="text-purple-400 text-5xl opacity-50">?</div>
                  <div v-else class="drawn-card-preview w-full h-full bg-gradient-to-br from-purple-800 to-indigo-900 rounded-lg flex flex-col items-center justify-center transform animate-flip-in border border-purple-400/50">
                    <div class="text-white text-2xl animate-pulse">ğŸŒŸ</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <div v-if="drawnCards.length === (selectedSpread?.positions.length || 0)" class="text-center mt-8">
            <button @click="revealCards" class="bg-gradient-to-r from-pink-600 to-red-600 text-white text-xl font-bold py-4 px-12 rounded-full shadow-lg hover:shadow-2xl transform hover:scale-105 transition-all duration-300 mystical-glow">
              âœ¨ æ­ç¤ºå‘½è¿
            </button>
          </div>
        </div>
      </div>

      <!-- Reveal Stage -->
      <div v-if="currentStage === 'reveal'" class="max-w-6xl mx-auto">
        <div class="bg-black/30 backdrop-blur-md rounded-3xl p-8 border border-purple-500/30 shadow-2xl">
          <h1 class="text-white text-5xl text-center">ğŸ´ å‘½è¿è§£è¯»</h1>
          <p class="text-white text-center mt-4 mb-6">æ‚¨çš„å¡”ç½—ç‰Œå·²ç»æ­ç¤ºï¼Œè®©æˆ‘ä»¬æ¥è§£è¯»å‘½è¿çš„å¯ç¤º...</p>
          
          <div v-if="llmLoading" class="mt-8 mb-8">
            <div class="bg-gradient-to-r from-purple-600/20 to-indigo-600/20 rounded-2xl p-6 border border-purple-400/30">
              <div class="flex items-center justify-center mb-4">
                <div class="w-8 h-8 border-4 border-purple-400 border-t-transparent rounded-full animate-spin mr-3"></div>
                <h3 class="text-xl font-bold text-white">{{ llmProgress }}</h3>
              </div>
            </div>
          </div>
          
          <div class="mt-6 text-center" v-if="userQuestion">
            <div class="inline-block bg-gradient-to-r from-purple-600/30 to-pink-600/30 backdrop-blur-sm rounded-2xl px-6 py-3 border border-purple-400/30">
              <span class="text-purple-200 text-sm">æ‚¨çš„é—®é¢˜ï¼š</span>
              <span class="text-white font-medium ml-2">{{ userQuestion }}</span>
            </div>
          </div>
          
          <div class="mt-8" v-if="interpretationResult">
            <h2 class="text-2xl font-bold text-white text-center mb-6">æ‚¨æŠ½åˆ°çš„ç‰Œ</h2>
            <div class="grid gap-6 justify-center" :class="getCardLayoutClass(interpretationResult.cards.length)">
              <div v-for="(card, index) in interpretationResult.cards" :key="card.name" class="text-center">
                <div class="position-title-header mb-3 text-center">
                  <div class="inline-block bg-gradient-to-r from-purple-600/80 to-indigo-600/80 backdrop-blur-sm rounded-full px-4 py-2 border border-purple-400/40">
                    <span class="text-white font-bold text-sm">{{ card.position }}</span>
                  </div>
                </div>
                <div class="tarot-card-container relative" :class="[ card.category === 'major' ? 'major-arcana' : 'minor-arcana' ]">
                  <img :src="card.imageUrl" :alt="card.name" class="tarot-card-image w-full object-cover rounded-lg" @error="handleImageError"/>
                  <div class="card-info p-2 text-center">
                    <div class="text-purple-200 mb-1 font-semibold">{{ card.name }}</div>
                    <div class="text-xs text-purple-300 cursor-help hover:text-purple-100 transition-colors duration-200" @mouseenter="showCardTooltip($event, card)" @mouseleave="hideCardTooltip">ğŸ“– è¯¦ç»†è§£è¯»</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <div v-if="tooltip.visible" ref="cardTooltip" class="card-tooltip" :style="tooltip.style">
            <div class="tooltip-content">
              <div class="flex items-center gap-2 mb-2">
                <h4 class="font-bold text-white text-lg">{{ tooltip.card?.name }}</h4>
                <span v-if="tooltip.card?.position" class="text-xs bg-purple-600/80 px-2 py-1 rounded-full text-white">{{ tooltip.card.position }}</span>
              </div>
              <div class="text-sm text-gray-200 leading-relaxed space-y-2" v-html="tooltip.content"></div>
            </div>
          </div>
          
          <div class="mt-12" v-if="interpretationResult">
            <div class="bg-gradient-to-br from-indigo-900/40 to-purple-900/40 backdrop-blur-sm rounded-2xl p-6 border border-indigo-400/30 shadow-xl space-y-6">
              <div v-for="(section, index) in interpretationResult.sections" :key="index" class="bg-black/20 rounded-xl p-5 border border-purple-400/20">
                <h3 class="text-2xl font-bold text-white mb-4 text-center flex items-center justify-center gap-2">
                  <span class="text-2xl">{{ section.icon }}</span> {{ section.title }}
                </h3>
                <div class="text-lg text-gray-200 leading-relaxed prose prose-invert max-w-none prose-p:my-2 prose-h3:my-4" v-html="formatMarkdown(section.content)"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onUnmounted, nextTick, reactive } from 'vue';
import { storyTarotDeck, type StoryTarotCard } from '../utils/storyTarotData';
import { classicSpreads, type TarotSpread } from '../utils/tarotInterpretation';
import { LLMService, type InterpretationSection, type LLMLoadingState } from '../../../services/LLMService';
import kabeiImage from '../../../assets/kabei.jpg';
import { marked } from 'marked';

const cardBackStyle = { backgroundImage: `url(${kabeiImage})` };

interface ProcessedCard {
  name: string;
  position: string;
  imageUrl: string;
  category: 'major' | 'minor';
  keywords: string[];
  story: string;
  contextualMeaning?: string; // Add this to store the AI-generated meaning
}

interface ProcessedInterpretation {
  cards: ProcessedCard[];
  sections: InterpretationSection[];
}

type Stage = 'intro' | 'spreadSelection' | 'shuffling' | 'drawing' | 'reveal';

const currentStage = ref<Stage>('intro');
const selectedSpread = ref<TarotSpread | null>(null);
const userQuestion = ref('');
const positions = ref<string[]>([]);
const drawnCards = ref<StoryTarotCard[]>([]);
const deck = ref<StoryTarotCard[]>([]);
const displayedDeck = ref<{id: number, drawn: boolean}[]>([]);
const interpretationResult = ref<ProcessedInterpretation | null>(null);

const llmLoading = ref(false);
const llmProgress = ref('');

LLMService.onLoadingStateChange((state: LLMLoadingState) => {
  llmLoading.value = state.isLoading;
  llmProgress.value = state.progress;
});

const barrageArea = ref<HTMLElement | null>(null);
const questionInput = ref<HTMLTextAreaElement | null>(null);

function processInterpretation(raw: InterpretationSection[], drawn: StoryTarotCard[], spread: TarotSpread): ProcessedInterpretation {
  return {
    cards: drawn.map((card, index) => ({
      name: card.chineseName || card.name,
      position: spread.positions[index]?.chineseName || `ä½ç½® ${index + 1}`,
      imageUrl: card.imageUrl,
      category: card.category,
      keywords: card.keywords,
      story: card.storyInterpretation,
    })),
    sections: raw,
  };
}

function goToSpreadSelection() { currentStage.value = 'spreadSelection'; }
function goBackToIntro() { currentStage.value = 'intro'; }
function selectSpread(spread: TarotSpread) {
  selectedSpread.value = spread;
  positions.value = spread.positions.map(p => p.chineseName);
}

function getSpreadIcon(spreadName: string): string {
  const icons: Record<string, string> = { 'Three Card Spread': 'ğŸ”®', 'Love Pyramid Spread': 'ğŸ’•', 'Decision Making Spread': 'âš–ï¸' };
  return icons[spreadName] || 'ğŸ´';
}

function startReading() {
  if (!selectedSpread.value) return;
  currentStage.value = 'shuffling';
  setTimeout(() => {
    currentStage.value = 'drawing';
    setupDeckForDrawing();
  }, 2500);
}

function shuffleAndDeal() {
  deck.value = [...storyTarotDeck].sort(() => Math.random() - 0.5);
}

function setupDeckForDrawing() {
  const count = selectedSpread.value?.positions.length || 0;
  displayedDeck.value = Array.from({ length: Math.max(7, count) }, (_, i) => ({ id: i, drawn: false }));
}

function drawCard(deckItem: {id: number, drawn: boolean}) {
  if (deckItem.drawn || !selectedSpread.value || drawnCards.value.length >= selectedSpread.value.positions.length) return;
  const card = deck.value.pop();
  if (card) {
    drawnCards.value.push(card);
    deckItem.drawn = true;
  }
}

async function revealCards() {
  if (!selectedSpread.value) return;
  currentStage.value = 'reveal';
  await nextTick();

  // Get main interpretation and all card meanings in a single call
  const result = await LLMService.getTarotInterpretation(drawnCards.value, selectedSpread.value, userQuestion.value);

  const processedCards = drawnCards.value.map((card, index) => {
    const cardMeaningObj = result.cardMeanings.find(m => m.cardName === (card.chineseName || card.name));
    return {
      name: card.chineseName || card.name,
      position: selectedSpread.value!.positions[index]?.chineseName || `ä½ç½® ${index + 1}`,
      imageUrl: card.imageUrl,
      category: card.category,
      keywords: card.keywords,
      story: card.storyInterpretation,
      contextualMeaning: cardMeaningObj ? marked(cardMeaningObj.meaning, { gfm: true, breaks: true }) as string : 'AIæœªèƒ½æä¾›æ­¤ç‰Œçš„è§£è¯»ã€‚'
    };
  });

  interpretationResult.value = {
    cards: processedCards,
    sections: result.base
  };
}

const tooltip = reactive({
  visible: false,
  content: '',
  card: null as ProcessedCard | null,
  style: { left: '0px', top: '0px' },
});
const cardTooltip = ref<HTMLElement | null>(null);
let tooltipTimeout: number | null = null;

function showCardTooltip(event: MouseEvent, card: ProcessedCard) {
  if (tooltipTimeout) clearTimeout(tooltipTimeout);

  tooltip.card = card;
  tooltip.content = card.contextualMeaning || 'æ­£åœ¨åŠ è½½è§£è¯»...';
  tooltip.visible = true;

  nextTick(() => {
    if (cardTooltip.value) {
      const target = event.currentTarget as HTMLElement;
      const targetRect = target.getBoundingClientRect();
      const tooltipEl = cardTooltip.value;
      
      // Reset position to get accurate dimensions of the content
      tooltipEl.style.left = '-9999px';
      tooltipEl.style.top = '-9999px';
      const tooltipRect = tooltipEl.getBoundingClientRect();
      
      let top = targetRect.bottom + window.scrollY + 12;
      if (top + tooltipRect.height > document.documentElement.scrollHeight) {
        top = targetRect.top + window.scrollY - tooltipRect.height - 12;
      }

      let left = targetRect.left + window.scrollX + (targetRect.width / 2) - (tooltipRect.width / 2);
      if (left < 10) left = 10;
      if (left + tooltipRect.width > window.innerWidth - 10) {
        left = window.innerWidth - tooltipRect.width - 10;
      }

      tooltip.style.left = `${left}px`;
      tooltip.style.top = `${top}px`;
    }
  });
}

function hideCardTooltip() {
  tooltipTimeout = window.setTimeout(() => {
    tooltip.visible = false;
  }, 200);
}

const formatMarkdown = (content: string) => content ? marked(content, { gfm: true, breaks: true }) : '';
const getCardLayoutClass = (count: number) => {
  if (count <= 3) return 'grid-cols-1 md:grid-cols-3';
  if (count === 4) return 'grid-cols-2 md:grid-cols-4';
  if (count <= 6) return 'grid-cols-3 md:grid-cols-3';
  return 'grid-cols-4';
};
const handleImageError = (event: Event) => { (event.target as HTMLImageElement).src = kabeiImage; };
const getFloatingCardStyle = (n: number) => ({ left: `${Math.random()*100}%`, top: `${Math.random()*100}%`, transform: `rotate(${Math.random()*360}deg) scale(${0.5+Math.random()*0.5})`, animation: `float ${5+Math.random()*10}s ease-in-out infinite alternate`, animationDelay: `${Math.random()*5}s` });

// --- Barrage System ---
interface BarrageItem {
  el: HTMLDivElement; text: string; x: number; width: number; speed: number; row: number; paused: boolean; likes: number;
}
const barrageItems = ref<BarrageItem[]>([]);
const BARRAGE_ROWS = 4;
const ROW_HEIGHT = 40;
interface BarrageRowState { lastItemExitTime: number; }
const rowStates = ref<BarrageRowState[]>(Array.from({ length: BARRAGE_ROWS }, () => ({ lastItemExitTime: 0 })));
let barrageAnimationId: number;

function initBarrage() {
  if (!barrageArea.value) return;
  const suggestions = [
    { text: 'æˆ‘çš„äº‹ä¸šå‘å±•å¦‚ä½•ï¼Ÿ', likes: 12 }, { text: 'æˆ‘çš„æ„Ÿæƒ…è¿åŠ¿æ€æ ·ï¼Ÿ', likes: 25 }, { text: 'è¿‘æœŸè´¢è¿å¦‚ä½•ï¼Ÿ', likes: 8 },
    { text: 'æˆ‘è¯¥å¦‚ä½•é¢å¯¹å½“å‰çš„å›°å¢ƒï¼Ÿ', likes: 15 }, { text: 'æœªæ¥ä¸‰ä¸ªæœˆä¼šæœ‰ä»€ä¹ˆæ–°æœºä¼šï¼Ÿ', likes: 5 }, { text: 'æˆ‘ä¸TAçš„å…³ç³»ä¼šå¦‚ä½•å‘å±•ï¼Ÿ', likes: 18 },
  ];
  
  const add = () => {
    // 1. è·å–å½“å‰æ­£åœ¨æ˜¾ç¤ºçš„å¼¹å¹•æ–‡æœ¬
    const currentTexts = new Set(barrageItems.value.map(item => item.text));
    // 2. ç­›é€‰å‡ºå°šæœªæ˜¾ç¤ºçš„å»ºè®®
    const availableSuggestions = suggestions.filter(s => !currentTexts.has(s.text));

    if (availableSuggestions.length > 0) {
      // 3. ä»å¯ç”¨å»ºè®®ä¸­éšæœºé€‰æ‹©ä¸€ä¸ª
      const suggestion = availableSuggestions[Math.floor(Math.random() * availableSuggestions.length)];
      addBarrageItem(suggestion);
    }
    
    // æ— è®ºæ˜¯å¦æ·»åŠ æˆåŠŸï¼Œéƒ½ç»§ç»­è°ƒåº¦ä¸‹ä¸€æ¬¡æ·»åŠ 
    setTimeout(add, 2000 + Math.random() * 2500);
  }

  add(); // ç«‹å³å¯åŠ¨
  animateBarrage();
}

function addBarrageItem(suggestion: {text: string, likes: number}) {
  if (!barrageArea.value) return;
  const containerWidth = barrageArea.value.offsetWidth;

  // Find an available row
  let bestRow = -1;
  let earliestExitTime = Infinity;
  for (let i = 0; i < BARRAGE_ROWS; i++) {
    if (performance.now() > rowStates.value[i].lastItemExitTime) {
      bestRow = i;
      break;
    }
    if (rowStates.value[i].lastItemExitTime < earliestExitTime) {
      earliestExitTime = rowStates.value[i].lastItemExitTime;
      bestRow = i;
    }
  }

  const el = document.createElement('div');
  el.className = 'barrage-item absolute whitespace-nowrap cursor-pointer transition-all duration-200 select-none flex items-center gap-3';
  el.style.top = `${bestRow * ROW_HEIGHT}px`;
  el.style.transform = `translateX(${containerWidth}px)`;
  
  const textSpan = document.createElement('span');
  textSpan.textContent = suggestion.text;
  textSpan.className = 'barrage-text flex-1 text-white';

  const likeButton = document.createElement('button');
  likeButton.className = 'like-button flex items-center gap-1 px-2 py-1 rounded-full transition-all duration-200 hover:bg-red-500/20';
  likeButton.innerHTML = `<svg class="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg><span class="text-xs font-medium text-white">${suggestion.likes}</span>`;

  el.appendChild(textSpan);
  el.appendChild(likeButton);
  barrageArea.value.appendChild(el);
  
  const speed = Math.random() * 20 + 40;
  const width = el.offsetWidth;
  const item: BarrageItem = { el, text: suggestion.text, x: containerWidth, width, speed, row: bestRow, paused: false, likes: suggestion.likes };
  
  const duration = (containerWidth + width) / speed * 1000;
  rowStates.value[bestRow].lastItemExitTime = performance.now() + duration / 2; // Allow some overlap

  el.addEventListener('click', () => userQuestion.value = item.text);
  
  el.addEventListener('mouseenter', () => {
    item.paused = true;
    el.style.zIndex = '100';
  });

  el.addEventListener('mouseleave', () => {
    item.paused = false;
    el.style.zIndex = 'auto';
  });

  likeButton.addEventListener('click', e => {
      e.stopPropagation();
      item.likes++;
      likeButton.innerHTML = `<svg class="w-4 h-4 text-red-500" fill="currentColor" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg><span class="text-xs font-medium text-red-500">${item.likes}</span>`;
  });
  
  barrageItems.value.push(item);
}

function animateBarrage() {
  let lastTime = 0;
  const animate = (currentTime: number) => {
    if (!lastTime) lastTime = currentTime;
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    for (let i = barrageItems.value.length - 1; i >= 0; i--) {
      const item = barrageItems.value[i];
      if (!item.paused) {
        item.x -= item.speed * deltaTime;
      }
      if (item.x + item.width < 0) {
        item.el.remove();
        barrageItems.value.splice(i, 1);
      } else {
        // ä¿®å¤ï¼šç”±JSç»Ÿä¸€ç®¡ç† transformï¼Œç»“åˆä½ç§»å’Œç¼©æ”¾ï¼Œè§£å†³æ‚¬åœå¼¹å°„é—®é¢˜
        const scale = item.paused ? 1.05 : 1;
        item.el.style.transform = `translateX(${item.x}px) scale(${scale})`;
      }
    }
    barrageAnimationId = requestAnimationFrame(animate);
  }
  animate(performance.now());
}

onMounted(() => {
  initBarrage();
  shuffleAndDeal();
});

onUnmounted(() => {
  LLMService.offLoadingStateChange(()=>{});
  cancelAnimationFrame(barrageAnimationId);
});
</script>

<style scoped>
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');

/* Using a modern, system-font stack for better readability and aesthetics */
.tarot-page {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
  overflow-x: hidden;
}

.mystical-glow {
  text-shadow: 0 0 8px rgba(255, 255, 255, 0.4), 0 0 12px rgba(192, 132, 252, 0.6), 0 0 20px rgba(192, 132, 252, 0.4);
}

.stars-background {
  position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; pointer-events: none;
}
.stars {
  position: absolute; color: #fff; opacity: 0.7; animation: twinkle 3s infinite ease-in-out;
}
@keyframes twinkle {
  0%, 100% { transform: scale(0.8); opacity: 0.5; }
  50% { transform: scale(1.2); opacity: 1; }
}

.spread-card > div { transition: transform 0.5s, box-shadow 0.5s; }
.spread-card.selected > div {
  border-color: rgba(233, 30, 99, 0.8);
  box-shadow: 0 0 20px rgba(233, 30, 99, 0.7);
  transform: scale(1.02);
}

@keyframes float {
  from { transform: translateY(0px) rotate(var(--r-from, 0deg)); }
  to { transform: translateY(-20px) rotate(var(--r-to, 10deg)); }
}
.floating-card {
  --r-from: -10deg; --r-to: 10deg; animation: float 6s ease-in-out infinite alternate;
}
.floating-card:nth-child(odd) {
  --r-from: 10deg; --r-to: -10deg; animation-duration: 8s;
}

.floating-card-back {
  width: 80px; height: 120px;
  background-size: cover; border-radius: 8px; border: 1px solid rgba(168, 85, 247, 0.3);
  box-shadow: 0 4px 15px rgba(0,0,0,0.4);
}
.mystical-progress-bar {
  height: 10px; background: rgba(168, 85, 247, 0.2); border-radius: 5px;
  overflow: hidden; border: 1px solid rgba(168, 85, 247, 0.4);
  animation: progress-animation 2.5s linear infinite;
  background: linear-gradient(90deg, #a855f7, #ec4899, #f97316, #ec4899, #a855f7);
  background-size: 300% 100%;
}
@keyframes progress-animation {
  0% { background-position: 150% 50%; }
  100% { background-position: -50% 50%; }
}

.card-back { background-size: cover; background-position: center; }
.deck-card.drawn { opacity: 0.2; pointer-events: none; transform: scale(0.9); }
@keyframes flip-in {
  from { transform: rotateY(90deg) scale(0.8); }
  to { transform: rotateY(0deg) scale(1); }
}
.animate-flip-in { animation: flip-in 0.5s ease-out forwards; }
.tarot-card-container {
  padding: 0.5rem; border-radius: 1rem; background: rgba(0, 0, 0, 0.2);
  border: 1px solid; transition: all 0.3s ease;
}
.major-arcana { border-color: rgba(250, 204, 21, 0.5); }
.minor-arcana { border-color: rgba(168, 85, 247, 0.4); }
.tarot-card-image { transition: transform 0.3s ease; border-radius: 0.75rem; }
.tarot-card-container:hover .tarot-card-image { transform: scale(1.05); }

.card-tooltip {
  position: absolute; z-index: 100; width: 320px; max-width: 90vw;
  background: rgba(17, 12, 41, 0.9); backdrop-filter: blur(12px);
  border-radius: 12px; border: 1px solid rgba(139, 92, 246, 0.5);
  padding: 16px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); pointer-events: none;
  transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out;
}
.prose-invert :where(p):not(:where([class~="not-prose"] *)) { margin-top: 0.5em; margin-bottom: 0.5em; }

.barrage-item {
  padding: 4px 12px;
  background: rgba(0,0,0,0.25);
  border-radius: 20px;
  border: 1px solid rgba(147,51,234,0.4);
  text-shadow: 0 0 5px rgba(167, 139, 250, 0.5);
  transition: background-color 0.3s, transform 0.3s ease;
}

.barrage-item:hover {
  background-color: rgba(0,0,0,0.5);
  /* transform property is correctly managed by JS to prevent conflicts. */
}
</style>
