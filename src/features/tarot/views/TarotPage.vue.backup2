<template>
  <div class="tarot-page min-h-screen bg-gradient-to-br from-indigo-900 via-purple-900 to-pink-900">
    <!-- 背景星空效果 -->
    <div class="stars-background">
      <div class="stars" v-for="n in 50" :key="n" 
           :style="{ 
             left: Math.random() * 100 + '%', 
             top: Math.random() * 100 + '%',
             animationDelay: Math.random() * 3 + 's'
           }">⭐</div>
    </div>

    <div class="container mx-auto px-4 py-8 relative z-10">
      <!-- 标题 -->
      <div class="text-center mb-12">
        <h1 class="text-5xl font-bold text-white mb-4 mystical-glow">🔮 塔罗占卜 🔮</h1>
        <p class="text-xl text-purple-200">探索命运的神秘面纱，聆听心灵的智慧之声</p>
      </div>

      <!-- 阶段1: 介绍和问题输入 -->
      <div v-if="currentStage === 'intro'" class="max-w-4xl mx-auto">
        <div class="bg-black/30 backdrop-blur-md rounded-3xl p-8 border border-purple-500/30 shadow-2xl">
          <div class="text-center mb-8">
            <div class="text-6xl mb-6 animate-pulse">🌟</div>
            <h2 class="text-3xl font-bold text-white mb-4">欢迎来到神秘的塔罗世界</h2>
            <p class="text-lg text-purple-200 mb-6 leading-relaxed">
              塔罗牌是古老的智慧结晶，能够帮助您探索内心深处的答案。<br>
              在开始占卜之前，请静下心来，专注于您想要了解的问题。
            </p>
          </div>

          <!-- 问题输入 -->
          <div class="mb-8">
            <!-- 弹幕高频问题区域 -->
            <div class="mb-6">
              <div class="text-center mb-4">
                <h3 class="text-lg font-medium text-purple-200 mb-2">💫 高频问题弹幕</h3>
                <p class="text-sm text-purple-300">点击飘过的问题可快速填充，悬停可点赞</p>
              </div>
              <div 
                ref="barrageArea"
                class="barrage-area relative w-full h-32 overflow-hidden bg-white/5 rounded-xl border border-purple-400/30 shadow-inner"
              ></div>
            </div>
            
            <label class="block text-white text-lg font-medium mb-4">
              💭 请输入您想要咨询的问题（可选）
            </label>
            <textarea 
              ref="questionInput"
              v-model="userQuestion"
              placeholder="例如：我的事业发展如何？我的感情运势怎样？我应该如何面对当前的困境？"
              class="w-full h-32 px-4 py-3 bg-white/10 border border-purple-400/50 rounded-lg text-white placeholder-purple-300 focus:outline-none focus:border-purple-400 focus:ring-2 focus:ring-purple-400/50 resize-none"
            ></textarea>
          </div>

          <div class="text-center">
            <button 
              @click="goToSpreadSelection" 
              class="bg-gradient-to-r from-purple-600 to-pink-600 text-white text-xl font-bold py-4 px-12 rounded-full shadow-lg hover:shadow-2xl transform hover:scale-105 transition-all duration-300 mystical-glow"
            >
              🎴 选择牌阵
            </button>
          </div>
        </div>
      </div>

      <!-- 阶段1.5: 牌阵选择 -->
      <div v-if="currentStage === 'spreadSelection'" class="max-w-6xl mx-auto">
        <div class="bg-black/30 backdrop-blur-md rounded-3xl p-8 border border-purple-500/30 shadow-2xl">
          <div class="text-center mb-12">
            <div class="text-5xl mb-6 animate-pulse">🔮</div>
            <h2 class="text-3xl font-bold text-white mb-4">选择您的专属牌阵</h2>
            <p class="text-lg text-purple-200 mb-8">每个牌阵都有其独特的智慧与启示，请根据您的问题选择最适合的牌阵</p>
          </div>

          <!-- 牌阵选择网格 -->
          <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-8">
            <div 
              v-for="(spread, index) in classicSpreads" 
              :key="spread.name"
              class="spread-card cursor-pointer transform transition-all duration-300 hover:scale-105 hover:-translate-y-2"
              :class="{ 'selected': selectedSpread?.name === spread.name }"
              @click="selectSpread(spread)"
            >
              <div class="bg-gradient-to-br from-purple-800/50 to-indigo-900/50 backdrop-blur-sm rounded-2xl p-6 border border-purple-400/30 shadow-xl h-full flex flex-col">
                <!-- 牌阵头部 -->
                <div class="text-center mb-4">
                  <div class="text-4xl mb-3">{{ getSpreadIcon(spread.name) }}</div>
                  <h3 class="text-xl font-bold text-white mb-2">{{ spread.chineseName }}</h3>
                  <div class="text-sm text-purple-300 mb-4">{{ spread.positions.length }}张牌</div>
                </div>

                <!-- 核心优势 - 最突出的位置 -->
                <div class="bg-gradient-to-r from-yellow-400/20 to-orange-400/20 rounded-xl p-4 mb-4 border border-yellow-400/40">
                  <div class="text-center">
                    <div class="text-yellow-200 text-sm font-bold mb-2 flex items-center justify-center">
                      <span class="mr-2">⭐</span>
                      <span>最擅长解决</span>
                    </div>
                    <div class="text-yellow-100 text-base font-semibold">{{ spread.bestFor[0] }}</div>
                  </div>
                </div>

                <!-- 其他适用场景 -->
                <div class="mb-4 flex-1">
                  <div class="text-purple-300 text-xs mb-2 text-center opacity-80">也适用于</div>
                  <div class="flex flex-wrap gap-1 justify-center">
                    <span 
                      v-for="purpose in spread.bestFor.slice(1, 3)" 
                      :key="purpose"
                      class="px-3 py-1 text-xs bg-purple-600/30 text-purple-200 rounded-full border border-purple-500/30"
                    >
                      {{ purpose }}
                    </span>
                  </div>
                </div>

                <!-- 简化描述 - 放在最底部 -->
                <div class="mt-auto pt-3 border-t border-purple-500/20">
                  <p class="text-xs text-purple-400 text-white opacity-80 leading-relaxed break-words">
                    {{ spread.description.length > 40 ? spread.description.slice(0, 40) + '...' : spread.description }}
                  </p>
                </div>
              </div>
            </div>
          </div>

          <!-- 选中牌阵详情 -->
          <div v-if="selectedSpread" class="bg-purple-900/20 rounded-2xl p-6 mb-8 border border-purple-400/20">
            <h3 class="text-2xl font-bold text-white mb-4 text-center">{{ selectedSpread.chineseName }} 详细说明</h3>
            <p class="text-purple-200 mb-6 text-center leading-relaxed">{{ selectedSpread.description }}</p>
            
            <!-- 牌位说明 -->
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
              <div 
                v-for="(position, index) in selectedSpread.positions" 
                :key="index"
                class="bg-black/20 rounded-lg p-4 border border-purple-400/20"
              >
                <div class="text-center">
                  <div class="text-2xl mb-2">{{ index + 1 }}</div>
                  <h4 class="text-white font-medium mb-2">{{ position.chineseName }}</h4>
                  <p class="text-purple-300 text-sm">{{ position.meaning }}</p>
                </div>
              </div>
            </div>
          </div>

          <!-- 操作按钮 -->
          <div class="flex justify-center space-x-6">
            <button 
              @click="goBackToIntro" 
              class="bg-gray-600 hover:bg-gray-700 text-white text-lg font-medium py-3 px-8 rounded-full transition-colors duration-300"
            >
              ← 返回
            </button>
            <button 
              @click="startReading" 
              :disabled="!selectedSpread"
              class="bg-gradient-to-r from-purple-600 to-pink-600 text-white text-lg font-bold py-3 px-12 rounded-full shadow-lg hover:shadow-2xl transform hover:scale-105 transition-all duration-300 mystical-glow disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none"
            >
              🎴 开始占卜
            </button>
          </div>
        </div>
      </div>

      <!-- 阶段2: 洗牌动画 -->
      <div v-if="currentStage === 'shuffling'" class="max-w-4xl mx-auto text-center relative overflow-hidden">
        <div class="bg-black/30 backdrop-blur-md rounded-3xl p-12 border border-purple-500/30 shadow-2xl relative">
          
          <!-- 漂浮卡牌背景 -->
          <div class="absolute inset-0 pointer-events-none overflow-hidden rounded-3xl">
            <div v-for="n in 8" :key="n" 
                 class="floating-card absolute opacity-20"
                 :style="getFloatingCardStyle(n)">
              <div class="floating-card-back"></div>
            </div>
          </div>
          
          <!-- 能量粒子背景 -->
          <div class="absolute inset-0 pointer-events-none overflow-hidden rounded-3xl">
            <div v-for="n in 15" :key="n"
                 class="energy-particle absolute text-purple-300 opacity-60"
                 :style="getEnergyParticleStyle(n)">
              ✨
            </div>
          </div>
          
          <!-- 主要内容 -->
          <div class="relative z-10">
            <div class="text-6xl mb-6 animate-pulse">🌀</div>
            <h2 class="text-3xl font-bold text-white mb-4">正在洗牌...</h2>
            <p class="text-lg text-purple-200 mb-8">请专注于您的问题，让宇宙的能量流入牌中</p>
            
            <!-- 神秘进度条 -->
            <div class="mystical-progress-container mb-8">
              <div class="mystical-progress-bar">
                <div class="progress-fill"></div>
                <div class="progress-glow"></div>
              </div>
              <div class="progress-text text-purple-300 text-sm mt-2">
                感受宇宙的能量流动...
              </div>
            </div>
            
            <!-- 能量波纹效果 -->
            <div class="energy-ripples">
              <div class="ripple"></div>
              <div class="ripple"></div>
              <div class="ripple"></div>
            </div>
          </div>
        </div>
      </div>

      <!-- 阶段3: 抽牌 -->
      <div v-if="currentStage === 'drawing'" class="max-w-6xl mx-auto">
        <div class="bg-black/30 backdrop-blur-md rounded-3xl p-8 border border-purple-500/30 shadow-2xl">
          <div class="text-center mb-8">
            <h2 class="text-3xl font-bold text-white mb-4">✨ 选择您的命运之牌</h2>
            <p class="text-lg text-purple-200 mb-6">请用心感受，点击下方的牌来抽取您的{{ selectedSpread?.positions.length || 3 }}张牌</p>
            <p class="text-purple-300">已抽取: {{ drawnCards.length }} / {{ selectedSpread?.positions.length || 3 }}</p>
          </div>

          <!-- 牌堆展示 -->
          <div class="deck-spread flex justify-center items-center mb-8 flex-wrap gap-4">
            <div 
              v-for="n in Math.max(7, selectedSpread?.positions.length || 3)" 
              :key="n"
              class="deck-card cursor-pointer transform transition-all duration-500 hover:scale-110 hover:-translate-y-4"
              @click="drawCard(n)"
            >
              <div class="w-24 h-36 rounded-lg shadow-lg border border-purple-400/50 overflow-hidden">
                <div class="card-back w-full h-full transform hover:scale-105 transition-transform duration-300"></div>
              </div>
            </div>
          </div>

          <!-- 已抽取的牌位 -->
          <div class="drawn-positions mt-12">
            <div class="grid gap-4 grid-cols-1 md:grid-cols-3">
              <div 
                v-for="(position, index) in positions" 
                :key="index"
                class="position-slot"
              >
                <div class="text-center mb-4">
                  <h3 class="text-lg font-bold text-white mb-2">{{ position }}</h3>
                </div>
                <div 
                  class="card-slot w-28 h-40 mx-auto rounded-lg border-2 border-dashed border-purple-400/50 flex items-center justify-center"
                  :class="{ 'filled': drawnCards[index] }"
                >
                  <div v-if="!drawnCards[index]" class="text-purple-400 text-5xl opacity-50">?</div>
                  <div 
                    v-else 
                    class="drawn-card-preview w-full h-full bg-gradient-to-br from-purple-800 to-indigo-900 rounded-lg flex flex-col items-center justify-center transform animate-flip-in relative overflow-hidden border border-purple-400/50"
                  >
                    <div class="relative z-10 text-center">
                      <div class="text-white text-2xl mb-1 animate-pulse">🌟</div>
                      <div class="text-white/60 text-xs font-medium">已选择</div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <div v-if="drawnCards.length === (selectedSpread?.positions.length || 3)" class="text-center mt-8">
            <button 
              @click="revealCards" 
              class="bg-gradient-to-r from-pink-600 to-red-600 text-white text-xl font-bold py-4 px-12 rounded-full shadow-lg hover:shadow-2xl transform hover:scale-105 transition-all duration-300 mystical-glow"
            >
              ✨ 揭示命运
            </button>
          </div>
        </div>
      </div>

      <!-- 阶段4: 翻牌和解读 -->
      <div v-if="currentStage === 'reveal'" class="max-w-6xl mx-auto">
        <div class="bg-black/30 backdrop-blur-md rounded-3xl p-8 border border-purple-500/30 shadow-2xl">
          <h1 class="text-white text-5xl text-center">🎴 命运解读</h1>
          <p class="text-white text-center mt-4">您的塔罗牌已经揭示，让我们来解读命运的启示...</p>
          
          <!-- LLM加载状态显示 -->
          <div v-if="llmLoading" class="mt-8 mb-8">
            <div class="bg-gradient-to-r from-purple-600/20 to-indigo-600/20 rounded-2xl p-6 border border-purple-400/30">
              <div class="flex items-center justify-center mb-4">
                <div class="w-8 h-8 border-4 border-purple-400 border-t-transparent rounded-full animate-spin mr-3"></div>
                <h3 class="text-xl font-bold text-white">正在生成专业解读...</h3>
              </div>
              <div class="text-center">
                <p class="text-purple-200 mb-2">{{ llmLoadingMessage }}</p>
                <div class="w-full bg-purple-900/30 rounded-full h-2">
                  <div class="bg-gradient-to-r from-purple-500 to-pink-500 h-2 rounded-full transition-all duration-500" 
                       :class="{
                         'w-1/4': llmLoadingStage === 'preparing',
                         'w-2/4': llmLoadingStage === 'calling', 
                         'w-3/4': llmLoadingStage === 'processing',
                         'w-full': llmLoadingStage === 'completed'
                       }"></div>
                </div>
                <p class="text-purple-300 text-sm mt-2">请耐心等待，AI正在为您量身定制深度解读</p>
              </div>
            </div>
          </div>
          
          <!-- 问题回顾 -->
          <div class="mt-6 text-center">
            <div class="inline-block bg-gradient-to-r from-purple-600/30 to-pink-600/30 backdrop-blur-sm rounded-2xl px-6 py-3 border border-purple-400/30">
              <span class="text-purple-200 text-sm">您的问题：</span>
              <span class="text-white font-medium ml-2">{{ userQuestion }}</span>
            </div>
          </div>
          
          <!-- 显示抽到的牌 -->
          <div class="mt-8" v-if="interpretationResult">
            <h2 class="text-2xl font-bold text-white text-center mb-6">您抽到的牌</h2>
            
            <!-- 根据牌阵类型调整布局 -->
            <div v-if="selectedSpread?.name === 'Love Pyramid Spread'" class="relative max-w-4xl mx-auto">
              <!-- 恋人金字塔特殊布局 -->
              <div class="flex flex-col items-center space-y-6">
                <!-- 第一层：你的内心 -->
                <div class="flex justify-center">
                  <div class="card-container" v-if="interpretationResult.cards[0]">
                    <!-- 牌位标题 - 移到卡牌上方 -->
                    <div class="position-title-header mb-3 text-center">
                      <div class="inline-block bg-gradient-to-r from-purple-600/80 to-indigo-600/80 backdrop-blur-sm rounded-full px-4 py-2 border border-purple-400/40">
                        <span class="text-white font-bold text-sm">{{ interpretationResult.cards[0].position }}</span>
                      </div>
                    </div>
                    
                    <div class="tarot-card-container relative" :class="[
                      interpretationResult.cards[0].category === 'major' ? 'major-arcana' : 'minor-arcana',
                      `element-${interpretationResult.cards[0].element}`
                    ]">
                      <!-- 卡牌图片容器 - 移除位置覆盖层 -->
                      <div class="card-image-container mb-4 relative">
                        <img 
                          :src="interpretationResult.cards[0].imageUrl" 
                          :alt="interpretationResult.cards[0].name" 
                          class="tarot-card-image w-full h-48 object-cover rounded-lg"
                          @error="handleImageError"
                        />
                        <!-- 元素标记 -->
                        <div class="element-badge" :class="`element-${interpretationResult.cards[0].element}`">
                          {{ getElementSymbol(interpretationResult.cards[0].element) }}
                        </div>
                      </div>
                      
                      <!-- 卡牌基本信息 -->
                      <div class="card-info text-center">
                        <div class="text-purple-200 mb-2 font-semibold">{{ interpretationResult.cards[0].name }}</div>
                        <div class="text-sm text-purple-300 mb-3">{{ interpretationResult.cards[0].englishName }}</div>
                        <div class="text-xs text-purple-200 mb-2">
                          关键词: {{ getDisplayKeywords(interpretationResult.cards[0].keywords) }}
                        </div>
                        <!-- 卡牌解读悬停显示 -->
                        <div class="text-xs text-purple-300 cursor-help hover:text-purple-100 transition-colors duration-200" 
                             @mouseenter="showCardTooltip($event, interpretationResult.cards[0])"
                             @mouseleave="hideCardTooltip">
                          📖 卡牌解读
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                
                <!-- 第二层：对方内心 + 关系基础 -->
                <div class="flex justify-center space-x-8">
                  <div class="card-container" v-if="interpretationResult.cards[1]">
                    <!-- 牌位标题 - 移到卡牌上方 -->
                    <div class="position-title-header mb-3 text-center">
                      <div class="inline-block bg-gradient-to-r from-purple-600/80 to-indigo-600/80 backdrop-blur-sm rounded-full px-4 py-2 border border-purple-400/40">
                        <span class="text-white font-bold text-sm">{{ interpretationResult.cards[1].position }}</span>
                      </div>
                    </div>
                    
                    <div class="tarot-card-container relative" :class="[
                      interpretationResult.cards[1].category === 'major' ? 'major-arcana' : 'minor-arcana',
                      `element-${interpretationResult.cards[1].element}`
                    ]">
                      <div class="card-image-container mb-4 relative">
                        <img 
                          :src="interpretationResult.cards[1].imageUrl" 
                          :alt="interpretationResult.cards[1].name" 
                          class="tarot-card-image w-full h-48 object-cover rounded-lg"
                          @error="handleImageError"
                        />
                        <div class="element-badge" :class="`element-${interpretationResult.cards[1].element}`">
                          {{ getElementSymbol(interpretationResult.cards[1].element) }}
                        </div>
                      </div>
                      <div class="card-info text-center">
                        <div class="text-purple-200 mb-2 font-semibold">{{ interpretationResult.cards[1].name }}</div>
                        <div class="text-sm text-purple-300 mb-3">{{ interpretationResult.cards[1].englishName }}</div>
                        <div class="text-xs text-purple-200 mb-2">
                          关键词: {{ getDisplayKeywords(interpretationResult.cards[1].keywords) }}
                        </div>
                        <!-- 卡牌解读悬停显示 -->
                        <div class="text-xs text-purple-300 cursor-help hover:text-purple-100 transition-colors duration-200" 
                             @mouseenter="showCardTooltip($event, interpretationResult.cards[1])"
                             @mouseleave="hideCardTooltip">
                          📖 卡牌解读
                        </div>
                      </div>
                    </div>
                  </div>
                  
                  <div class="card-container" v-if="interpretationResult.cards[2]">
                    <!-- 牌位标题 - 移到卡牌上方 -->
                    <div class="position-title-header mb-3 text-center">
                      <div class="inline-block bg-gradient-to-r from-purple-600/80 to-indigo-600/80 backdrop-blur-sm rounded-full px-4 py-2 border border-purple-400/40">
                        <span class="text-white font-bold text-sm">{{ interpretationResult.cards[2].position }}</span>
                      </div>
                    </div>
                    
                    <div class="tarot-card-container relative" :class="[
                      interpretationResult.cards[2].category === 'major' ? 'major-arcana' : 'minor-arcana',
                      `element-${interpretationResult.cards[2].element}`
                    ]">
                      <div class="card-image-container mb-4 relative">
                        <img 
                          :src="interpretationResult.cards[2].imageUrl" 
                          :alt="interpretationResult.cards[2].name" 
                          class="tarot-card-image w-full h-48 object-cover rounded-lg"
                          @error="handleImageError"
                        />
                        <div class="element-badge" :class="`element-${interpretationResult.cards[2].element}`">
                          {{ getElementSymbol(interpretationResult.cards[2].element) }}
                        </div>
                      </div>
                      <div class="card-info text-center">
                        <div class="text-purple-200 mb-2 font-semibold">{{ interpretationResult.cards[2].name }}</div>
                        <div class="text-sm text-purple-300 mb-3">{{ interpretationResult.cards[2].englishName }}</div>
                        <div class="text-xs text-purple-200 mb-2">
                          关键词: {{ getDisplayKeywords(interpretationResult.cards[2].keywords) }}
                        </div>
                        <!-- 卡牌解读悬停显示 -->
                        <div class="text-xs text-purple-300 cursor-help hover:text-purple-100 transition-colors duration-200" 
                             @mouseenter="showCardTooltip($event, interpretationResult.cards[2])"
                             @mouseleave="hideCardTooltip">
                          📖 卡牌解读
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                
                <!-- 第三层：关系未来 -->
                <div class="flex justify-center">
                  <div class="card-container" v-if="interpretationResult.cards[3]">
                    <!-- 牌位标题 - 移到卡牌上方 -->
                    <div class="position-title-header mb-3 text-center">
                      <div class="inline-block bg-gradient-to-r from-purple-600/80 to-indigo-600/80 backdrop-blur-sm rounded-full px-4 py-2 border border-purple-400/40">
                        <span class="text-white font-bold text-sm">{{ interpretationResult.cards[3].position }}</span>
                      </div>
                    </div>
                    
                    <div class="tarot-card-container relative" :class="[
                      interpretationResult.cards[3].category === 'major' ? 'major-arcana' : 'minor-arcana',
                      `element-${interpretationResult.cards[3].element}`
                    ]">
                      <div class="card-image-container mb-4 relative">
                        <img 
                          :src="interpretationResult.cards[3].imageUrl" 
                          :alt="interpretationResult.cards[3].name" 
                          class="tarot-card-image w-full h-48 object-cover rounded-lg"
                          @error="handleImageError"
                        />
                        <div class="element-badge" :class="`element-${interpretationResult.cards[3].element}`">
                          {{ getElementSymbol(interpretationResult.cards[3].element) }}
                        </div>
                      </div>
                      <div class="card-info text-center">
                        <div class="text-purple-200 mb-2 font-semibold">{{ interpretationResult.cards[3].name }}</div>
                        <div class="text-sm text-purple-300 mb-3">{{ interpretationResult.cards[3].englishName }}</div>
                        <div class="text-xs text-purple-200 mb-2">
                          关键词: {{ getDisplayKeywords(interpretationResult.cards[3].keywords) }}
                        </div>
                        <!-- 卡牌解读悬停显示 -->
                        <div class="text-xs text-purple-300 cursor-help hover:text-purple-100 transition-colors duration-200" 
                             @mouseenter="showCardTooltip($event, interpretationResult.cards[3])"
                             @mouseleave="hideCardTooltip">
                          📖 卡牌解读
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- 其他牌阵的优化布局 -->
            <div v-else class="grid gap-6" :class="getCardLayoutClass(interpretationResult.cards.length)">
              <div 
                v-for="(card, index) in interpretationResult.cards" 
                :key="index"
                class="text-center"
              >
                <!-- 牌位标题 - 移到卡牌上方 -->
                <div class="position-title-header mb-3 text-center">
                  <div class="inline-block bg-gradient-to-r from-purple-600/80 to-indigo-600/80 backdrop-blur-sm rounded-full px-4 py-2 border border-purple-400/40">
                    <span class="text-white font-bold text-sm">{{ card.position }}</span>
                  </div>
                </div>
                
                <div class="tarot-card-container relative" :class="[
                  card.category === 'major' ? 'major-arcana' : 'minor-arcana',
                  `element-${card.element}`
                ]">
                  <!-- 卡牌图片容器 - 移除位置覆盖层 -->
                  <div class="card-image-container mb-4 relative">
                    <img 
                      :src="card.imageUrl" 
                      :alt="card.name" 
                      :class="getCardImageClass(interpretationResult.cards.length)"
                      @error="handleImageError"
                    />
                    <!-- 元素标记 -->
                    <div class="element-badge" :class="`element-${card.element}`">
                      {{ getElementSymbol(card.element) }}
                    </div>
                  </div>
                  
                  <!-- 卡牌基本信息 -->
                  <div class="card-info text-center">
                    <div class="text-purple-200 mb-2 font-semibold">{{ card.name }}</div>
                    <div class="text-sm text-purple-300 mb-3">{{ card.englishName }}</div>
                    <div class="text-xs text-purple-200 mb-2">
                      关键词: {{ getDisplayKeywords(card.keywords) }}
                    </div>
                    <!-- 卡牌解读悬停显示 -->
                    <div class="text-xs text-purple-300 cursor-help hover:text-purple-100 transition-colors duration-200" 
                         @mouseenter="showCardTooltip($event, card)"
                         @mouseleave="hideCardTooltip">
                      📖 卡牌解读
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <!-- 卡牌详细信息悬停提示框 -->
          <div 
            v-if="tooltipVisible" 
            ref="cardTooltip"
            class="card-tooltip"
            :style="tooltipStyle"
          >
            <div class="tooltip-content">
              <div class="flex items-center gap-2 mb-2">
                <h4 class="font-bold text-white text-lg">{{ tooltipCard?.name }}</h4>
                <span v-if="tooltipCard?.position" class="text-xs bg-purple-600/80 px-2 py-1 rounded-full text-white">
                  {{ tooltipCard.position }}
                </span>
              </div>
              
              <div class="text-sm text-purple-200 mb-3 leading-relaxed">
                <strong class="text-purple-100">关键词:</strong> {{ tooltipCard?.keywords || '神秘, 智慧, 指引' }}
              </div>
              
              <!-- 显示完整的卡牌解读 -->
              <div class="text-sm text-gray-200 leading-relaxed space-y-2">
                <div v-for="(paragraph, index) in formatInterpretationContent(tooltipCard?.fullInterpretation || tooltipCard?.meaning || '')" 
                     :key="index" 
                     class="text-sm leading-relaxed">
                  {{ paragraph }}
                </div>
              </div>
            </div>
          </div>
          
          <!-- 整体解读 -->
          <div class="mt-12" v-if="interpretationResult">
            <div class="bg-gradient-to-br from-indigo-900/40 to-purple-900/40 backdrop-blur-sm rounded-2xl p-6 border border-indigo-400/30 shadow-xl space-y-6">
              
              <!-- 新增：动态解读板块渲染 -->
              <div 
                v-for="(section, index) in interpretationResult.sections" 
                :key="index"
                class="bg-black/20 rounded-xl p-5 border border-purple-400/20"
              >
                <h3 class="text-2xl font-bold text-white mb-4 text-center flex items-center justify-center gap-2">
                  {{ section.icon }} {{ section.title }}
                </h3>
                <div class="text-lg text-gray-200 leading-relaxed prose prose-invert max-w-none">
                  <div v-html="formatMarkdownContent(section.content)" class="space-y-3"></div>
                </div>
              </div>

            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, onBeforeMount, nextTick, onUnmounted } from 'vue';
import { storyTarotDeck, type StoryTarotCard } from '../utils/storyTarotData';
import { classicSpreads, type TarotSpread } from '../utils/tarotInterpretation';
import { useAIReading } from '../../../composables/useAIReading';
import { useLLMConfigStore } from '../../../store/llmConfig';
import kabeiImage from '../../../assets/kabei.jpg';
import type { EnhancedTarotInterpretation, InterpretationSection } from '../../../services/LLMService';
import { marked } from 'marked';

// 解读结果类型定义 - 重构为包含动态板块的结构
interface ProcessedInterpretation {
  cards: Array<{
    name: string;
    englishName: string;
    position: string;
    meaning: string;
    keywords: string;
    imageUrl: string;
    category: string;
    element: string;
    fullInterpretation?: string;
  }>;
  sections: InterpretationSection[];
}

// 阶段管理
type Stage = 'intro' | 'spreadSelection' | 'shuffling' | 'drawing' | 'reveal';
const currentStage = ref<Stage>('intro');

// 牌阵相关
const selectedSpread = ref<TarotSpread | null>(null);

// 基础数据
const userQuestion = ref('');
const positions = ref<string[]>(['过去', '现在', '未来']);
const drawnCards = ref<StoryTarotCard[]>([]);
const revealedCards = ref<boolean[]>([false, false, false]);

// 弹幕相关
const barrageArea = ref<HTMLElement | null>(null);
const questionInput = ref<HTMLTextAreaElement | null>(null);

// 定义弹幕项类型
interface BarrageItem {
  el: HTMLDivElement;
  text: string;
  likes: number;
  row: number;
  x: number;
  y: number;
  width: number;
  speed: number;
  paused: boolean;
}

const barrageItems = ref<BarrageItem[]>([]);
let animationFrame: number | null = null;

// 高频问题数据
const suggestions = ref([
  { text: '我的事业发展如何？', likes: 2 },
  { text: '我的感情运势怎样？', likes: 5 },
  { text: '近期财运如何？', likes: 1 },
  { text: '我该如何面对当前的困境？', likes: 3 },
  { text: '未来三个月会有什么新机会？', likes: 0 },
  { text: '我与某某的关系会如何发展？', likes: 1 },
  { text: '需要注意哪些健康问题？', likes: 0 },
  { text: '目前的选择是否正确？', likes: 0 },
  { text: '我的学业运势如何？', likes: 2 },
  { text: '什么时候会遇到真爱？', likes: 4 },
  { text: '我适合换工作吗？', likes: 1 },
  { text: '家庭关系如何改善？', likes: 0 },
  { text: '投资理财要注意什么？', likes: 1 },
  { text: '我的人际关系怎样？', likes: 0 },
  { text: '如何提升个人运势？', likes: 2 },
  { text: '今年会有什么重大变化？', likes: 1 }
]);

// 弹幕配置 - 优化速度基准和智能分配
const BARRAGE_ROWS = 4; // 弹幕行数
const BARRAGE_HEIGHT = 120; // 弹幕区域总高度
const ROW_HEIGHT = 30; // 每行高度
const SPEED_MIN = 40; // 最小速度 (px/s)
const SPEED_MAX = 65; // 最大速度 (px/s)

// 智能行分配状态管理
interface BarrageRowState {
  isOccupied: boolean;
  lastItemEndTime: number;
  lastItemWidth: number;
  currentItems: number;
}

const rowStates = ref<BarrageRowState[]>(
  Array.from({ length: BARRAGE_ROWS }, () => ({
    isOccupied: false,
    lastItemEndTime: 0,
    lastItemWidth: 0,
    currentItems: 0
  }))
);

// 音效控制
const soundEnabled = ref(true);

// LLM加载状态
const llmLoading = ref(false);
const llmLoadingMessage = ref('');
const llmLoadingStage = ref<'preparing' | 'calling' | 'processing' | 'completed' | 'error'>('preparing');

// 解读结果 - 使用新的、灵活的接口
const interpretationResult = ref<ProcessedInterpretation | null>(null);

// 使用 useAIReading Composable
const { 
  interpretationResult: rawInterpretation, 
  isLoading: llmLoading, 
  loadingMessage: llmLoadingMessage, 
  loadingStage: llmLoadingStage,
  getTarotReading 
} = useAIReading();

// 方法定义
function goToSpreadSelection() {
  currentStage.value = 'spreadSelection';
}

function goBackToIntro() {
  currentStage.value = 'intro';
}

function selectSpread(spread: TarotSpread) {
  selectedSpread.value = spread;
  positions.value = spread.positions.map(p => p.chineseName);
  revealedCards.value = new Array(spread.positions.length).fill(false);
}

function getSpreadIcon(spreadName: string): string {
  const icons: Record<string, string> = {
    'Three Card Spread': '🔮',
    'Celtic Cross': '✨',
    'Love Pyramid Spread': '💕',
    'Career Path Spread': '🌟',
    'Decision Making Spread': '⚖️',
    'Past Present Future': '🕰️',
    'Relationship Spread': '💖'
  };
  return icons[spreadName] || '🎴';
}

// 弹幕相关方法
function initBarrage() {
  if (!barrageArea.value) return;
  
  // 立即生成第一批弹幕，提升用户进入体验
  setTimeout(() => addBarrageItem(), 100);
  setTimeout(() => addBarrageItem(), 300);
  setTimeout(() => addBarrageItem(), 500);
  
  // 启动弹幕动画循环
  startBarrageAnimation();
  
  // 智能生成新弹幕 - 动态间隔避免拥挤
  const generateBarrage = () => {
    if (barrageItems.value.length < 10) { // 限制同时显示的弹幕数量
      addBarrageItem();
    }
    
    // 动态间隔：根据当前弹幕数量调整生成频率
    const currentCount = barrageItems.value.length;
    const baseInterval = 1200;
    const dynamicInterval = baseInterval + (currentCount * 200); // 弹幕越多，间隔越长
    
    setTimeout(generateBarrage, Math.min(dynamicInterval, 3000));
  };
  
  // 启动智能生成循环
  setTimeout(generateBarrage, 800);
}

function startBarrageAnimation() {
  let lastTime = performance.now();
  
  function animate(currentTime: number) {
    const deltaTime = currentTime - lastTime;
    lastTime = currentTime;
    
    // 使用倒序遍历避免数组索引混乱
    for (let i = barrageItems.value.length - 1; i >= 0; i--) {
      const item = barrageItems.value[i];
      
      if (!item.paused) {
        // 基于时间的移动计算
        item.x -= (item.speed * deltaTime) / 1000;
        
        // 如果弹幕完全移出屏幕，移除它
        if (item.x + item.width < 0) {
          item.el.remove();
          barrageItems.value.splice(i, 1);
          
          // 更新行状态：减少当前行的弹幕计数
          if (rowStates.value[item.row]) {
            rowStates.value[item.row].currentItems = Math.max(0, rowStates.value[item.row].currentItems - 1);
            
            // 如果行中没有弹幕了，重置占用状态
            if (rowStates.value[item.row].currentItems === 0) {
              rowStates.value[item.row].isOccupied = false;
            }
          }
          continue;
        }
        
        // 更新位置 - 使用transform确保平滑移动
        item.el.style.transform = `translateX(${item.x}px)`;
      }
    }
    
    animationFrame = requestAnimationFrame(animate);
  }
  
  animate(lastTime);
}

function addBarrageItem() {
  if (!barrageArea.value) return;
  
  const suggestion = suggestions.value[Math.floor(Math.random() * suggestions.value.length)];
  
  // 智能行分配 - 选择最空闲的行，避免重叠
  const getOptimalRow = (): number => {
    const currentTime = performance.now();
    const containerWidth = barrageArea.value!.offsetWidth;
    
    // 预估文本宽度（基于字符数量的粗略估算）
    const estimatedWidth = Math.min(suggestion.text.length * 16 + 80, 320);
    
    // 找到最适合的行
    let bestRow = 0;
    let minOccupancy = Infinity;
    
    for (let i = 0; i < BARRAGE_ROWS; i++) {
      const rowState = rowStates.value[i];
      
      // 计算此行的占用度评分（越低越好）
      let occupancyScore = rowState.currentItems * 100;
      
      // 如果行中有未完全移出的弹幕，增加惩罚
      if (rowState.isOccupied && currentTime < rowState.lastItemEndTime) {
        const timeRemaining = rowState.lastItemEndTime - currentTime;
        occupancyScore += timeRemaining / 10; // 时间惩罚
      }
      
      // 检查空间是否足够
      const spaceNeeded = estimatedWidth + 50; // 额外间距
      const timeForSpace = (spaceNeeded / SPEED_MIN) * 1000; // 需要的时间
      
      if (currentTime > rowState.lastItemEndTime + timeForSpace) {
        occupancyScore -= 50; // 空间充足，奖励分数
      }
      
      if (occupancyScore < minOccupancy) {
        minOccupancy = occupancyScore;
        bestRow = i;
      }
    }
    
    return bestRow;
  };
  
  const row = getOptimalRow();
  
  const el = document.createElement('div');
  el.className = 'barrage-item absolute whitespace-nowrap cursor-pointer transition-all duration-200 hover:scale-105 select-none flex items-center gap-3';
  
  // 预设样式，避免闪现
  const containerWidth = barrageArea.value.offsetWidth;
  const initialX = containerWidth + 20;
  
  el.style.cssText = `
    top: ${row * ROW_HEIGHT}px;
    font-size: 16px;
    line-height: ${ROW_HEIGHT}px;
    height: ${ROW_HEIGHT - 4}px;
    color: rgba(196, 181, 253, 0.95);
    text-shadow: 0 0 6px rgba(147, 51, 234, 0.6);
    z-index: 10;
    padding: 6px 12px;
    background: rgba(0, 0, 0, 0.25);
    border-radius: 20px;
    border: 1px solid rgba(147, 51, 234, 0.4);
    backdrop-filter: blur(4px);
    will-change: transform;
    transform: translateX(${initialX}px);
  `;
  
  // 创建问题文本
  const textSpan = document.createElement('span');
  textSpan.textContent = suggestion.text;
  textSpan.className = 'barrage-text flex-1';
  
  // 创建Twitter风格的点赞按钮
  const likeButton = document.createElement('button');
  likeButton.className = 'like-button flex items-center gap-1 px-2 py-1 rounded-full transition-all duration-200 hover:bg-red-500/20 hover:scale-110';
  likeButton.innerHTML = `
    <svg class="w-4 h-4 transition-all duration-200 ${suggestion.likes > 0 ? 'text-red-500' : 'text-gray-400'}" 
         fill="${suggestion.likes > 0 ? 'currentColor' : 'none'}" 
         stroke="currentColor" 
         viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
            d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>
    </svg>
    <span class="text-xs font-medium ${suggestion.likes > 0 ? 'text-red-500' : 'text-gray-400'}">${suggestion.likes}</span>
  `;
  
  el.appendChild(textSpan);
  el.appendChild(likeButton);
  
  // 添加到DOM后获取宽度
  barrageArea.value.appendChild(el);
  const width = el.offsetWidth;
  
  const item: BarrageItem = {
    el,
    text: suggestion.text,
    likes: suggestion.likes,
    row,
    x: initialX,
    y: row * ROW_HEIGHT,
    width,
    speed: SPEED_MIN + Math.random() * (SPEED_MAX - SPEED_MIN),
    paused: false
  };
  
  // 添加事件监听
  let pausedX = 0;
  el.addEventListener('mouseenter', () => {
    item.paused = true;
    pausedX = item.x; // 保存暂停时的位置
    el.style.backgroundColor = 'rgba(147, 51, 234, 0.5)';
    el.style.transform = `translateX(${pausedX}px) scale(1.05)`;
    el.style.boxShadow = '0 4px 20px rgba(147, 51, 234, 0.4)';
  });
  
  el.addEventListener('mouseleave', () => {
    item.paused = false;
    el.style.backgroundColor = 'rgba(0, 0, 0, 0.25)';
    el.style.transform = `translateX(${pausedX}px) scale(1)`;
    el.style.boxShadow = 'none';
  });
  
  // 点击文本填充到输入框
  textSpan.addEventListener('click', (e) => {
    e.stopPropagation();
    userQuestion.value = item.text;
    if (questionInput.value) {
      questionInput.value.focus();
    }
    
    // 移除弹幕
    item.el.remove();
    const itemIndex = barrageItems.value.indexOf(item);
    if (itemIndex !== -1) {
      barrageItems.value.splice(itemIndex, 1);
    }
  });
  
  // 点击点赞按钮
  likeButton.addEventListener('click', (e) => {
    e.stopPropagation();
    
    // 增加点赞数
    const suggestionIndex = suggestions.value.findIndex(s => s.text === item.text);
    if (suggestionIndex !== -1) {
      suggestions.value[suggestionIndex].likes++;
      item.likes = suggestions.value[suggestionIndex].likes;
      
      // 更新显示 - Twitter风格动画
      const likeCount = likeButton.querySelector('span');
      const heartIcon = likeButton.querySelector('svg');
      if (likeCount && heartIcon) {
        likeCount.textContent = item.likes.toString();
        likeCount.className = 'text-xs font-medium text-red-500';
        
        heartIcon.setAttribute('fill', 'currentColor');
        heartIcon.setAttribute('class', 'w-4 h-4 transition-all duration-200 text-red-500');
        
        // Twitter风格的点赞动画
        likeButton.style.transform = 'scale(1.3)';
        heartIcon.style.transform = 'scale(1.2)';
        
        setTimeout(() => {
          likeButton.style.transform = 'scale(1)';
          heartIcon.style.transform = 'scale(1)';
        }, 200);
        
        // 添加小心心飞出效果
        const flyHeart = document.createElement('div');
        flyHeart.innerHTML = '❤️';
        flyHeart.style.cssText = `
          position: absolute;
          font-size: 12px;
          pointer-events: none;
          animation: fly-heart 1s ease-out forwards;
          left: 50%;
          top: 50%;
          transform: translate(-50%, -50%);
        `;
        likeButton.appendChild(flyHeart);
        
        setTimeout(() => {
          flyHeart.remove();
        }, 1000);
      }
    }
  });
  
  // 更新行状态管理
  const currentTime = performance.now();
  const moveDuration = (containerWidth + width) / item.speed * 1000; // 完全移出屏幕的时间
  
  rowStates.value[row].isOccupied = true;
  rowStates.value[row].lastItemEndTime = currentTime + moveDuration;
  rowStates.value[row].lastItemWidth = width;
  rowStates.value[row].currentItems++;
  
  // 添加到弹幕列表
  barrageItems.value.push(item);
}

function startReading() {
  if (!selectedSpread.value) return;
  currentStage.value = 'shuffling';
  
  // 模拟洗牌动画
  setTimeout(() => {
    currentStage.value = 'drawing';
  }, 3500);
}

// 抽牌逻辑...
const deck = ref<StoryTarotCard[]>([]);

function shuffleAndDeal() {
  deck.value = [...storyTarotDeck].sort(() => Math.random() - 0.5);
}

function drawCard(cardIndex: number) {
  if (!selectedSpread.value || drawnCards.value.length >= selectedSpread.value.positions.length) {
    return;
  }
  
  const card = deck.value.pop();
  if (card) {
    drawnCards.value.push(card);
    // 禁用被点击的卡牌
    const cardElement = document.querySelector(`.deck-card:nth-child(${cardIndex})`);
    if (cardElement) {
      cardElement.classList.add('drawn');
    }
  }
}

async function revealCards() {
  currentStage.value = 'reveal';
  await nextTick();
  
  if (!selectedSpread.value) return;

  try {
    const result = await getTarotReading(drawnCards.value, selectedSpread.value, userQuestion.value);
    
    if (result && result.base) {
      interpretationResult.value = processNewInterpretation(result, drawnCards.value, selectedSpread.value);
    } else {
      console.error('Failed to get interpretation or interpretation.base is missing');
      // 可以设置一个备用的、错误的解读结果
    }
  } catch (error) {
    console.error('Error revealing cards:', error);
     // 可以设置一个备用的、错误的解读结果
  }
}

// 悬停提示
const tooltipVisible = ref(false);
const tooltipCard = ref<any>(null);
const cardTooltip = ref<HTMLElement | null>(null);
const tooltipStyle = ref({
  left: '0px',
  top: '0px'
});

function showCardTooltip(event: MouseEvent, card: any) {
  tooltipCard.value = card;
  tooltipVisible.value = true;
  nextTick(() => {
    if (cardTooltip.value) {
      const target = event.currentTarget as HTMLElement;
      const targetRect = target.getBoundingClientRect();
      const tooltipRect = cardTooltip.value.getBoundingClientRect();
      
      let top = targetRect.bottom + window.scrollY + 10;
      let left = targetRect.left + window.scrollX - (tooltipRect.width / 2) + (targetRect.width / 2);

      // Boundary checks
      if (left < 0) left = 10;
      if (left + tooltipRect.width > window.innerWidth) {
        left = window.innerWidth - tooltipRect.width - 10;
      }
      if (top + tooltipRect.height > document.body.scrollHeight) {
        top = targetRect.top + window.scrollY - tooltipRect.height - 10;
      }
      
      tooltipStyle.value = {
        left: `${left}px`,
        top: `${top}px`
      };
    }
  });
}

function hideCardTooltip() {
  tooltipVisible.value = false;
}

// Markdown格式化
const formatMarkdownContent = (content: string) => {
  if (!content) return '';
  return marked(content, { gfm: true, breaks: true });
};

// 处理图片加载错误
function handleImageError(event: Event) {
  const img = event.target as HTMLImageElement;
  img.src = '/static/tarot/- 00_fool_jpg (愚者).png'; // 使用愚者牌作为默认图片
}

// 获取元素符号
function getElementSymbol(element: string): string {
  const symbols: Record<string, string> = {
    fire: '🔥',
    water: '💧',
    air: '💨',
    earth: '🌍'
  };
  return symbols[element] || '✨';
}

// 获取卡牌布局类
function getCardLayoutClass(cardCount: number): string {
  switch (cardCount) {
    case 1:
      return 'grid-cols-1';
    case 2:
      return 'grid-cols-1 md:grid-cols-2';
    case 3:
      return 'grid-cols-1 md:grid-cols-3';
    case 4:
      return 'grid-cols-1 md:grid-cols-2 lg:grid-cols-4';
    case 5:
      return 'grid-cols-1 md:grid-cols-2 lg:grid-cols-3';
    default:
      return 'grid-cols-1 md:grid-cols-2 lg:grid-cols-3';
  }
}

// 获取卡牌图片尺寸类
function getCardImageClass(cardCount: number): string {
  const baseClass = 'tarot-card-image w-full object-cover rounded-lg';
  switch (cardCount) {
    case 1:
    case 2:
    case 3:
      return `${baseClass} h-48`;
    case 4:
      return `${baseClass} h-40 lg:h-36`;
    case 5:
    case 6:
      return `${baseClass} h-36`;
    default:
      return `${baseClass} h-32`;
  }
}

// 生成漂浮卡牌样式
function getFloatingCardStyle(index: number): string {
  const positions = [
    { left: '10%', top: '15%' },
    { left: '85%', top: '25%' },
    { left: '15%', top: '70%' },
    { left: '75%', top: '80%' },
    { left: '45%', top: '10%' },
    { left: '65%', top: '60%' },
    { left: '25%', top: '45%' },
    { left: '80%', top: '45%' }
  ];
  
  const pos = positions[index - 1] || positions[0];
  const duration = 4 + (index * 0.5); // 4-8秒不等的动画时长
  const delay = index * 0.3; // 错开动画开始时间
  
  return `
    left: ${pos.left};
    top: ${pos.top};
    font-size: 2rem;
    animation: floatCard ${duration}s ease-in-out infinite ${delay}s;
    transform: rotate(${index * 15}deg);
  `;
}

// 生成能量粒子样式  
function getEnergyParticleStyle(index: number): string {
  const x = Math.random() * 100;
  const y = Math.random() * 100;
  const duration = 2 + Math.random() * 3; // 2-5秒随机时长
  const delay = Math.random() * 2; // 0-2秒随机延迟
  const scale = 0.5 + Math.random() * 0.5; // 0.5-1.0随机大小
  
  return `
    left: ${x}%;
    top: ${y}%;
    font-size: ${scale}rem;
    animation: sparkle ${duration}s ease-in-out infinite ${delay}s;
  `;
}

// 组件挂载时预加载LLM配置
onMounted(() => {
  // 提前初始化弹幕，提升用户体验
  initBarrage();
  shuffleAndDeal();
});

// 在组件创建阶段就开始准备弹幕数据
onBeforeMount(() => {
  // 预热弹幕系统，确保数据准备就绪
  console.log('🎯 塔罗页面初始化，准备弹幕系统...');
});

// 生成整体解读 - 专注牌面分析和牌阵含义
function generateOverallInterpretation(cards: any[], spread: TarotSpread, question: string): { title: string; content: string } {
  const cardCount = cards.length;
  const majorCount = cards.filter(card => card.category === 'major').length;
  const minorCount = cards.filter(card => card.category === 'minor').length;
  
  let reading = '';
  
  // 牌阵结构分析
  reading += `## 牌阵结构分析\n\n`;
  reading += `**${spread.chineseName}** 为您展现了关于"${question}"的完整画面。`;
  
  // 牌面组合分析
  reading += `\n\n## 牌面组合特征\n\n`;
  if (majorCount > minorCount) {
    reading += `🌟 **大阿尔卡纳主导** (${majorCount}/${cardCount}张)\n`;
    reading += `这表明您的问题涉及重大的人生课题和精神成长。宇宙正在为您开启重要的转折点，这不仅仅是表面问题的解决，更是灵魂层面的深度转化。`;
  } else if (minorCount > majorCount) {
    reading += `⚡ **小阿尔卡纳主导** (${minorCount}/${cardCount}张)\n`;
    reading += `这表明解决方案更多体现在日常行动和具体实践中。通过调整生活细节和改变行为模式，您能够有效地改善当前状况。`;
  } else {
    reading += `⚖️ **大小阿尔卡纳平衡** (${majorCount}:${minorCount})\n`;
    reading += `这显示了精神觉醒与实际行动的完美结合。您需要在内在成长和外在努力之间找到平衡点。`;
  }
  
  // 牌面能量流动分析
  reading += `\n\n## 能量流动趋势\n\n`;
  const cardNames = cards.map(card => card.chineseName || card.name);
  reading += `从 **${cardNames[0]}** 到 **${cardNames[cardNames.length - 1]}**，能量呈现出`;
  
  if (spread.chineseName === '三张牌占卜法') {
    reading += `时间线的发展轨迹，过去的积累正在转化为未来的可能性。`;
  } else if (spread.chineseName === '恋人金字塔') {
    reading += `情感关系的层次结构，从基础建立到未来发展的完整脉络。`;
  } else {
    reading += `多维度的展开模式，各个层面相互影响、相互支撑。`;
  }
  
  return {
    title: '整体解读',
    content: reading
  };
}

// 生成单牌解读
function generateCardInterpretations(cards: any[], spread: TarotSpread, question: string): any[] {
  return cards.map((card, index) => {
    const position = spread.positions[index];
    
    return {
      position: position.chineseName,
      cardName: card.name,
      interpretation: card.meaning
    };
  });
}

// 生成建议指导（降级版本）
function generateGuidance(cards: any[], question: string): { title: string; content: string } {
  return {
    title: '智慧指引与行动建议',
    content: `基于塔罗牌的指引，建议您保持开放的心态，相信内心的智慧。结合您的问题"${question}"，请仔细感受每张牌的能量，让宇宙的智慧为您指明前进的方向。`
  };
}

// 组件卸载时清理
onUnmounted(() => {
  if (animationFrame) {
    cancelAnimationFrame(animationFrame);
  }
});

// 使用全局AI解读composable和配置store
const { 
  getReading
} = useAIReading();
const llmConfigStore = useLLMConfigStore();

// 格式化解读内容 - 智能分段和结构化处理
function formatInterpretationContent(content: string): string[] {
  if (!content) return [];
  
  // 第一步：基础清理
  let cleanContent = content
    // 清理JSON残留
    .replace(/```json\s*/g, '')
    .replace(/```\s*/g, '')
    .replace(/^\s*{\s*$/gm, '')
    .replace(/^\s*}\s*$/gm, '')
    .replace(/^\s*"[^"]*":\s*/gm, '')
    .replace(/",?\s*$/gm, '')
    // 清理转义字符
    .replace(/\\"/g, '"')
    .replace(/\\n/g, '\n')
    .replace(/\\\//g, '/')
    .replace(/\\\\/g, '\\')
    // 标准化空白字符
    .replace(/\s+/g, ' ')
    .replace(/\n\s+/g, '\n')
    .trim();
  
  // 第二步：智能识别和处理markdown结构
  const sections: string[] = [];
  
  // 按markdown标题和结构分割
  const parts = cleanContent.split(/(?=##\s|###\s|\*\*[^*]+\*\*|^\d+\.\s|^[•·]\s)/gm);
  
  for (const part of parts) {
    const trimmedPart = part.trim();
    if (!trimmedPart || trimmedPart.length < 10) continue;
  
    // 处理标题
    if (trimmedPart.startsWith('##')) {
      sections.push(trimmedPart);
      continue;
    }
    
    // 处理有结构的内容
    if (trimmedPart.includes('**') || trimmedPart.includes('•') || trimmedPart.includes('：')) {
      // 保持结构化内容的完整性
      sections.push(trimmedPart);
      continue;
    }
    
    // 处理长段落 - 智能分割
    if (trimmedPart.length > 200) {
      const sentences = trimmedPart.split(/([。！？.!?]+\s*)/);
      let currentChunk = '';
    
    for (let i = 0; i < sentences.length; i += 2) {
      const sentence = sentences[i]?.trim() || '';
      const punctuation = sentences[i + 1]?.trim() || '';
      
      if (sentence) {
        const fullSentence = sentence + punctuation;
        
          if (currentChunk.length + fullSentence.length > 150 && currentChunk) {
            sections.push(currentChunk.trim());
            currentChunk = fullSentence;
        } else {
            currentChunk += (currentChunk ? ' ' : '') + fullSentence;
          }
        }
      }
      
      if (currentChunk.trim()) {
        sections.push(currentChunk.trim());
            }
          } else {
      sections.push(trimmedPart);
    }
  }
  
  // 第三步：后处理和优化
  const finalSections = sections
    .filter(section => {
      // 过滤无效内容
      const clean = section.replace(/[^\u4e00-\u9fff\w\s]/g, '').trim();
      return clean.length > 8;
    })
    .map(section => {
      // 优化格式
      return section
        .replace(/\s+/g, ' ')
        .replace(/([。！？.!?])\1+/g, '$1')
             .trim();
    })
    .filter(section => {
      // 最终过滤
      return section.length > 15 && 
             !section.match(/^[\s\.,，。！？!?]*$/) &&
             !section.includes('position') &&
             !section.includes('cardName') &&
             !section.includes('interpretation');
    });
  
  // 如果处理后没有有效内容，提供默认内容
  if (finalSections.length === 0) {
    return ['塔罗牌为您带来深刻的智慧与指引，每一张牌都蕴含着宇宙的神秘信息。'];
  }
  
  return finalSections;
}

// 新增：处理新版API返回结果的函数
function processNewInterpretation(
  raw: EnhancedTarotInterpretation, 
  drawnCards: StoryTarotCard[], 
  spread: TarotSpread
): ProcessedInterpretation {
  return {
    cards: drawnCards.map((card, index) => ({
      name: card.chineseName || card.name,
      englishName: card.name,
      position: spread.positions[index]?.chineseName || `位置 ${index + 1}`,
      meaning: card.meaning,
      keywords: Array.isArray(card.keywords) ? card.keywords.join(', ') : '',
      imageUrl: card.imageUrl,
      category: card.category,
      element: card.element,
      fullInterpretation: card.storyInterpretation || card.meaning
    })),
    sections: raw.base,
  };
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成基础降级解读（最后的保障）
function generateBasicFallbackInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): ProcessedInterpretation {
  const cardInfos = cards.map((card, index) => {
    const position = spread.positions[index];
    const keywords = Array.isArray(card.keywords) ? card.keywords.join(', ') : card.keywords;
    
    return {
      name: card.chineseName || card.name,
      englishName: card.name,
      position: position.chineseName || position.name,
      meaning: `${card.chineseName || card.name}在${position.chineseName || position.name}位置上为您带来指引。`,
      fullInterpretation: card.storyInterpretation || '这张牌蕴含着深刻的智慧',
      keywords,
      imageUrl: card.imageUrl,
      category: card.category,
      element: card.element || 'earth'
    };
  });
  
  return {
    cards: cardInfos,
    sections: [
      {
        icon: '🌟',
        title: '整体解读',
        content: `通过${spread.chineseName || spread.name}，塔罗牌为您的问题"${question}"提供了指引。请仔细感受每张牌的能量和含义。`
      },
      {
        icon: '💡',
        title: '智慧指引与行动建议',
        content: `基于塔罗牌的指引，建议您保持开放的心态，相信内心的智慧。结合您的问题"${question}"，请仔细感受每张牌的能量，让宇宙的智慧为您指明前进的方向。`
      }
    ],
  };
}

// 生成核心启示 - 专注人生哲理和深层洞察
function generateSummary(cards: any[]): { title: string; content: string } {
  const question = userQuestion.value;
  const cardNames = cards.map(card => card.chineseName || card.name);
  const majorCount = cards.filter(card => card.category === 'major').length;
  
  let insight = '';
  
  // 核心人生启示
  insight += `## 核心人生启示\n\n`;
  
  if (question.includes('选择') || question.includes('决定')) {
    insight += `🎯 **选择的智慧**\n`;
    insight += `真正的选择从来不是在外在的选项之间，而是在不同的自己之间。每一次选择，都是在选择成为什么样的人。${cardNames[0]}提醒您要倾听内心的声音，${cardNames[cardNames.length - 1]}指引您走向真正的自我。`;
  } else if (question.includes('困难') || question.includes('挑战') || question.includes('问题')) {
    insight += `🌱 **成长的智慧**\n`;
    insight += `困难不是生活对您的惩罚，而是宇宙给您的礼物。每一个挑战都携带着让您变得更强大、更智慧的能量。${cardNames[0]}显示了挑战的本质，${cardNames[cardNames.length - 1]}指向了成长的方向。`;
  } else if (question.includes('未来') || question.includes('前景')) {
    insight += `✨ **创造的智慧**\n`;
    insight += `未来不是一个固定的目的地，而是您每一个当下选择的累积。您不是在等待未来的到来，而是在每一个此刻创造着未来。${cardNames[0]}提醒您掌握当下，${cardNames[cardNames.length - 1]}指引您创造明天。`;
  } else {
    insight += `🌌 **生命的智慧**\n`;
    insight += `生命是一场神圣的旅程，每一个经历都是灵魂成长的养分。${cardNames[0]}提醒您保持初心，${cardNames[cardNames.length - 1]}指引您相信前方的光明。`;
  }
  
  // 深层精神内涵
  insight += `\n\n## 精神内涵与觉醒\n\n`;
  if (majorCount > cards.length / 2) {
    insight += `🎆 **灵魂觉醒的时刻**\n`;
    insight += `大阿尔卡纳的主导显示，您正在经历一次深刻的精神转化。这不仅仅是外在问题的解决，更是内在意识的升华。请以开放的心态迎接这个转变。`;
  } else {
    insight += `🌿 **实践中的智慧**\n`;
    insight += `小阿尔卡纳的主导提醒您，最深刻的智慧往往隐藏在最平凡的日常中。生活的真谛不在于追求轰轰烈烈，而在于在平凡中发现神圣。`;
  }
  
  insight += `\n\n💫 **最终启示**\n`;
  insight += `塔罗牌不是在预测命运，而是在揭示您内在的智慧。您已经拥有了所有需要的答案，只是有时需要一面镜子来看清它们。愿这次神圣的连接为您的人生旅程带来光明与力量。`;
  
  return {
    title: '核心启示与人生感悟',
    content: insight
  };
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成塔罗牌解读 - 统一调用LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('🎯 开始生成塔罗牌解读...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // 动态导入LLMService以避免循环依赖
    const { LLMService } = await import('../../../services/LLMService');
    
    // 设置状态监听
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // 调用统一的塔罗解读方法，该方法现在返回 EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // 使用新的组合函数来生成最终的显示结果
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // 清理状态监听
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('❌ 塔罗解读生成失败:', error);
    
    // 生成基础降级解读
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// 生成