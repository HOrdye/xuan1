<template>
  <div class="tarot-page min-h-screen bg-gradient-to-br from-indigo-900 via-purple-900 to-pink-900">
    <!-- èƒŒæ™¯æ˜Ÿç©ºæ•ˆæœ -->
    <div class="stars-background">
      <div class="stars" v-for="n in 50" :key="n" 
           :style="{ 
             left: Math.random() * 100 + '%', 
             top: Math.random() * 100 + '%',
             animationDelay: Math.random() * 3 + 's'
           }">â­</div>
    </div>

    <div class="container mx-auto px-4 py-8 relative z-10">
      <!-- æ ‡é¢˜ -->
      <div class="text-center mb-12">
        <h1 class="text-5xl font-bold text-white mb-4 mystical-glow">ğŸ”® å¡”ç½—å åœ ğŸ”®</h1>
        <p class="text-xl text-purple-200">æ¢ç´¢å‘½è¿çš„ç¥ç§˜é¢çº±ï¼Œè†å¬å¿ƒçµçš„æ™ºæ…§ä¹‹å£°</p>
      </div>

      <!-- é˜¶æ®µ1: ä»‹ç»å’Œé—®é¢˜è¾“å…¥ -->
      <div v-if="currentStage === 'intro'" class="max-w-4xl mx-auto">
        <div class="bg-black/30 backdrop-blur-md rounded-3xl p-8 border border-purple-500/30 shadow-2xl">
          <div class="text-center mb-8">
            <div class="text-6xl mb-6 animate-pulse">ğŸŒŸ</div>
            <h2 class="text-3xl font-bold text-white mb-4">æ¬¢è¿æ¥åˆ°ç¥ç§˜çš„å¡”ç½—ä¸–ç•Œ</h2>
            <p class="text-lg text-purple-200 mb-6 leading-relaxed">
              å¡”ç½—ç‰Œæ˜¯å¤è€çš„æ™ºæ…§ç»“æ™¶ï¼Œèƒ½å¤Ÿå¸®åŠ©æ‚¨æ¢ç´¢å†…å¿ƒæ·±å¤„çš„ç­”æ¡ˆã€‚<br>
              åœ¨å¼€å§‹å åœä¹‹å‰ï¼Œè¯·é™ä¸‹å¿ƒæ¥ï¼Œä¸“æ³¨äºæ‚¨æƒ³è¦äº†è§£çš„é—®é¢˜ã€‚
            </p>
          </div>

          <!-- é—®é¢˜è¾“å…¥ -->
          <div class="mb-8">
            <!-- å¼¹å¹•é«˜é¢‘é—®é¢˜åŒºåŸŸ -->
            <div class="mb-6">
              <div class="text-center mb-4">
                <h3 class="text-lg font-medium text-purple-200 mb-2">ğŸ’« é«˜é¢‘é—®é¢˜å¼¹å¹•</h3>
                <p class="text-sm text-purple-300">ç‚¹å‡»é£˜è¿‡çš„é—®é¢˜å¯å¿«é€Ÿå¡«å……ï¼Œæ‚¬åœå¯ç‚¹èµ</p>
              </div>
              <div 
                ref="barrageArea"
                class="barrage-area relative w-full h-32 overflow-hidden bg-white/5 rounded-xl border border-purple-400/30 shadow-inner"
              ></div>
            </div>
            
            <label class="block text-white text-lg font-medium mb-4">
              ğŸ’­ è¯·è¾“å…¥æ‚¨æƒ³è¦å’¨è¯¢çš„é—®é¢˜ï¼ˆå¯é€‰ï¼‰
            </label>
            <textarea 
              ref="questionInput"
              v-model="userQuestion"
              placeholder="ä¾‹å¦‚ï¼šæˆ‘çš„äº‹ä¸šå‘å±•å¦‚ä½•ï¼Ÿæˆ‘çš„æ„Ÿæƒ…è¿åŠ¿æ€æ ·ï¼Ÿæˆ‘åº”è¯¥å¦‚ä½•é¢å¯¹å½“å‰çš„å›°å¢ƒï¼Ÿ"
              class="w-full h-32 px-4 py-3 bg-white/10 border border-purple-400/50 rounded-lg text-white placeholder-purple-300 focus:outline-none focus:border-purple-400 focus:ring-2 focus:ring-purple-400/50 resize-none"
            ></textarea>
          </div>

          <div class="text-center">
            <button 
              @click="goToSpreadSelection" 
              class="bg-gradient-to-r from-purple-600 to-pink-600 text-white text-xl font-bold py-4 px-12 rounded-full shadow-lg hover:shadow-2xl transform hover:scale-105 transition-all duration-300 mystical-glow"
            >
              ğŸ´ é€‰æ‹©ç‰Œé˜µ
            </button>
          </div>
        </div>
      </div>

      <!-- é˜¶æ®µ1.5: ç‰Œé˜µé€‰æ‹© -->
      <div v-if="currentStage === 'spreadSelection'" class="max-w-6xl mx-auto">
        <div class="bg-black/30 backdrop-blur-md rounded-3xl p-8 border border-purple-500/30 shadow-2xl">
          <div class="text-center mb-12">
            <div class="text-5xl mb-6 animate-pulse">ğŸ”®</div>
            <h2 class="text-3xl font-bold text-white mb-4">é€‰æ‹©æ‚¨çš„ä¸“å±ç‰Œé˜µ</h2>
            <p class="text-lg text-purple-200 mb-8">æ¯ä¸ªç‰Œé˜µéƒ½æœ‰å…¶ç‹¬ç‰¹çš„æ™ºæ…§ä¸å¯ç¤ºï¼Œè¯·æ ¹æ®æ‚¨çš„é—®é¢˜é€‰æ‹©æœ€é€‚åˆçš„ç‰Œé˜µ</p>
          </div>

          <!-- ç‰Œé˜µé€‰æ‹©ç½‘æ ¼ -->
          <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-8">
            <div 
              v-for="(spread, index) in classicSpreads" 
              :key="spread.name"
              class="spread-card cursor-pointer transform transition-all duration-300 hover:scale-105 hover:-translate-y-2"
              :class="{ 'selected': selectedSpread?.name === spread.name }"
              @click="selectSpread(spread)"
            >
              <div class="bg-gradient-to-br from-purple-800/50 to-indigo-900/50 backdrop-blur-sm rounded-2xl p-6 border border-purple-400/30 shadow-xl h-full flex flex-col">
                <!-- ç‰Œé˜µå¤´éƒ¨ -->
                <div class="text-center mb-4">
                  <div class="text-4xl mb-3">{{ getSpreadIcon(spread.name) }}</div>
                  <h3 class="text-xl font-bold text-white mb-2">{{ spread.chineseName }}</h3>
                  <div class="text-sm text-purple-300 mb-4">{{ spread.positions.length }}å¼ ç‰Œ</div>
                </div>

                <!-- æ ¸å¿ƒä¼˜åŠ¿ - æœ€çªå‡ºçš„ä½ç½® -->
                <div class="bg-gradient-to-r from-yellow-400/20 to-orange-400/20 rounded-xl p-4 mb-4 border border-yellow-400/40">
                  <div class="text-center">
                    <div class="text-yellow-200 text-sm font-bold mb-2 flex items-center justify-center">
                      <span class="mr-2">â­</span>
                      <span>æœ€æ“…é•¿è§£å†³</span>
                    </div>
                    <div class="text-yellow-100 text-base font-semibold">{{ spread.bestFor[0] }}</div>
                  </div>
                </div>

                <!-- å…¶ä»–é€‚ç”¨åœºæ™¯ -->
                <div class="mb-4 flex-1">
                  <div class="text-purple-300 text-xs mb-2 text-center opacity-80">ä¹Ÿé€‚ç”¨äº</div>
                  <div class="flex flex-wrap gap-1 justify-center">
                    <span 
                      v-for="purpose in spread.bestFor.slice(1, 3)" 
                      :key="purpose"
                      class="px-3 py-1 text-xs bg-purple-600/30 text-purple-200 rounded-full border border-purple-500/30"
                    >
                      {{ purpose }}
                    </span>
                  </div>
                </div>

                <!-- ç®€åŒ–æè¿° - æ”¾åœ¨æœ€åº•éƒ¨ -->
                <div class="mt-auto pt-3 border-t border-purple-500/20">
                  <p class="text-xs text-purple-400 text-white opacity-80 leading-relaxed break-words">
                    {{ spread.description.length > 40 ? spread.description.slice(0, 40) + '...' : spread.description }}
                  </p>
                </div>
              </div>
            </div>
          </div>

          <!-- é€‰ä¸­ç‰Œé˜µè¯¦æƒ… -->
          <div v-if="selectedSpread" class="bg-purple-900/20 rounded-2xl p-6 mb-8 border border-purple-400/20">
            <h3 class="text-2xl font-bold text-white mb-4 text-center">{{ selectedSpread.chineseName }} è¯¦ç»†è¯´æ˜</h3>
            <p class="text-purple-200 mb-6 text-center leading-relaxed">{{ selectedSpread.description }}</p>
            
            <!-- ç‰Œä½è¯´æ˜ -->
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
              <div 
                v-for="(position, index) in selectedSpread.positions" 
                :key="index"
                class="bg-black/20 rounded-lg p-4 border border-purple-400/20"
              >
                <div class="text-center">
                  <div class="text-2xl mb-2">{{ index + 1 }}</div>
                  <h4 class="text-white font-medium mb-2">{{ position.chineseName }}</h4>
                  <p class="text-purple-300 text-sm">{{ position.meaning }}</p>
                </div>
              </div>
            </div>
          </div>

          <!-- æ“ä½œæŒ‰é’® -->
          <div class="flex justify-center space-x-6">
            <button 
              @click="goBackToIntro" 
              class="bg-gray-600 hover:bg-gray-700 text-white text-lg font-medium py-3 px-8 rounded-full transition-colors duration-300"
            >
              â† è¿”å›
            </button>
            <button 
              @click="startReading" 
              :disabled="!selectedSpread"
              class="bg-gradient-to-r from-purple-600 to-pink-600 text-white text-lg font-bold py-3 px-12 rounded-full shadow-lg hover:shadow-2xl transform hover:scale-105 transition-all duration-300 mystical-glow disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none"
            >
              ğŸ´ å¼€å§‹å åœ
            </button>
          </div>
        </div>
      </div>

      <!-- é˜¶æ®µ2: æ´—ç‰ŒåŠ¨ç”» -->
      <div v-if="currentStage === 'shuffling'" class="max-w-4xl mx-auto text-center relative overflow-hidden">
        <div class="bg-black/30 backdrop-blur-md rounded-3xl p-12 border border-purple-500/30 shadow-2xl relative">
          
          <!-- æ¼‚æµ®å¡ç‰ŒèƒŒæ™¯ -->
          <div class="absolute inset-0 pointer-events-none overflow-hidden rounded-3xl">
            <div v-for="n in 8" :key="n" 
                 class="floating-card absolute opacity-20"
                 :style="getFloatingCardStyle(n)">
              <div class="floating-card-back"></div>
            </div>
          </div>
          
          <!-- èƒ½é‡ç²’å­èƒŒæ™¯ -->
          <div class="absolute inset-0 pointer-events-none overflow-hidden rounded-3xl">
            <div v-for="n in 15" :key="n"
                 class="energy-particle absolute text-purple-300 opacity-60"
                 :style="getEnergyParticleStyle(n)">
              âœ¨
            </div>
          </div>
          
          <!-- ä¸»è¦å†…å®¹ -->
          <div class="relative z-10">
            <div class="text-6xl mb-6 animate-pulse">ğŸŒ€</div>
            <h2 class="text-3xl font-bold text-white mb-4">æ­£åœ¨æ´—ç‰Œ...</h2>
            <p class="text-lg text-purple-200 mb-8">è¯·ä¸“æ³¨äºæ‚¨çš„é—®é¢˜ï¼Œè®©å®‡å®™çš„èƒ½é‡æµå…¥ç‰Œä¸­</p>
            
            <!-- ç¥ç§˜è¿›åº¦æ¡ -->
            <div class="mystical-progress-container mb-8">
              <div class="mystical-progress-bar">
                <div class="progress-fill"></div>
                <div class="progress-glow"></div>
              </div>
              <div class="progress-text text-purple-300 text-sm mt-2">
                æ„Ÿå—å®‡å®™çš„èƒ½é‡æµåŠ¨...
              </div>
            </div>
            
            <!-- èƒ½é‡æ³¢çº¹æ•ˆæœ -->
            <div class="energy-ripples">
              <div class="ripple"></div>
              <div class="ripple"></div>
              <div class="ripple"></div>
            </div>
          </div>
        </div>
      </div>

      <!-- é˜¶æ®µ3: æŠ½ç‰Œ -->
      <div v-if="currentStage === 'drawing'" class="max-w-6xl mx-auto">
        <div class="bg-black/30 backdrop-blur-md rounded-3xl p-8 border border-purple-500/30 shadow-2xl">
          <div class="text-center mb-8">
            <h2 class="text-3xl font-bold text-white mb-4">âœ¨ é€‰æ‹©æ‚¨çš„å‘½è¿ä¹‹ç‰Œ</h2>
            <p class="text-lg text-purple-200 mb-6">è¯·ç”¨å¿ƒæ„Ÿå—ï¼Œç‚¹å‡»ä¸‹æ–¹çš„ç‰Œæ¥æŠ½å–æ‚¨çš„{{ selectedSpread?.positions.length || 3 }}å¼ ç‰Œ</p>
            <p class="text-purple-300">å·²æŠ½å–: {{ drawnCards.length }} / {{ selectedSpread?.positions.length || 3 }}</p>
          </div>

          <!-- ç‰Œå †å±•ç¤º -->
          <div class="deck-spread flex justify-center items-center mb-8 flex-wrap gap-4">
            <div 
              v-for="n in Math.max(7, selectedSpread?.positions.length || 3)" 
              :key="n"
              class="deck-card cursor-pointer transform transition-all duration-500 hover:scale-110 hover:-translate-y-4"
              @click="drawCard(n)"
            >
              <div class="w-24 h-36 rounded-lg shadow-lg border border-purple-400/50 overflow-hidden">
                <div class="card-back w-full h-full transform hover:scale-105 transition-transform duration-300"></div>
              </div>
            </div>
          </div>

          <!-- å·²æŠ½å–çš„ç‰Œä½ -->
          <div class="drawn-positions mt-12">
            <div class="grid gap-4 grid-cols-1 md:grid-cols-3">
              <div 
                v-for="(position, index) in positions" 
                :key="index"
                class="position-slot"
              >
                <div class="text-center mb-4">
                  <h3 class="text-lg font-bold text-white mb-2">{{ position }}</h3>
                </div>
                <div 
                  class="card-slot w-28 h-40 mx-auto rounded-lg border-2 border-dashed border-purple-400/50 flex items-center justify-center"
                  :class="{ 'filled': drawnCards[index] }"
                >
                  <div v-if="!drawnCards[index]" class="text-purple-400 text-5xl opacity-50">?</div>
                  <div 
                    v-else 
                    class="drawn-card-preview w-full h-full bg-gradient-to-br from-purple-800 to-indigo-900 rounded-lg flex flex-col items-center justify-center transform animate-flip-in relative overflow-hidden border border-purple-400/50"
                  >
                    <div class="relative z-10 text-center">
                      <div class="text-white text-2xl mb-1 animate-pulse">ğŸŒŸ</div>
                      <div class="text-white/60 text-xs font-medium">å·²é€‰æ‹©</div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <div v-if="drawnCards.length === (selectedSpread?.positions.length || 3)" class="text-center mt-8">
            <button 
              @click="revealCards" 
              class="bg-gradient-to-r from-pink-600 to-red-600 text-white text-xl font-bold py-4 px-12 rounded-full shadow-lg hover:shadow-2xl transform hover:scale-105 transition-all duration-300 mystical-glow"
            >
              âœ¨ æ­ç¤ºå‘½è¿
            </button>
          </div>
        </div>
      </div>

      <!-- é˜¶æ®µ4: ç¿»ç‰Œå’Œè§£è¯» -->
      <div v-if="currentStage === 'reveal'" class="max-w-6xl mx-auto">
        <div class="bg-black/30 backdrop-blur-md rounded-3xl p-8 border border-purple-500/30 shadow-2xl">
          <h1 class="text-white text-5xl text-center">ğŸ´ å‘½è¿è§£è¯»</h1>
          <p class="text-white text-center mt-4">æ‚¨çš„å¡”ç½—ç‰Œå·²ç»æ­ç¤ºï¼Œè®©æˆ‘ä»¬æ¥è§£è¯»å‘½è¿çš„å¯ç¤º...</p>
          
          <!-- LLMåŠ è½½çŠ¶æ€æ˜¾ç¤º -->
          <div v-if="llmLoading" class="mt-8 mb-8">
            <div class="bg-gradient-to-r from-purple-600/20 to-indigo-600/20 rounded-2xl p-6 border border-purple-400/30">
              <div class="flex items-center justify-center mb-4">
                <div class="w-8 h-8 border-4 border-purple-400 border-t-transparent rounded-full animate-spin mr-3"></div>
                <h3 class="text-xl font-bold text-white">æ­£åœ¨ç”Ÿæˆä¸“ä¸šè§£è¯»...</h3>
              </div>
              <div class="text-center">
                <p class="text-purple-200 mb-2">{{ llmLoadingMessage }}</p>
                <div class="w-full bg-purple-900/30 rounded-full h-2">
                  <div class="bg-gradient-to-r from-purple-500 to-pink-500 h-2 rounded-full transition-all duration-500" 
                       :class="{
                         'w-1/4': llmLoadingStage === 'preparing',
                         'w-2/4': llmLoadingStage === 'calling', 
                         'w-3/4': llmLoadingStage === 'processing',
                         'w-full': llmLoadingStage === 'completed'
                       }"></div>
                </div>
                <p class="text-purple-300 text-sm mt-2">è¯·è€å¿ƒç­‰å¾…ï¼ŒAIæ­£åœ¨ä¸ºæ‚¨é‡èº«å®šåˆ¶æ·±åº¦è§£è¯»</p>
              </div>
            </div>
          </div>
          
          <!-- é—®é¢˜å›é¡¾ -->
          <div class="mt-6 text-center">
            <div class="inline-block bg-gradient-to-r from-purple-600/30 to-pink-600/30 backdrop-blur-sm rounded-2xl px-6 py-3 border border-purple-400/30">
              <span class="text-purple-200 text-sm">æ‚¨çš„é—®é¢˜ï¼š</span>
              <span class="text-white font-medium ml-2">{{ userQuestion }}</span>
            </div>
          </div>
          
          <!-- æ˜¾ç¤ºæŠ½åˆ°çš„ç‰Œ -->
          <div class="mt-8" v-if="interpretationResult">
            <h2 class="text-2xl font-bold text-white text-center mb-6">æ‚¨æŠ½åˆ°çš„ç‰Œ</h2>
            
            <!-- æ ¹æ®ç‰Œé˜µç±»å‹è°ƒæ•´å¸ƒå±€ -->
            <div v-if="selectedSpread?.name === 'Love Pyramid Spread'" class="relative max-w-4xl mx-auto">
              <!-- æ‹äººé‡‘å­—å¡”ç‰¹æ®Šå¸ƒå±€ -->
              <div class="flex flex-col items-center space-y-6">
                <!-- ç¬¬ä¸€å±‚ï¼šä½ çš„å†…å¿ƒ -->
                <div class="flex justify-center">
                  <div class="card-container" v-if="interpretationResult.cards[0]">
                    <!-- ç‰Œä½æ ‡é¢˜ - ç§»åˆ°å¡ç‰Œä¸Šæ–¹ -->
                    <div class="position-title-header mb-3 text-center">
                      <div class="inline-block bg-gradient-to-r from-purple-600/80 to-indigo-600/80 backdrop-blur-sm rounded-full px-4 py-2 border border-purple-400/40">
                        <span class="text-white font-bold text-sm">{{ interpretationResult.cards[0].position }}</span>
                      </div>
                    </div>
                    
                    <div class="tarot-card-container relative" :class="[
                      interpretationResult.cards[0].category === 'major' ? 'major-arcana' : 'minor-arcana',
                      `element-${interpretationResult.cards[0].element}`
                    ]">
                      <!-- å¡ç‰Œå›¾ç‰‡å®¹å™¨ - ç§»é™¤ä½ç½®è¦†ç›–å±‚ -->
                      <div class="card-image-container mb-4 relative">
                        <img 
                          :src="interpretationResult.cards[0].imageUrl" 
                          :alt="interpretationResult.cards[0].name" 
                          class="tarot-card-image w-full h-48 object-cover rounded-lg"
                          @error="handleImageError"
                        />
                        <!-- å…ƒç´ æ ‡è®° -->
                        <div class="element-badge" :class="`element-${interpretationResult.cards[0].element}`">
                          {{ getElementSymbol(interpretationResult.cards[0].element) }}
                        </div>
                      </div>
                      
                      <!-- å¡ç‰ŒåŸºæœ¬ä¿¡æ¯ -->
                      <div class="card-info text-center">
                        <div class="text-purple-200 mb-2 font-semibold">{{ interpretationResult.cards[0].name }}</div>
                        <div class="text-sm text-purple-300 mb-3">{{ interpretationResult.cards[0].englishName }}</div>
                        <div class="text-xs text-purple-200 mb-2">
                          å…³é”®è¯: {{ getDisplayKeywords(interpretationResult.cards[0].keywords) }}
                        </div>
                        <!-- å¡ç‰Œè§£è¯»æ‚¬åœæ˜¾ç¤º -->
                        <div class="text-xs text-purple-300 cursor-help hover:text-purple-100 transition-colors duration-200" 
                             @mouseenter="showCardTooltip($event, interpretationResult.cards[0])"
                             @mouseleave="hideCardTooltip">
                          ğŸ“– å¡ç‰Œè§£è¯»
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                
                <!-- ç¬¬äºŒå±‚ï¼šå¯¹æ–¹å†…å¿ƒ + å…³ç³»åŸºç¡€ -->
                <div class="flex justify-center space-x-8">
                  <div class="card-container" v-if="interpretationResult.cards[1]">
                    <!-- ç‰Œä½æ ‡é¢˜ - ç§»åˆ°å¡ç‰Œä¸Šæ–¹ -->
                    <div class="position-title-header mb-3 text-center">
                      <div class="inline-block bg-gradient-to-r from-purple-600/80 to-indigo-600/80 backdrop-blur-sm rounded-full px-4 py-2 border border-purple-400/40">
                        <span class="text-white font-bold text-sm">{{ interpretationResult.cards[1].position }}</span>
                      </div>
                    </div>
                    
                    <div class="tarot-card-container relative" :class="[
                      interpretationResult.cards[1].category === 'major' ? 'major-arcana' : 'minor-arcana',
                      `element-${interpretationResult.cards[1].element}`
                    ]">
                      <div class="card-image-container mb-4 relative">
                        <img 
                          :src="interpretationResult.cards[1].imageUrl" 
                          :alt="interpretationResult.cards[1].name" 
                          class="tarot-card-image w-full h-48 object-cover rounded-lg"
                          @error="handleImageError"
                        />
                        <div class="element-badge" :class="`element-${interpretationResult.cards[1].element}`">
                          {{ getElementSymbol(interpretationResult.cards[1].element) }}
                        </div>
                      </div>
                      <div class="card-info text-center">
                        <div class="text-purple-200 mb-2 font-semibold">{{ interpretationResult.cards[1].name }}</div>
                        <div class="text-sm text-purple-300 mb-3">{{ interpretationResult.cards[1].englishName }}</div>
                        <div class="text-xs text-purple-200 mb-2">
                          å…³é”®è¯: {{ getDisplayKeywords(interpretationResult.cards[1].keywords) }}
                        </div>
                        <!-- å¡ç‰Œè§£è¯»æ‚¬åœæ˜¾ç¤º -->
                        <div class="text-xs text-purple-300 cursor-help hover:text-purple-100 transition-colors duration-200" 
                             @mouseenter="showCardTooltip($event, interpretationResult.cards[1])"
                             @mouseleave="hideCardTooltip">
                          ğŸ“– å¡ç‰Œè§£è¯»
                        </div>
                      </div>
                    </div>
                  </div>
                  
                  <div class="card-container" v-if="interpretationResult.cards[2]">
                    <!-- ç‰Œä½æ ‡é¢˜ - ç§»åˆ°å¡ç‰Œä¸Šæ–¹ -->
                    <div class="position-title-header mb-3 text-center">
                      <div class="inline-block bg-gradient-to-r from-purple-600/80 to-indigo-600/80 backdrop-blur-sm rounded-full px-4 py-2 border border-purple-400/40">
                        <span class="text-white font-bold text-sm">{{ interpretationResult.cards[2].position }}</span>
                      </div>
                    </div>
                    
                    <div class="tarot-card-container relative" :class="[
                      interpretationResult.cards[2].category === 'major' ? 'major-arcana' : 'minor-arcana',
                      `element-${interpretationResult.cards[2].element}`
                    ]">
                      <div class="card-image-container mb-4 relative">
                        <img 
                          :src="interpretationResult.cards[2].imageUrl" 
                          :alt="interpretationResult.cards[2].name" 
                          class="tarot-card-image w-full h-48 object-cover rounded-lg"
                          @error="handleImageError"
                        />
                        <div class="element-badge" :class="`element-${interpretationResult.cards[2].element}`">
                          {{ getElementSymbol(interpretationResult.cards[2].element) }}
                        </div>
                      </div>
                      <div class="card-info text-center">
                        <div class="text-purple-200 mb-2 font-semibold">{{ interpretationResult.cards[2].name }}</div>
                        <div class="text-sm text-purple-300 mb-3">{{ interpretationResult.cards[2].englishName }}</div>
                        <div class="text-xs text-purple-200 mb-2">
                          å…³é”®è¯: {{ getDisplayKeywords(interpretationResult.cards[2].keywords) }}
                        </div>
                        <!-- å¡ç‰Œè§£è¯»æ‚¬åœæ˜¾ç¤º -->
                        <div class="text-xs text-purple-300 cursor-help hover:text-purple-100 transition-colors duration-200" 
                             @mouseenter="showCardTooltip($event, interpretationResult.cards[2])"
                             @mouseleave="hideCardTooltip">
                          ğŸ“– å¡ç‰Œè§£è¯»
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                
                <!-- ç¬¬ä¸‰å±‚ï¼šå…³ç³»æœªæ¥ -->
                <div class="flex justify-center">
                  <div class="card-container" v-if="interpretationResult.cards[3]">
                    <!-- ç‰Œä½æ ‡é¢˜ - ç§»åˆ°å¡ç‰Œä¸Šæ–¹ -->
                    <div class="position-title-header mb-3 text-center">
                      <div class="inline-block bg-gradient-to-r from-purple-600/80 to-indigo-600/80 backdrop-blur-sm rounded-full px-4 py-2 border border-purple-400/40">
                        <span class="text-white font-bold text-sm">{{ interpretationResult.cards[3].position }}</span>
                      </div>
                    </div>
                    
                    <div class="tarot-card-container relative" :class="[
                      interpretationResult.cards[3].category === 'major' ? 'major-arcana' : 'minor-arcana',
                      `element-${interpretationResult.cards[3].element}`
                    ]">
                      <div class="card-image-container mb-4 relative">
                        <img 
                          :src="interpretationResult.cards[3].imageUrl" 
                          :alt="interpretationResult.cards[3].name" 
                          class="tarot-card-image w-full h-48 object-cover rounded-lg"
                          @error="handleImageError"
                        />
                        <div class="element-badge" :class="`element-${interpretationResult.cards[3].element}`">
                          {{ getElementSymbol(interpretationResult.cards[3].element) }}
                        </div>
                      </div>
                      <div class="card-info text-center">
                        <div class="text-purple-200 mb-2 font-semibold">{{ interpretationResult.cards[3].name }}</div>
                        <div class="text-sm text-purple-300 mb-3">{{ interpretationResult.cards[3].englishName }}</div>
                        <div class="text-xs text-purple-200 mb-2">
                          å…³é”®è¯: {{ getDisplayKeywords(interpretationResult.cards[3].keywords) }}
                        </div>
                        <!-- å¡ç‰Œè§£è¯»æ‚¬åœæ˜¾ç¤º -->
                        <div class="text-xs text-purple-300 cursor-help hover:text-purple-100 transition-colors duration-200" 
                             @mouseenter="showCardTooltip($event, interpretationResult.cards[3])"
                             @mouseleave="hideCardTooltip">
                          ğŸ“– å¡ç‰Œè§£è¯»
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- å…¶ä»–ç‰Œé˜µçš„ä¼˜åŒ–å¸ƒå±€ -->
            <div v-else class="grid gap-6" :class="getCardLayoutClass(interpretationResult.cards.length)">
              <div 
                v-for="(card, index) in interpretationResult.cards" 
                :key="index"
                class="text-center"
              >
                <!-- ç‰Œä½æ ‡é¢˜ - ç§»åˆ°å¡ç‰Œä¸Šæ–¹ -->
                <div class="position-title-header mb-3 text-center">
                  <div class="inline-block bg-gradient-to-r from-purple-600/80 to-indigo-600/80 backdrop-blur-sm rounded-full px-4 py-2 border border-purple-400/40">
                    <span class="text-white font-bold text-sm">{{ card.position }}</span>
                  </div>
                </div>
                
                <div class="tarot-card-container relative" :class="[
                  card.category === 'major' ? 'major-arcana' : 'minor-arcana',
                  `element-${card.element}`
                ]">
                  <!-- å¡ç‰Œå›¾ç‰‡å®¹å™¨ - ç§»é™¤ä½ç½®è¦†ç›–å±‚ -->
                  <div class="card-image-container mb-4 relative">
                    <img 
                      :src="card.imageUrl" 
                      :alt="card.name" 
                      :class="getCardImageClass(interpretationResult.cards.length)"
                      @error="handleImageError"
                    />
                    <!-- å…ƒç´ æ ‡è®° -->
                    <div class="element-badge" :class="`element-${card.element}`">
                      {{ getElementSymbol(card.element) }}
                    </div>
                  </div>
                  
                  <!-- å¡ç‰ŒåŸºæœ¬ä¿¡æ¯ -->
                  <div class="card-info text-center">
                    <div class="text-purple-200 mb-2 font-semibold">{{ card.name }}</div>
                    <div class="text-sm text-purple-300 mb-3">{{ card.englishName }}</div>
                    <div class="text-xs text-purple-200 mb-2">
                      å…³é”®è¯: {{ getDisplayKeywords(card.keywords) }}
                    </div>
                    <!-- å¡ç‰Œè§£è¯»æ‚¬åœæ˜¾ç¤º -->
                    <div class="text-xs text-purple-300 cursor-help hover:text-purple-100 transition-colors duration-200" 
                         @mouseenter="showCardTooltip($event, card)"
                         @mouseleave="hideCardTooltip">
                      ğŸ“– å¡ç‰Œè§£è¯»
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <!-- å¡ç‰Œè¯¦ç»†ä¿¡æ¯æ‚¬åœæç¤ºæ¡† -->
          <div 
            v-if="tooltipVisible" 
            ref="cardTooltip"
            class="card-tooltip"
            :style="tooltipStyle"
          >
            <div class="tooltip-content">
              <div class="flex items-center gap-2 mb-2">
                <h4 class="font-bold text-white text-lg">{{ tooltipCard?.name }}</h4>
                <span v-if="tooltipCard?.position" class="text-xs bg-purple-600/80 px-2 py-1 rounded-full text-white">
                  {{ tooltipCard.position }}
                </span>
              </div>
              
              <div class="text-sm text-purple-200 mb-3 leading-relaxed">
                <strong class="text-purple-100">å…³é”®è¯:</strong> {{ tooltipCard?.keywords || 'ç¥ç§˜, æ™ºæ…§, æŒ‡å¼•' }}
              </div>
              
              <!-- æ˜¾ç¤ºå®Œæ•´çš„å¡ç‰Œè§£è¯» -->
              <div class="text-sm text-gray-200 leading-relaxed space-y-2">
                <div v-for="(paragraph, index) in formatInterpretationContent(tooltipCard?.fullInterpretation || tooltipCard?.meaning || '')" 
                     :key="index" 
                     class="text-sm leading-relaxed">
                  {{ paragraph }}
                </div>
              </div>
            </div>
          </div>
          
          <!-- æ•´ä½“è§£è¯» -->
          <div class="mt-12" v-if="interpretationResult">
            <div class="bg-gradient-to-br from-indigo-900/40 to-purple-900/40 backdrop-blur-sm rounded-2xl p-6 border border-indigo-400/30 shadow-xl space-y-6">
              
              <!-- æ–°å¢ï¼šåŠ¨æ€è§£è¯»æ¿å—æ¸²æŸ“ -->
              <div 
                v-for="(section, index) in interpretationResult.sections" 
                :key="index"
                class="bg-black/20 rounded-xl p-5 border border-purple-400/20"
              >
                <h3 class="text-2xl font-bold text-white mb-4 text-center flex items-center justify-center gap-2">
                  {{ section.icon }} {{ section.title }}
                </h3>
                <div class="text-lg text-gray-200 leading-relaxed prose prose-invert max-w-none">
                  <div v-html="formatMarkdownContent(section.content)" class="space-y-3"></div>
                </div>
              </div>

            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, onBeforeMount, nextTick, onUnmounted } from 'vue';
import { storyTarotDeck, type StoryTarotCard } from '../utils/storyTarotData';
import { classicSpreads, type TarotSpread } from '../utils/tarotInterpretation';
import { useAIReading } from '../../../composables/useAIReading';
import { useLLMConfigStore } from '../../../store/llmConfig';
import kabeiImage from '../../../assets/kabei.jpg';
import type { EnhancedTarotInterpretation, InterpretationSection } from '../../../services/LLMService';
import { marked } from 'marked';

// è§£è¯»ç»“æœç±»å‹å®šä¹‰ - é‡æ„ä¸ºåŒ…å«åŠ¨æ€æ¿å—çš„ç»“æ„
interface ProcessedInterpretation {
  cards: Array<{
    name: string;
    englishName: string;
    position: string;
    meaning: string;
    keywords: string;
    imageUrl: string;
    category: string;
    element: string;
    fullInterpretation?: string;
  }>;
  sections: InterpretationSection[];
}

// é˜¶æ®µç®¡ç†
type Stage = 'intro' | 'spreadSelection' | 'shuffling' | 'drawing' | 'reveal';
const currentStage = ref<Stage>('intro');

// ç‰Œé˜µç›¸å…³
const selectedSpread = ref<TarotSpread | null>(null);

// åŸºç¡€æ•°æ®
const userQuestion = ref('');
const positions = ref<string[]>(['è¿‡å»', 'ç°åœ¨', 'æœªæ¥']);
const drawnCards = ref<StoryTarotCard[]>([]);
const revealedCards = ref<boolean[]>([false, false, false]);

// å¼¹å¹•ç›¸å…³
const barrageArea = ref<HTMLElement | null>(null);
const questionInput = ref<HTMLTextAreaElement | null>(null);

// å®šä¹‰å¼¹å¹•é¡¹ç±»å‹
interface BarrageItem {
  el: HTMLDivElement;
  text: string;
  likes: number;
  row: number;
  x: number;
  y: number;
  width: number;
  speed: number;
  paused: boolean;
}

const barrageItems = ref<BarrageItem[]>([]);
let animationFrame: number | null = null;

// é«˜é¢‘é—®é¢˜æ•°æ®
const suggestions = ref([
  { text: 'æˆ‘çš„äº‹ä¸šå‘å±•å¦‚ä½•ï¼Ÿ', likes: 2 },
  { text: 'æˆ‘çš„æ„Ÿæƒ…è¿åŠ¿æ€æ ·ï¼Ÿ', likes: 5 },
  { text: 'è¿‘æœŸè´¢è¿å¦‚ä½•ï¼Ÿ', likes: 1 },
  { text: 'æˆ‘è¯¥å¦‚ä½•é¢å¯¹å½“å‰çš„å›°å¢ƒï¼Ÿ', likes: 3 },
  { text: 'æœªæ¥ä¸‰ä¸ªæœˆä¼šæœ‰ä»€ä¹ˆæ–°æœºä¼šï¼Ÿ', likes: 0 },
  { text: 'æˆ‘ä¸æŸæŸçš„å…³ç³»ä¼šå¦‚ä½•å‘å±•ï¼Ÿ', likes: 1 },
  { text: 'éœ€è¦æ³¨æ„å“ªäº›å¥åº·é—®é¢˜ï¼Ÿ', likes: 0 },
  { text: 'ç›®å‰çš„é€‰æ‹©æ˜¯å¦æ­£ç¡®ï¼Ÿ', likes: 0 },
  { text: 'æˆ‘çš„å­¦ä¸šè¿åŠ¿å¦‚ä½•ï¼Ÿ', likes: 2 },
  { text: 'ä»€ä¹ˆæ—¶å€™ä¼šé‡åˆ°çœŸçˆ±ï¼Ÿ', likes: 4 },
  { text: 'æˆ‘é€‚åˆæ¢å·¥ä½œå—ï¼Ÿ', likes: 1 },
  { text: 'å®¶åº­å…³ç³»å¦‚ä½•æ”¹å–„ï¼Ÿ', likes: 0 },
  { text: 'æŠ•èµ„ç†è´¢è¦æ³¨æ„ä»€ä¹ˆï¼Ÿ', likes: 1 },
  { text: 'æˆ‘çš„äººé™…å…³ç³»æ€æ ·ï¼Ÿ', likes: 0 },
  { text: 'å¦‚ä½•æå‡ä¸ªäººè¿åŠ¿ï¼Ÿ', likes: 2 },
  { text: 'ä»Šå¹´ä¼šæœ‰ä»€ä¹ˆé‡å¤§å˜åŒ–ï¼Ÿ', likes: 1 }
]);

// å¼¹å¹•é…ç½® - ä¼˜åŒ–é€Ÿåº¦åŸºå‡†å’Œæ™ºèƒ½åˆ†é…
const BARRAGE_ROWS = 4; // å¼¹å¹•è¡Œæ•°
const BARRAGE_HEIGHT = 120; // å¼¹å¹•åŒºåŸŸæ€»é«˜åº¦
const ROW_HEIGHT = 30; // æ¯è¡Œé«˜åº¦
const SPEED_MIN = 40; // æœ€å°é€Ÿåº¦ (px/s)
const SPEED_MAX = 65; // æœ€å¤§é€Ÿåº¦ (px/s)

// æ™ºèƒ½è¡Œåˆ†é…çŠ¶æ€ç®¡ç†
interface BarrageRowState {
  isOccupied: boolean;
  lastItemEndTime: number;
  lastItemWidth: number;
  currentItems: number;
}

const rowStates = ref<BarrageRowState[]>(
  Array.from({ length: BARRAGE_ROWS }, () => ({
    isOccupied: false,
    lastItemEndTime: 0,
    lastItemWidth: 0,
    currentItems: 0
  }))
);

// éŸ³æ•ˆæ§åˆ¶
const soundEnabled = ref(true);

// LLMåŠ è½½çŠ¶æ€
const llmLoading = ref(false);
const llmLoadingMessage = ref('');
const llmLoadingStage = ref<'preparing' | 'calling' | 'processing' | 'completed' | 'error'>('preparing');

// è§£è¯»ç»“æœ - ä½¿ç”¨æ–°çš„ã€çµæ´»çš„æ¥å£
const interpretationResult = ref<ProcessedInterpretation | null>(null);

// ä½¿ç”¨ useAIReading Composable
const { 
  interpretationResult: rawInterpretation, 
  isLoading: llmLoading, 
  loadingMessage: llmLoadingMessage, 
  loadingStage: llmLoadingStage,
  getTarotReading 
} = useAIReading();

// æ–¹æ³•å®šä¹‰
function goToSpreadSelection() {
  currentStage.value = 'spreadSelection';
}

function goBackToIntro() {
  currentStage.value = 'intro';
}

function selectSpread(spread: TarotSpread) {
  selectedSpread.value = spread;
  positions.value = spread.positions.map(p => p.chineseName);
  revealedCards.value = new Array(spread.positions.length).fill(false);
}

function getSpreadIcon(spreadName: string): string {
  const icons: Record<string, string> = {
    'Three Card Spread': 'ğŸ”®',
    'Celtic Cross': 'âœ¨',
    'Love Pyramid Spread': 'ğŸ’•',
    'Career Path Spread': 'ğŸŒŸ',
    'Decision Making Spread': 'âš–ï¸',
    'Past Present Future': 'ğŸ•°ï¸',
    'Relationship Spread': 'ğŸ’–'
  };
  return icons[spreadName] || 'ğŸ´';
}

// å¼¹å¹•ç›¸å…³æ–¹æ³•
function initBarrage() {
  if (!barrageArea.value) return;
  
  // ç«‹å³ç”Ÿæˆç¬¬ä¸€æ‰¹å¼¹å¹•ï¼Œæå‡ç”¨æˆ·è¿›å…¥ä½“éªŒ
  setTimeout(() => addBarrageItem(), 100);
  setTimeout(() => addBarrageItem(), 300);
  setTimeout(() => addBarrageItem(), 500);
  
  // å¯åŠ¨å¼¹å¹•åŠ¨ç”»å¾ªç¯
  startBarrageAnimation();
  
  // æ™ºèƒ½ç”Ÿæˆæ–°å¼¹å¹• - åŠ¨æ€é—´éš”é¿å…æ‹¥æŒ¤
  const generateBarrage = () => {
    if (barrageItems.value.length < 10) { // é™åˆ¶åŒæ—¶æ˜¾ç¤ºçš„å¼¹å¹•æ•°é‡
      addBarrageItem();
    }
    
    // åŠ¨æ€é—´éš”ï¼šæ ¹æ®å½“å‰å¼¹å¹•æ•°é‡è°ƒæ•´ç”Ÿæˆé¢‘ç‡
    const currentCount = barrageItems.value.length;
    const baseInterval = 1200;
    const dynamicInterval = baseInterval + (currentCount * 200); // å¼¹å¹•è¶Šå¤šï¼Œé—´éš”è¶Šé•¿
    
    setTimeout(generateBarrage, Math.min(dynamicInterval, 3000));
  };
  
  // å¯åŠ¨æ™ºèƒ½ç”Ÿæˆå¾ªç¯
  setTimeout(generateBarrage, 800);
}

function startBarrageAnimation() {
  let lastTime = performance.now();
  
  function animate(currentTime: number) {
    const deltaTime = currentTime - lastTime;
    lastTime = currentTime;
    
    // ä½¿ç”¨å€’åºéå†é¿å…æ•°ç»„ç´¢å¼•æ··ä¹±
    for (let i = barrageItems.value.length - 1; i >= 0; i--) {
      const item = barrageItems.value[i];
      
      if (!item.paused) {
        // åŸºäºæ—¶é—´çš„ç§»åŠ¨è®¡ç®—
        item.x -= (item.speed * deltaTime) / 1000;
        
        // å¦‚æœå¼¹å¹•å®Œå…¨ç§»å‡ºå±å¹•ï¼Œç§»é™¤å®ƒ
        if (item.x + item.width < 0) {
          item.el.remove();
          barrageItems.value.splice(i, 1);
          
          // æ›´æ–°è¡ŒçŠ¶æ€ï¼šå‡å°‘å½“å‰è¡Œçš„å¼¹å¹•è®¡æ•°
          if (rowStates.value[item.row]) {
            rowStates.value[item.row].currentItems = Math.max(0, rowStates.value[item.row].currentItems - 1);
            
            // å¦‚æœè¡Œä¸­æ²¡æœ‰å¼¹å¹•äº†ï¼Œé‡ç½®å ç”¨çŠ¶æ€
            if (rowStates.value[item.row].currentItems === 0) {
              rowStates.value[item.row].isOccupied = false;
            }
          }
          continue;
        }
        
        // æ›´æ–°ä½ç½® - ä½¿ç”¨transformç¡®ä¿å¹³æ»‘ç§»åŠ¨
        item.el.style.transform = `translateX(${item.x}px)`;
      }
    }
    
    animationFrame = requestAnimationFrame(animate);
  }
  
  animate(lastTime);
}

function addBarrageItem() {
  if (!barrageArea.value) return;
  
  const suggestion = suggestions.value[Math.floor(Math.random() * suggestions.value.length)];
  
  // æ™ºèƒ½è¡Œåˆ†é… - é€‰æ‹©æœ€ç©ºé—²çš„è¡Œï¼Œé¿å…é‡å 
  const getOptimalRow = (): number => {
    const currentTime = performance.now();
    const containerWidth = barrageArea.value!.offsetWidth;
    
    // é¢„ä¼°æ–‡æœ¬å®½åº¦ï¼ˆåŸºäºå­—ç¬¦æ•°é‡çš„ç²—ç•¥ä¼°ç®—ï¼‰
    const estimatedWidth = Math.min(suggestion.text.length * 16 + 80, 320);
    
    // æ‰¾åˆ°æœ€é€‚åˆçš„è¡Œ
    let bestRow = 0;
    let minOccupancy = Infinity;
    
    for (let i = 0; i < BARRAGE_ROWS; i++) {
      const rowState = rowStates.value[i];
      
      // è®¡ç®—æ­¤è¡Œçš„å ç”¨åº¦è¯„åˆ†ï¼ˆè¶Šä½è¶Šå¥½ï¼‰
      let occupancyScore = rowState.currentItems * 100;
      
      // å¦‚æœè¡Œä¸­æœ‰æœªå®Œå…¨ç§»å‡ºçš„å¼¹å¹•ï¼Œå¢åŠ æƒ©ç½š
      if (rowState.isOccupied && currentTime < rowState.lastItemEndTime) {
        const timeRemaining = rowState.lastItemEndTime - currentTime;
        occupancyScore += timeRemaining / 10; // æ—¶é—´æƒ©ç½š
      }
      
      // æ£€æŸ¥ç©ºé—´æ˜¯å¦è¶³å¤Ÿ
      const spaceNeeded = estimatedWidth + 50; // é¢å¤–é—´è·
      const timeForSpace = (spaceNeeded / SPEED_MIN) * 1000; // éœ€è¦çš„æ—¶é—´
      
      if (currentTime > rowState.lastItemEndTime + timeForSpace) {
        occupancyScore -= 50; // ç©ºé—´å……è¶³ï¼Œå¥–åŠ±åˆ†æ•°
      }
      
      if (occupancyScore < minOccupancy) {
        minOccupancy = occupancyScore;
        bestRow = i;
      }
    }
    
    return bestRow;
  };
  
  const row = getOptimalRow();
  
  const el = document.createElement('div');
  el.className = 'barrage-item absolute whitespace-nowrap cursor-pointer transition-all duration-200 hover:scale-105 select-none flex items-center gap-3';
  
  // é¢„è®¾æ ·å¼ï¼Œé¿å…é—ªç°
  const containerWidth = barrageArea.value.offsetWidth;
  const initialX = containerWidth + 20;
  
  el.style.cssText = `
    top: ${row * ROW_HEIGHT}px;
    font-size: 16px;
    line-height: ${ROW_HEIGHT}px;
    height: ${ROW_HEIGHT - 4}px;
    color: rgba(196, 181, 253, 0.95);
    text-shadow: 0 0 6px rgba(147, 51, 234, 0.6);
    z-index: 10;
    padding: 6px 12px;
    background: rgba(0, 0, 0, 0.25);
    border-radius: 20px;
    border: 1px solid rgba(147, 51, 234, 0.4);
    backdrop-filter: blur(4px);
    will-change: transform;
    transform: translateX(${initialX}px);
  `;
  
  // åˆ›å»ºé—®é¢˜æ–‡æœ¬
  const textSpan = document.createElement('span');
  textSpan.textContent = suggestion.text;
  textSpan.className = 'barrage-text flex-1';
  
  // åˆ›å»ºTwitteré£æ ¼çš„ç‚¹èµæŒ‰é’®
  const likeButton = document.createElement('button');
  likeButton.className = 'like-button flex items-center gap-1 px-2 py-1 rounded-full transition-all duration-200 hover:bg-red-500/20 hover:scale-110';
  likeButton.innerHTML = `
    <svg class="w-4 h-4 transition-all duration-200 ${suggestion.likes > 0 ? 'text-red-500' : 'text-gray-400'}" 
         fill="${suggestion.likes > 0 ? 'currentColor' : 'none'}" 
         stroke="currentColor" 
         viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
            d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>
    </svg>
    <span class="text-xs font-medium ${suggestion.likes > 0 ? 'text-red-500' : 'text-gray-400'}">${suggestion.likes}</span>
  `;
  
  el.appendChild(textSpan);
  el.appendChild(likeButton);
  
  // æ·»åŠ åˆ°DOMåè·å–å®½åº¦
  barrageArea.value.appendChild(el);
  const width = el.offsetWidth;
  
  const item: BarrageItem = {
    el,
    text: suggestion.text,
    likes: suggestion.likes,
    row,
    x: initialX,
    y: row * ROW_HEIGHT,
    width,
    speed: SPEED_MIN + Math.random() * (SPEED_MAX - SPEED_MIN),
    paused: false
  };
  
  // æ·»åŠ äº‹ä»¶ç›‘å¬
  let pausedX = 0;
  el.addEventListener('mouseenter', () => {
    item.paused = true;
    pausedX = item.x; // ä¿å­˜æš‚åœæ—¶çš„ä½ç½®
    el.style.backgroundColor = 'rgba(147, 51, 234, 0.5)';
    el.style.transform = `translateX(${pausedX}px) scale(1.05)`;
    el.style.boxShadow = '0 4px 20px rgba(147, 51, 234, 0.4)';
  });
  
  el.addEventListener('mouseleave', () => {
    item.paused = false;
    el.style.backgroundColor = 'rgba(0, 0, 0, 0.25)';
    el.style.transform = `translateX(${pausedX}px) scale(1)`;
    el.style.boxShadow = 'none';
  });
  
  // ç‚¹å‡»æ–‡æœ¬å¡«å……åˆ°è¾“å…¥æ¡†
  textSpan.addEventListener('click', (e) => {
    e.stopPropagation();
    userQuestion.value = item.text;
    if (questionInput.value) {
      questionInput.value.focus();
    }
    
    // ç§»é™¤å¼¹å¹•
    item.el.remove();
    const itemIndex = barrageItems.value.indexOf(item);
    if (itemIndex !== -1) {
      barrageItems.value.splice(itemIndex, 1);
    }
  });
  
  // ç‚¹å‡»ç‚¹èµæŒ‰é’®
  likeButton.addEventListener('click', (e) => {
    e.stopPropagation();
    
    // å¢åŠ ç‚¹èµæ•°
    const suggestionIndex = suggestions.value.findIndex(s => s.text === item.text);
    if (suggestionIndex !== -1) {
      suggestions.value[suggestionIndex].likes++;
      item.likes = suggestions.value[suggestionIndex].likes;
      
      // æ›´æ–°æ˜¾ç¤º - Twitteré£æ ¼åŠ¨ç”»
      const likeCount = likeButton.querySelector('span');
      const heartIcon = likeButton.querySelector('svg');
      if (likeCount && heartIcon) {
        likeCount.textContent = item.likes.toString();
        likeCount.className = 'text-xs font-medium text-red-500';
        
        heartIcon.setAttribute('fill', 'currentColor');
        heartIcon.setAttribute('class', 'w-4 h-4 transition-all duration-200 text-red-500');
        
        // Twitteré£æ ¼çš„ç‚¹èµåŠ¨ç”»
        likeButton.style.transform = 'scale(1.3)';
        heartIcon.style.transform = 'scale(1.2)';
        
        setTimeout(() => {
          likeButton.style.transform = 'scale(1)';
          heartIcon.style.transform = 'scale(1)';
        }, 200);
        
        // æ·»åŠ å°å¿ƒå¿ƒé£å‡ºæ•ˆæœ
        const flyHeart = document.createElement('div');
        flyHeart.innerHTML = 'â¤ï¸';
        flyHeart.style.cssText = `
          position: absolute;
          font-size: 12px;
          pointer-events: none;
          animation: fly-heart 1s ease-out forwards;
          left: 50%;
          top: 50%;
          transform: translate(-50%, -50%);
        `;
        likeButton.appendChild(flyHeart);
        
        setTimeout(() => {
          flyHeart.remove();
        }, 1000);
      }
    }
  });
  
  // æ›´æ–°è¡ŒçŠ¶æ€ç®¡ç†
  const currentTime = performance.now();
  const moveDuration = (containerWidth + width) / item.speed * 1000; // å®Œå…¨ç§»å‡ºå±å¹•çš„æ—¶é—´
  
  rowStates.value[row].isOccupied = true;
  rowStates.value[row].lastItemEndTime = currentTime + moveDuration;
  rowStates.value[row].lastItemWidth = width;
  rowStates.value[row].currentItems++;
  
  // æ·»åŠ åˆ°å¼¹å¹•åˆ—è¡¨
  barrageItems.value.push(item);
}

function startReading() {
  if (!selectedSpread.value) return;
  currentStage.value = 'shuffling';
  
  // æ¨¡æ‹Ÿæ´—ç‰ŒåŠ¨ç”»
  setTimeout(() => {
    currentStage.value = 'drawing';
  }, 3500);
}

// æŠ½ç‰Œé€»è¾‘...
const deck = ref<StoryTarotCard[]>([]);

function shuffleAndDeal() {
  deck.value = [...storyTarotDeck].sort(() => Math.random() - 0.5);
}

function drawCard(cardIndex: number) {
  if (!selectedSpread.value || drawnCards.value.length >= selectedSpread.value.positions.length) {
    return;
  }
  
  const card = deck.value.pop();
  if (card) {
    drawnCards.value.push(card);
    // ç¦ç”¨è¢«ç‚¹å‡»çš„å¡ç‰Œ
    const cardElement = document.querySelector(`.deck-card:nth-child(${cardIndex})`);
    if (cardElement) {
      cardElement.classList.add('drawn');
    }
  }
}

async function revealCards() {
  currentStage.value = 'reveal';
  await nextTick();
  
  if (!selectedSpread.value) return;

  try {
    const result = await getTarotReading(drawnCards.value, selectedSpread.value, userQuestion.value);
    
    if (result && result.base) {
      interpretationResult.value = processNewInterpretation(result, drawnCards.value, selectedSpread.value);
    } else {
      console.error('Failed to get interpretation or interpretation.base is missing');
      // å¯ä»¥è®¾ç½®ä¸€ä¸ªå¤‡ç”¨çš„ã€é”™è¯¯çš„è§£è¯»ç»“æœ
    }
  } catch (error) {
    console.error('Error revealing cards:', error);
     // å¯ä»¥è®¾ç½®ä¸€ä¸ªå¤‡ç”¨çš„ã€é”™è¯¯çš„è§£è¯»ç»“æœ
  }
}

// æ‚¬åœæç¤º
const tooltipVisible = ref(false);
const tooltipCard = ref<any>(null);
const cardTooltip = ref<HTMLElement | null>(null);
const tooltipStyle = ref({
  left: '0px',
  top: '0px'
});

function showCardTooltip(event: MouseEvent, card: any) {
  tooltipCard.value = card;
  tooltipVisible.value = true;
  nextTick(() => {
    if (cardTooltip.value) {
      const target = event.currentTarget as HTMLElement;
      const targetRect = target.getBoundingClientRect();
      const tooltipRect = cardTooltip.value.getBoundingClientRect();
      
      let top = targetRect.bottom + window.scrollY + 10;
      let left = targetRect.left + window.scrollX - (tooltipRect.width / 2) + (targetRect.width / 2);

      // Boundary checks
      if (left < 0) left = 10;
      if (left + tooltipRect.width > window.innerWidth) {
        left = window.innerWidth - tooltipRect.width - 10;
      }
      if (top + tooltipRect.height > document.body.scrollHeight) {
        top = targetRect.top + window.scrollY - tooltipRect.height - 10;
      }
      
      tooltipStyle.value = {
        left: `${left}px`,
        top: `${top}px`
      };
    }
  });
}

function hideCardTooltip() {
  tooltipVisible.value = false;
}

// Markdownæ ¼å¼åŒ–
const formatMarkdownContent = (content: string) => {
  if (!content) return '';
  return marked(content, { gfm: true, breaks: true });
};

// å¤„ç†å›¾ç‰‡åŠ è½½é”™è¯¯
function handleImageError(event: Event) {
  const img = event.target as HTMLImageElement;
  img.src = '/static/tarot/- 00_fool_jpg (æ„šè€…).png'; // ä½¿ç”¨æ„šè€…ç‰Œä½œä¸ºé»˜è®¤å›¾ç‰‡
}

// è·å–å…ƒç´ ç¬¦å·
function getElementSymbol(element: string): string {
  const symbols: Record<string, string> = {
    fire: 'ğŸ”¥',
    water: 'ğŸ’§',
    air: 'ğŸ’¨',
    earth: 'ğŸŒ'
  };
  return symbols[element] || 'âœ¨';
}

// è·å–å¡ç‰Œå¸ƒå±€ç±»
function getCardLayoutClass(cardCount: number): string {
  switch (cardCount) {
    case 1:
      return 'grid-cols-1';
    case 2:
      return 'grid-cols-1 md:grid-cols-2';
    case 3:
      return 'grid-cols-1 md:grid-cols-3';
    case 4:
      return 'grid-cols-1 md:grid-cols-2 lg:grid-cols-4';
    case 5:
      return 'grid-cols-1 md:grid-cols-2 lg:grid-cols-3';
    default:
      return 'grid-cols-1 md:grid-cols-2 lg:grid-cols-3';
  }
}

// è·å–å¡ç‰Œå›¾ç‰‡å°ºå¯¸ç±»
function getCardImageClass(cardCount: number): string {
  const baseClass = 'tarot-card-image w-full object-cover rounded-lg';
  switch (cardCount) {
    case 1:
    case 2:
    case 3:
      return `${baseClass} h-48`;
    case 4:
      return `${baseClass} h-40 lg:h-36`;
    case 5:
    case 6:
      return `${baseClass} h-36`;
    default:
      return `${baseClass} h-32`;
  }
}

// ç”Ÿæˆæ¼‚æµ®å¡ç‰Œæ ·å¼
function getFloatingCardStyle(index: number): string {
  const positions = [
    { left: '10%', top: '15%' },
    { left: '85%', top: '25%' },
    { left: '15%', top: '70%' },
    { left: '75%', top: '80%' },
    { left: '45%', top: '10%' },
    { left: '65%', top: '60%' },
    { left: '25%', top: '45%' },
    { left: '80%', top: '45%' }
  ];
  
  const pos = positions[index - 1] || positions[0];
  const duration = 4 + (index * 0.5); // 4-8ç§’ä¸ç­‰çš„åŠ¨ç”»æ—¶é•¿
  const delay = index * 0.3; // é”™å¼€åŠ¨ç”»å¼€å§‹æ—¶é—´
  
  return `
    left: ${pos.left};
    top: ${pos.top};
    font-size: 2rem;
    animation: floatCard ${duration}s ease-in-out infinite ${delay}s;
    transform: rotate(${index * 15}deg);
  `;
}

// ç”Ÿæˆèƒ½é‡ç²’å­æ ·å¼  
function getEnergyParticleStyle(index: number): string {
  const x = Math.random() * 100;
  const y = Math.random() * 100;
  const duration = 2 + Math.random() * 3; // 2-5ç§’éšæœºæ—¶é•¿
  const delay = Math.random() * 2; // 0-2ç§’éšæœºå»¶è¿Ÿ
  const scale = 0.5 + Math.random() * 0.5; // 0.5-1.0éšæœºå¤§å°
  
  return `
    left: ${x}%;
    top: ${y}%;
    font-size: ${scale}rem;
    animation: sparkle ${duration}s ease-in-out infinite ${delay}s;
  `;
}

// ç»„ä»¶æŒ‚è½½æ—¶é¢„åŠ è½½LLMé…ç½®
onMounted(() => {
  // æå‰åˆå§‹åŒ–å¼¹å¹•ï¼Œæå‡ç”¨æˆ·ä½“éªŒ
  initBarrage();
  shuffleAndDeal();
});

// åœ¨ç»„ä»¶åˆ›å»ºé˜¶æ®µå°±å¼€å§‹å‡†å¤‡å¼¹å¹•æ•°æ®
onBeforeMount(() => {
  // é¢„çƒ­å¼¹å¹•ç³»ç»Ÿï¼Œç¡®ä¿æ•°æ®å‡†å¤‡å°±ç»ª
  console.log('ğŸ¯ å¡”ç½—é¡µé¢åˆå§‹åŒ–ï¼Œå‡†å¤‡å¼¹å¹•ç³»ç»Ÿ...');
});

// ç”Ÿæˆæ•´ä½“è§£è¯» - ä¸“æ³¨ç‰Œé¢åˆ†æå’Œç‰Œé˜µå«ä¹‰
function generateOverallInterpretation(cards: any[], spread: TarotSpread, question: string): { title: string; content: string } {
  const cardCount = cards.length;
  const majorCount = cards.filter(card => card.category === 'major').length;
  const minorCount = cards.filter(card => card.category === 'minor').length;
  
  let reading = '';
  
  // ç‰Œé˜µç»“æ„åˆ†æ
  reading += `## ç‰Œé˜µç»“æ„åˆ†æ\n\n`;
  reading += `**${spread.chineseName}** ä¸ºæ‚¨å±•ç°äº†å…³äº"${question}"çš„å®Œæ•´ç”»é¢ã€‚`;
  
  // ç‰Œé¢ç»„åˆåˆ†æ
  reading += `\n\n## ç‰Œé¢ç»„åˆç‰¹å¾\n\n`;
  if (majorCount > minorCount) {
    reading += `ğŸŒŸ **å¤§é˜¿å°”å¡çº³ä¸»å¯¼** (${majorCount}/${cardCount}å¼ )\n`;
    reading += `è¿™è¡¨æ˜æ‚¨çš„é—®é¢˜æ¶‰åŠé‡å¤§çš„äººç”Ÿè¯¾é¢˜å’Œç²¾ç¥æˆé•¿ã€‚å®‡å®™æ­£åœ¨ä¸ºæ‚¨å¼€å¯é‡è¦çš„è½¬æŠ˜ç‚¹ï¼Œè¿™ä¸ä»…ä»…æ˜¯è¡¨é¢é—®é¢˜çš„è§£å†³ï¼Œæ›´æ˜¯çµé­‚å±‚é¢çš„æ·±åº¦è½¬åŒ–ã€‚`;
  } else if (minorCount > majorCount) {
    reading += `âš¡ **å°é˜¿å°”å¡çº³ä¸»å¯¼** (${minorCount}/${cardCount}å¼ )\n`;
    reading += `è¿™è¡¨æ˜è§£å†³æ–¹æ¡ˆæ›´å¤šä½“ç°åœ¨æ—¥å¸¸è¡ŒåŠ¨å’Œå…·ä½“å®è·µä¸­ã€‚é€šè¿‡è°ƒæ•´ç”Ÿæ´»ç»†èŠ‚å’Œæ”¹å˜è¡Œä¸ºæ¨¡å¼ï¼Œæ‚¨èƒ½å¤Ÿæœ‰æ•ˆåœ°æ”¹å–„å½“å‰çŠ¶å†µã€‚`;
  } else {
    reading += `âš–ï¸ **å¤§å°é˜¿å°”å¡çº³å¹³è¡¡** (${majorCount}:${minorCount})\n`;
    reading += `è¿™æ˜¾ç¤ºäº†ç²¾ç¥è§‰é†’ä¸å®é™…è¡ŒåŠ¨çš„å®Œç¾ç»“åˆã€‚æ‚¨éœ€è¦åœ¨å†…åœ¨æˆé•¿å’Œå¤–åœ¨åŠªåŠ›ä¹‹é—´æ‰¾åˆ°å¹³è¡¡ç‚¹ã€‚`;
  }
  
  // ç‰Œé¢èƒ½é‡æµåŠ¨åˆ†æ
  reading += `\n\n## èƒ½é‡æµåŠ¨è¶‹åŠ¿\n\n`;
  const cardNames = cards.map(card => card.chineseName || card.name);
  reading += `ä» **${cardNames[0]}** åˆ° **${cardNames[cardNames.length - 1]}**ï¼Œèƒ½é‡å‘ˆç°å‡º`;
  
  if (spread.chineseName === 'ä¸‰å¼ ç‰Œå åœæ³•') {
    reading += `æ—¶é—´çº¿çš„å‘å±•è½¨è¿¹ï¼Œè¿‡å»çš„ç§¯ç´¯æ­£åœ¨è½¬åŒ–ä¸ºæœªæ¥çš„å¯èƒ½æ€§ã€‚`;
  } else if (spread.chineseName === 'æ‹äººé‡‘å­—å¡”') {
    reading += `æƒ…æ„Ÿå…³ç³»çš„å±‚æ¬¡ç»“æ„ï¼Œä»åŸºç¡€å»ºç«‹åˆ°æœªæ¥å‘å±•çš„å®Œæ•´è„‰ç»œã€‚`;
  } else {
    reading += `å¤šç»´åº¦çš„å±•å¼€æ¨¡å¼ï¼Œå„ä¸ªå±‚é¢ç›¸äº’å½±å“ã€ç›¸äº’æ”¯æ’‘ã€‚`;
  }
  
  return {
    title: 'æ•´ä½“è§£è¯»',
    content: reading
  };
}

// ç”Ÿæˆå•ç‰Œè§£è¯»
function generateCardInterpretations(cards: any[], spread: TarotSpread, question: string): any[] {
  return cards.map((card, index) => {
    const position = spread.positions[index];
    
    return {
      position: position.chineseName,
      cardName: card.name,
      interpretation: card.meaning
    };
  });
}

// ç”Ÿæˆå»ºè®®æŒ‡å¯¼ï¼ˆé™çº§ç‰ˆæœ¬ï¼‰
function generateGuidance(cards: any[], question: string): { title: string; content: string } {
  return {
    title: 'æ™ºæ…§æŒ‡å¼•ä¸è¡ŒåŠ¨å»ºè®®',
    content: `åŸºäºå¡”ç½—ç‰Œçš„æŒ‡å¼•ï¼Œå»ºè®®æ‚¨ä¿æŒå¼€æ”¾çš„å¿ƒæ€ï¼Œç›¸ä¿¡å†…å¿ƒçš„æ™ºæ…§ã€‚ç»“åˆæ‚¨çš„é—®é¢˜"${question}"ï¼Œè¯·ä»”ç»†æ„Ÿå—æ¯å¼ ç‰Œçš„èƒ½é‡ï¼Œè®©å®‡å®™çš„æ™ºæ…§ä¸ºæ‚¨æŒ‡æ˜å‰è¿›çš„æ–¹å‘ã€‚`
  };
}

// ç»„ä»¶å¸è½½æ—¶æ¸…ç†
onUnmounted(() => {
  if (animationFrame) {
    cancelAnimationFrame(animationFrame);
  }
});

// ä½¿ç”¨å…¨å±€AIè§£è¯»composableå’Œé…ç½®store
const { 
  getReading
} = useAIReading();
const llmConfigStore = useLLMConfigStore();

// æ ¼å¼åŒ–è§£è¯»å†…å®¹ - æ™ºèƒ½åˆ†æ®µå’Œç»“æ„åŒ–å¤„ç†
function formatInterpretationContent(content: string): string[] {
  if (!content) return [];
  
  // ç¬¬ä¸€æ­¥ï¼šåŸºç¡€æ¸…ç†
  let cleanContent = content
    // æ¸…ç†JSONæ®‹ç•™
    .replace(/```json\s*/g, '')
    .replace(/```\s*/g, '')
    .replace(/^\s*{\s*$/gm, '')
    .replace(/^\s*}\s*$/gm, '')
    .replace(/^\s*"[^"]*":\s*/gm, '')
    .replace(/",?\s*$/gm, '')
    // æ¸…ç†è½¬ä¹‰å­—ç¬¦
    .replace(/\\"/g, '"')
    .replace(/\\n/g, '\n')
    .replace(/\\\//g, '/')
    .replace(/\\\\/g, '\\')
    // æ ‡å‡†åŒ–ç©ºç™½å­—ç¬¦
    .replace(/\s+/g, ' ')
    .replace(/\n\s+/g, '\n')
    .trim();
  
  // ç¬¬äºŒæ­¥ï¼šæ™ºèƒ½è¯†åˆ«å’Œå¤„ç†markdownç»“æ„
  const sections: string[] = [];
  
  // æŒ‰markdownæ ‡é¢˜å’Œç»“æ„åˆ†å‰²
  const parts = cleanContent.split(/(?=##\s|###\s|\*\*[^*]+\*\*|^\d+\.\s|^[â€¢Â·]\s)/gm);
  
  for (const part of parts) {
    const trimmedPart = part.trim();
    if (!trimmedPart || trimmedPart.length < 10) continue;
  
    // å¤„ç†æ ‡é¢˜
    if (trimmedPart.startsWith('##')) {
      sections.push(trimmedPart);
      continue;
    }
    
    // å¤„ç†æœ‰ç»“æ„çš„å†…å®¹
    if (trimmedPart.includes('**') || trimmedPart.includes('â€¢') || trimmedPart.includes('ï¼š')) {
      // ä¿æŒç»“æ„åŒ–å†…å®¹çš„å®Œæ•´æ€§
      sections.push(trimmedPart);
      continue;
    }
    
    // å¤„ç†é•¿æ®µè½ - æ™ºèƒ½åˆ†å‰²
    if (trimmedPart.length > 200) {
      const sentences = trimmedPart.split(/([ã€‚ï¼ï¼Ÿ.!?]+\s*)/);
      let currentChunk = '';
    
    for (let i = 0; i < sentences.length; i += 2) {
      const sentence = sentences[i]?.trim() || '';
      const punctuation = sentences[i + 1]?.trim() || '';
      
      if (sentence) {
        const fullSentence = sentence + punctuation;
        
          if (currentChunk.length + fullSentence.length > 150 && currentChunk) {
            sections.push(currentChunk.trim());
            currentChunk = fullSentence;
        } else {
            currentChunk += (currentChunk ? ' ' : '') + fullSentence;
          }
        }
      }
      
      if (currentChunk.trim()) {
        sections.push(currentChunk.trim());
            }
          } else {
      sections.push(trimmedPart);
    }
  }
  
  // ç¬¬ä¸‰æ­¥ï¼šåå¤„ç†å’Œä¼˜åŒ–
  const finalSections = sections
    .filter(section => {
      // è¿‡æ»¤æ— æ•ˆå†…å®¹
      const clean = section.replace(/[^\u4e00-\u9fff\w\s]/g, '').trim();
      return clean.length > 8;
    })
    .map(section => {
      // ä¼˜åŒ–æ ¼å¼
      return section
        .replace(/\s+/g, ' ')
        .replace(/([ã€‚ï¼ï¼Ÿ.!?])\1+/g, '$1')
             .trim();
    })
    .filter(section => {
      // æœ€ç»ˆè¿‡æ»¤
      return section.length > 15 && 
             !section.match(/^[\s\.,ï¼Œã€‚ï¼ï¼Ÿ!?]*$/) &&
             !section.includes('position') &&
             !section.includes('cardName') &&
             !section.includes('interpretation');
    });
  
  // å¦‚æœå¤„ç†åæ²¡æœ‰æœ‰æ•ˆå†…å®¹ï¼Œæä¾›é»˜è®¤å†…å®¹
  if (finalSections.length === 0) {
    return ['å¡”ç½—ç‰Œä¸ºæ‚¨å¸¦æ¥æ·±åˆ»çš„æ™ºæ…§ä¸æŒ‡å¼•ï¼Œæ¯ä¸€å¼ ç‰Œéƒ½è•´å«ç€å®‡å®™çš„ç¥ç§˜ä¿¡æ¯ã€‚'];
  }
  
  return finalSections;
}

// æ–°å¢ï¼šå¤„ç†æ–°ç‰ˆAPIè¿”å›ç»“æœçš„å‡½æ•°
function processNewInterpretation(
  raw: EnhancedTarotInterpretation, 
  drawnCards: StoryTarotCard[], 
  spread: TarotSpread
): ProcessedInterpretation {
  return {
    cards: drawnCards.map((card, index) => ({
      name: card.chineseName || card.name,
      englishName: card.name,
      position: spread.positions[index]?.chineseName || `ä½ç½® ${index + 1}`,
      meaning: card.meaning,
      keywords: Array.isArray(card.keywords) ? card.keywords.join(', ') : '',
      imageUrl: card.imageUrl,
      category: card.category,
      element: card.element,
      fullInterpretation: card.storyInterpretation || card.meaning
    })),
    sections: raw.base,
  };
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”ŸæˆåŸºç¡€é™çº§è§£è¯»ï¼ˆæœ€åçš„ä¿éšœï¼‰
function generateBasicFallbackInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): ProcessedInterpretation {
  const cardInfos = cards.map((card, index) => {
    const position = spread.positions[index];
    const keywords = Array.isArray(card.keywords) ? card.keywords.join(', ') : card.keywords;
    
    return {
      name: card.chineseName || card.name,
      englishName: card.name,
      position: position.chineseName || position.name,
      meaning: `${card.chineseName || card.name}åœ¨${position.chineseName || position.name}ä½ç½®ä¸Šä¸ºæ‚¨å¸¦æ¥æŒ‡å¼•ã€‚`,
      fullInterpretation: card.storyInterpretation || 'è¿™å¼ ç‰Œè•´å«ç€æ·±åˆ»çš„æ™ºæ…§',
      keywords,
      imageUrl: card.imageUrl,
      category: card.category,
      element: card.element || 'earth'
    };
  });
  
  return {
    cards: cardInfos,
    sections: [
      {
        icon: 'ğŸŒŸ',
        title: 'æ•´ä½“è§£è¯»',
        content: `é€šè¿‡${spread.chineseName || spread.name}ï¼Œå¡”ç½—ç‰Œä¸ºæ‚¨çš„é—®é¢˜"${question}"æä¾›äº†æŒ‡å¼•ã€‚è¯·ä»”ç»†æ„Ÿå—æ¯å¼ ç‰Œçš„èƒ½é‡å’Œå«ä¹‰ã€‚`
      },
      {
        icon: 'ğŸ’¡',
        title: 'æ™ºæ…§æŒ‡å¼•ä¸è¡ŒåŠ¨å»ºè®®',
        content: `åŸºäºå¡”ç½—ç‰Œçš„æŒ‡å¼•ï¼Œå»ºè®®æ‚¨ä¿æŒå¼€æ”¾çš„å¿ƒæ€ï¼Œç›¸ä¿¡å†…å¿ƒçš„æ™ºæ…§ã€‚ç»“åˆæ‚¨çš„é—®é¢˜"${question}"ï¼Œè¯·ä»”ç»†æ„Ÿå—æ¯å¼ ç‰Œçš„èƒ½é‡ï¼Œè®©å®‡å®™çš„æ™ºæ…§ä¸ºæ‚¨æŒ‡æ˜å‰è¿›çš„æ–¹å‘ã€‚`
      }
    ],
  };
}

// ç”Ÿæˆæ ¸å¿ƒå¯ç¤º - ä¸“æ³¨äººç”Ÿå“²ç†å’Œæ·±å±‚æ´å¯Ÿ
function generateSummary(cards: any[]): { title: string; content: string } {
  const question = userQuestion.value;
  const cardNames = cards.map(card => card.chineseName || card.name);
  const majorCount = cards.filter(card => card.category === 'major').length;
  
  let insight = '';
  
  // æ ¸å¿ƒäººç”Ÿå¯ç¤º
  insight += `## æ ¸å¿ƒäººç”Ÿå¯ç¤º\n\n`;
  
  if (question.includes('é€‰æ‹©') || question.includes('å†³å®š')) {
    insight += `ğŸ¯ **é€‰æ‹©çš„æ™ºæ…§**\n`;
    insight += `çœŸæ­£çš„é€‰æ‹©ä»æ¥ä¸æ˜¯åœ¨å¤–åœ¨çš„é€‰é¡¹ä¹‹é—´ï¼Œè€Œæ˜¯åœ¨ä¸åŒçš„è‡ªå·±ä¹‹é—´ã€‚æ¯ä¸€æ¬¡é€‰æ‹©ï¼Œéƒ½æ˜¯åœ¨é€‰æ‹©æˆä¸ºä»€ä¹ˆæ ·çš„äººã€‚${cardNames[0]}æé†’æ‚¨è¦å€¾å¬å†…å¿ƒçš„å£°éŸ³ï¼Œ${cardNames[cardNames.length - 1]}æŒ‡å¼•æ‚¨èµ°å‘çœŸæ­£çš„è‡ªæˆ‘ã€‚`;
  } else if (question.includes('å›°éš¾') || question.includes('æŒ‘æˆ˜') || question.includes('é—®é¢˜')) {
    insight += `ğŸŒ± **æˆé•¿çš„æ™ºæ…§**\n`;
    insight += `å›°éš¾ä¸æ˜¯ç”Ÿæ´»å¯¹æ‚¨çš„æƒ©ç½šï¼Œè€Œæ˜¯å®‡å®™ç»™æ‚¨çš„ç¤¼ç‰©ã€‚æ¯ä¸€ä¸ªæŒ‘æˆ˜éƒ½æºå¸¦ç€è®©æ‚¨å˜å¾—æ›´å¼ºå¤§ã€æ›´æ™ºæ…§çš„èƒ½é‡ã€‚${cardNames[0]}æ˜¾ç¤ºäº†æŒ‘æˆ˜çš„æœ¬è´¨ï¼Œ${cardNames[cardNames.length - 1]}æŒ‡å‘äº†æˆé•¿çš„æ–¹å‘ã€‚`;
  } else if (question.includes('æœªæ¥') || question.includes('å‰æ™¯')) {
    insight += `âœ¨ **åˆ›é€ çš„æ™ºæ…§**\n`;
    insight += `æœªæ¥ä¸æ˜¯ä¸€ä¸ªå›ºå®šçš„ç›®çš„åœ°ï¼Œè€Œæ˜¯æ‚¨æ¯ä¸€ä¸ªå½“ä¸‹é€‰æ‹©çš„ç´¯ç§¯ã€‚æ‚¨ä¸æ˜¯åœ¨ç­‰å¾…æœªæ¥çš„åˆ°æ¥ï¼Œè€Œæ˜¯åœ¨æ¯ä¸€ä¸ªæ­¤åˆ»åˆ›é€ ç€æœªæ¥ã€‚${cardNames[0]}æé†’æ‚¨æŒæ¡å½“ä¸‹ï¼Œ${cardNames[cardNames.length - 1]}æŒ‡å¼•æ‚¨åˆ›é€ æ˜å¤©ã€‚`;
  } else {
    insight += `ğŸŒŒ **ç”Ÿå‘½çš„æ™ºæ…§**\n`;
    insight += `ç”Ÿå‘½æ˜¯ä¸€åœºç¥åœ£çš„æ—…ç¨‹ï¼Œæ¯ä¸€ä¸ªç»å†éƒ½æ˜¯çµé­‚æˆé•¿çš„å…»åˆ†ã€‚${cardNames[0]}æé†’æ‚¨ä¿æŒåˆå¿ƒï¼Œ${cardNames[cardNames.length - 1]}æŒ‡å¼•æ‚¨ç›¸ä¿¡å‰æ–¹çš„å…‰æ˜ã€‚`;
  }
  
  // æ·±å±‚ç²¾ç¥å†…æ¶µ
  insight += `\n\n## ç²¾ç¥å†…æ¶µä¸è§‰é†’\n\n`;
  if (majorCount > cards.length / 2) {
    insight += `ğŸ† **çµé­‚è§‰é†’çš„æ—¶åˆ»**\n`;
    insight += `å¤§é˜¿å°”å¡çº³çš„ä¸»å¯¼æ˜¾ç¤ºï¼Œæ‚¨æ­£åœ¨ç»å†ä¸€æ¬¡æ·±åˆ»çš„ç²¾ç¥è½¬åŒ–ã€‚è¿™ä¸ä»…ä»…æ˜¯å¤–åœ¨é—®é¢˜çš„è§£å†³ï¼Œæ›´æ˜¯å†…åœ¨æ„è¯†çš„å‡åã€‚è¯·ä»¥å¼€æ”¾çš„å¿ƒæ€è¿æ¥è¿™ä¸ªè½¬å˜ã€‚`;
  } else {
    insight += `ğŸŒ¿ **å®è·µä¸­çš„æ™ºæ…§**\n`;
    insight += `å°é˜¿å°”å¡çº³çš„ä¸»å¯¼æé†’æ‚¨ï¼Œæœ€æ·±åˆ»çš„æ™ºæ…§å¾€å¾€éšè—åœ¨æœ€å¹³å‡¡çš„æ—¥å¸¸ä¸­ã€‚ç”Ÿæ´»çš„çœŸè°›ä¸åœ¨äºè¿½æ±‚è½°è½°çƒˆçƒˆï¼Œè€Œåœ¨äºåœ¨å¹³å‡¡ä¸­å‘ç°ç¥åœ£ã€‚`;
  }
  
  insight += `\n\nğŸ’« **æœ€ç»ˆå¯ç¤º**\n`;
  insight += `å¡”ç½—ç‰Œä¸æ˜¯åœ¨é¢„æµ‹å‘½è¿ï¼Œè€Œæ˜¯åœ¨æ­ç¤ºæ‚¨å†…åœ¨çš„æ™ºæ…§ã€‚æ‚¨å·²ç»æ‹¥æœ‰äº†æ‰€æœ‰éœ€è¦çš„ç­”æ¡ˆï¼Œåªæ˜¯æœ‰æ—¶éœ€è¦ä¸€é¢é•œå­æ¥çœ‹æ¸…å®ƒä»¬ã€‚æ„¿è¿™æ¬¡ç¥åœ£çš„è¿æ¥ä¸ºæ‚¨çš„äººç”Ÿæ—…ç¨‹å¸¦æ¥å…‰æ˜ä¸åŠ›é‡ã€‚`;
  
  return {
    title: 'æ ¸å¿ƒå¯ç¤ºä¸äººç”Ÿæ„Ÿæ‚Ÿ',
    content: insight
  };
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç»Ÿä¸€è°ƒç”¨LLMService
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<ProcessedInterpretation> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // åŠ¨æ€å¯¼å…¥LLMServiceä»¥é¿å…å¾ªç¯ä¾èµ–
    const { LLMService } = await import('../../../services/LLMService');
    
    // è®¾ç½®çŠ¶æ€ç›‘å¬
    const handleLoadingStateChange = (state: any) => {
      llmLoading.value = state.isLoading;
      llmLoadingMessage.value = state.progress;
      llmLoadingStage.value = state.stage;
    };
    
    LLMService.onLoadingStateChange(handleLoadingStateChange);
    
    try {
      // è°ƒç”¨ç»Ÿä¸€çš„å¡”ç½—è§£è¯»æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç°åœ¨è¿”å› EnhancedTarotInterpretation
      const enhancedResult = await LLMService.getTarotInterpretation(cards, spread, question);
      
      // ä½¿ç”¨æ–°çš„ç»„åˆå‡½æ•°æ¥ç”Ÿæˆæœ€ç»ˆçš„æ˜¾ç¤ºç»“æœ
      return processNewInterpretation(enhancedResult, cards, spread);
      
    } finally {
      // æ¸…ç†çŠ¶æ€ç›‘å¬
      LLMService.offLoadingStateChange(handleLoadingStateChange);
    }
    
  } catch (error) {
    console.error('âŒ å¡”ç½—è§£è¯»ç”Ÿæˆå¤±è´¥:', error);
    
    // ç”ŸæˆåŸºç¡€é™çº§è§£è¯»
    return generateBasicFallbackInterpretation(cards, spread, question);
  }
}

// ç”Ÿæˆ