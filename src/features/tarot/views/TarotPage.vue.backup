<template>
  <div class="tarot-page min-h-screen bg-gradient-to-br from-indigo-900 via-purple-900 to-pink-900">
    <!-- èƒŒæ™¯æ˜Ÿç©ºæ•ˆæœ -->
    <div class="stars-background">
      <div class="stars" v-for="n in 50" :key="n" 
           :style="{ 
             left: Math.random() * 100 + '%', 
             top: Math.random() * 100 + '%',
             animationDelay: Math.random() * 3 + 's'
           }">â­</div>
    </div>

    <div class="container mx-auto px-4 py-8 relative z-10">
      <!-- æ ‡é¢˜ -->
      <div class="text-center mb-12">
        <h1 class="text-5xl font-bold text-white mb-4 mystical-glow">ğŸ”® å¡”ç½—å åœ ğŸ”®</h1>
        <p class="text-xl text-purple-200">æ¢ç´¢å‘½è¿çš„ç¥ç§˜é¢çº±ï¼Œè†å¬å¿ƒçµçš„æ™ºæ…§ä¹‹å£°</p>
      </div>

      <!-- é˜¶æ®µ1: ä»‹ç»å’Œé—®é¢˜è¾“å…¥ -->
      <div v-if="currentStage === 'intro'" class="max-w-4xl mx-auto">
        <div class="bg-black/30 backdrop-blur-md rounded-3xl p-8 border border-purple-500/30 shadow-2xl">
          <div class="text-center mb-8">
            <div class="text-6xl mb-6 animate-pulse">ğŸŒŸ</div>
            <h2 class="text-3xl font-bold text-white mb-4">æ¬¢è¿æ¥åˆ°ç¥ç§˜çš„å¡”ç½—ä¸–ç•Œ</h2>
            <p class="text-lg text-purple-200 mb-6 leading-relaxed">
              å¡”ç½—ç‰Œæ˜¯å¤è€çš„æ™ºæ…§ç»“æ™¶ï¼Œèƒ½å¤Ÿå¸®åŠ©æ‚¨æ¢ç´¢å†…å¿ƒæ·±å¤„çš„ç­”æ¡ˆã€‚<br>
              åœ¨å¼€å§‹å åœä¹‹å‰ï¼Œè¯·é™ä¸‹å¿ƒæ¥ï¼Œä¸“æ³¨äºæ‚¨æƒ³è¦äº†è§£çš„é—®é¢˜ã€‚
            </p>
          </div>

          <!-- é—®é¢˜è¾“å…¥ -->
          <div class="mb-8">
            <!-- å¼¹å¹•é«˜é¢‘é—®é¢˜åŒºåŸŸ -->
            <div class="mb-6">
              <div class="text-center mb-4">
                <h3 class="text-lg font-medium text-purple-200 mb-2">ğŸ’« é«˜é¢‘é—®é¢˜å¼¹å¹•</h3>
                <p class="text-sm text-purple-300">ç‚¹å‡»é£˜è¿‡çš„é—®é¢˜å¯å¿«é€Ÿå¡«å……ï¼Œæ‚¬åœå¯ç‚¹èµ</p>
              </div>
              <div 
                ref="barrageArea"
                class="barrage-area relative w-full h-32 overflow-hidden bg-white/5 rounded-xl border border-purple-400/30 shadow-inner"
              ></div>
            </div>
            
            <label class="block text-white text-lg font-medium mb-4">
              ğŸ’­ è¯·è¾“å…¥æ‚¨æƒ³è¦å’¨è¯¢çš„é—®é¢˜ï¼ˆå¯é€‰ï¼‰
            </label>
            <textarea 
              ref="questionInput"
              v-model="userQuestion"
              placeholder="ä¾‹å¦‚ï¼šæˆ‘çš„äº‹ä¸šå‘å±•å¦‚ä½•ï¼Ÿæˆ‘çš„æ„Ÿæƒ…è¿åŠ¿æ€æ ·ï¼Ÿæˆ‘åº”è¯¥å¦‚ä½•é¢å¯¹å½“å‰çš„å›°å¢ƒï¼Ÿ"
              class="w-full h-32 px-4 py-3 bg-white/10 border border-purple-400/50 rounded-lg text-white placeholder-purple-300 focus:outline-none focus:border-purple-400 focus:ring-2 focus:ring-purple-400/50 resize-none"
            ></textarea>
          </div>

          <div class="text-center">
            <button 
              @click="goToSpreadSelection" 
              class="bg-gradient-to-r from-purple-600 to-pink-600 text-white text-xl font-bold py-4 px-12 rounded-full shadow-lg hover:shadow-2xl transform hover:scale-105 transition-all duration-300 mystical-glow"
            >
              ğŸ´ é€‰æ‹©ç‰Œé˜µ
            </button>
          </div>
        </div>
      </div>

      <!-- é˜¶æ®µ1.5: ç‰Œé˜µé€‰æ‹© -->
      <div v-if="currentStage === 'spreadSelection'" class="max-w-6xl mx-auto">
        <div class="bg-black/30 backdrop-blur-md rounded-3xl p-8 border border-purple-500/30 shadow-2xl">
          <div class="text-center mb-12">
            <div class="text-5xl mb-6 animate-pulse">ğŸ”®</div>
            <h2 class="text-3xl font-bold text-white mb-4">é€‰æ‹©æ‚¨çš„ä¸“å±ç‰Œé˜µ</h2>
            <p class="text-lg text-purple-200 mb-8">æ¯ä¸ªç‰Œé˜µéƒ½æœ‰å…¶ç‹¬ç‰¹çš„æ™ºæ…§ä¸å¯ç¤ºï¼Œè¯·æ ¹æ®æ‚¨çš„é—®é¢˜é€‰æ‹©æœ€é€‚åˆçš„ç‰Œé˜µ</p>
          </div>

          <!-- ç‰Œé˜µé€‰æ‹©ç½‘æ ¼ -->
          <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-8">
            <div 
              v-for="(spread, index) in classicSpreads" 
              :key="spread.name"
              class="spread-card cursor-pointer transform transition-all duration-300 hover:scale-105 hover:-translate-y-2"
              :class="{ 'selected': selectedSpread?.name === spread.name }"
              @click="selectSpread(spread)"
            >
              <div class="bg-gradient-to-br from-purple-800/50 to-indigo-900/50 backdrop-blur-sm rounded-2xl p-6 border border-purple-400/30 shadow-xl h-full flex flex-col">
                <!-- ç‰Œé˜µå¤´éƒ¨ -->
                <div class="text-center mb-4">
                  <div class="text-4xl mb-3">{{ getSpreadIcon(spread.name) }}</div>
                  <h3 class="text-xl font-bold text-white mb-2">{{ spread.chineseName }}</h3>
                  <div class="text-sm text-purple-300 mb-4">{{ spread.positions.length }}å¼ ç‰Œ</div>
                </div>

                <!-- æ ¸å¿ƒä¼˜åŠ¿ - æœ€çªå‡ºçš„ä½ç½® -->
                <div class="bg-gradient-to-r from-yellow-400/20 to-orange-400/20 rounded-xl p-4 mb-4 border border-yellow-400/40">
                  <div class="text-center">
                    <div class="text-yellow-200 text-sm font-bold mb-2 flex items-center justify-center">
                      <span class="mr-2">â­</span>
                      <span>æœ€æ“…é•¿è§£å†³</span>
                    </div>
                    <div class="text-yellow-100 text-base font-semibold">{{ spread.bestFor[0] }}</div>
                  </div>
                </div>

                <!-- å…¶ä»–é€‚ç”¨åœºæ™¯ -->
                <div class="mb-4 flex-1">
                  <div class="text-purple-300 text-xs mb-2 text-center opacity-80">ä¹Ÿé€‚ç”¨äº</div>
                  <div class="flex flex-wrap gap-1 justify-center">
                    <span 
                      v-for="purpose in spread.bestFor.slice(1, 3)" 
                      :key="purpose"
                      class="px-3 py-1 text-xs bg-purple-600/30 text-purple-200 rounded-full border border-purple-500/30"
                    >
                      {{ purpose }}
                    </span>
                  </div>
                </div>

                <!-- ç®€åŒ–æè¿° - æ”¾åœ¨æœ€åº•éƒ¨ -->
                <div class="mt-auto pt-3 border-t border-purple-500/20">
                  <p class="text-xs text-purple-400 text-white opacity-80 leading-relaxed word-wrap: break-word; overflow-wrap: break-word;">
                    {{ spread.description.length > 40 ? spread.description.slice(0, 40) + '...' : spread.description }}
                  </p>
                </div>
              </div>
            </div>
          </div>

          <!-- é€‰ä¸­ç‰Œé˜µè¯¦æƒ… -->
          <div v-if="selectedSpread" class="bg-purple-900/20 rounded-2xl p-6 mb-8 border border-purple-400/20">
            <h3 class="text-2xl font-bold text-white mb-4 text-center">{{ selectedSpread.chineseName }} è¯¦ç»†è¯´æ˜</h3>
            <p class="text-purple-200 mb-6 text-center leading-relaxed">{{ selectedSpread.description }}</p>
            
            <!-- ç‰Œä½è¯´æ˜ -->
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
              <div 
                v-for="(position, index) in selectedSpread.positions" 
                :key="index"
                class="bg-black/20 rounded-lg p-4 border border-purple-400/20"
              >
                <div class="text-center">
                  <div class="text-2xl mb-2">{{ index + 1 }}</div>
                  <h4 class="text-white font-medium mb-2">{{ position.chineseName }}</h4>
                  <p class="text-purple-300 text-sm">{{ position.meaning }}</p>
                </div>
              </div>
            </div>
          </div>

          <!-- æ“ä½œæŒ‰é’® -->
          <div class="flex justify-center space-x-6">
            <button 
              @click="goBackToIntro" 
              class="bg-gray-600 hover:bg-gray-700 text-white text-lg font-medium py-3 px-8 rounded-full transition-colors duration-300"
            >
              â† è¿”å›
            </button>
            <button 
              @click="startReading" 
              :disabled="!selectedSpread"
              class="bg-gradient-to-r from-purple-600 to-pink-600 text-white text-lg font-bold py-3 px-12 rounded-full shadow-lg hover:shadow-2xl transform hover:scale-105 transition-all duration-300 mystical-glow disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none"
            >
              ğŸ´ å¼€å§‹å åœ
            </button>
          </div>
        </div>
      </div>

      <!-- é˜¶æ®µ2: æ´—ç‰ŒåŠ¨ç”» -->
      <div v-if="currentStage === 'shuffling'" class="max-w-4xl mx-auto text-center">
        <div class="bg-black/30 backdrop-blur-md rounded-3xl p-12 border border-purple-500/30 shadow-2xl">
          <h2 class="text-3xl font-bold text-white mb-8">ğŸŒ€ æ­£åœ¨æ´—ç‰Œ...</h2>
          <p class="text-lg text-purple-200 mb-8">è¯·ä¸“æ³¨äºæ‚¨çš„é—®é¢˜ï¼Œè®©å®‡å®™çš„èƒ½é‡æµå…¥ç‰Œä¸­</p>
          
          <div class="loading-dots">
            <span></span><span></span><span></span>
          </div>
        </div>
      </div>

      <!-- é˜¶æ®µ3: æŠ½ç‰Œ -->
      <div v-if="currentStage === 'drawing'" class="max-w-6xl mx-auto">
        <div class="bg-black/30 backdrop-blur-md rounded-3xl p-8 border border-purple-500/30 shadow-2xl">
          <div class="text-center mb-8">
            <h2 class="text-3xl font-bold text-white mb-4">âœ¨ é€‰æ‹©æ‚¨çš„å‘½è¿ä¹‹ç‰Œ</h2>
            <p class="text-lg text-purple-200 mb-6">è¯·ç”¨å¿ƒæ„Ÿå—ï¼Œç‚¹å‡»ä¸‹æ–¹çš„ç‰Œæ¥æŠ½å–æ‚¨çš„{{ selectedSpread?.positions.length || 3 }}å¼ ç‰Œ</p>
            <p class="text-purple-300">å·²æŠ½å–: {{ drawnCards.length }} / {{ selectedSpread?.positions.length || 3 }}</p>
          </div>

          <!-- ç‰Œå †å±•ç¤º -->
          <div class="deck-spread flex justify-center items-center mb-8 flex-wrap gap-4">
            <div 
              v-for="n in Math.max(7, selectedSpread?.positions.length || 3)" 
              :key="n"
              class="deck-card cursor-pointer transform transition-all duration-500 hover:scale-110 hover:-translate-y-4"
              @click="drawCard(n)"
            >
              <div class="w-24 h-36 bg-gradient-to-br from-indigo-600 to-purple-700 rounded-lg shadow-lg flex items-center justify-center border border-purple-400/50">
                <div class="text-white text-3xl transform rotate-12">ğŸƒ</div>
              </div>
            </div>
          </div>

          <!-- å·²æŠ½å–çš„ç‰Œä½ -->
          <div class="drawn-positions mt-12">
            <div class="grid gap-4 grid-cols-1 md:grid-cols-3">
              <div 
                v-for="(position, index) in positions" 
                :key="index"
                class="position-slot"
              >
                <div class="text-center mb-4">
                  <h3 class="text-lg font-bold text-white mb-2">{{ position }}</h3>
                </div>
                <div 
                  class="card-slot w-28 h-40 mx-auto rounded-lg border-2 border-dashed border-purple-400/50 flex items-center justify-center"
                  :class="{ 'filled': drawnCards[index] }"
                >
                  <div v-if="!drawnCards[index]" class="text-purple-400 text-5xl opacity-50">?</div>
                  <div 
                    v-else 
                    class="drawn-card-preview w-full h-full bg-gradient-to-br from-purple-800 to-indigo-900 rounded-lg flex flex-col items-center justify-center transform animate-flip-in relative overflow-hidden border border-purple-400/50"
                  >
                    <div class="relative z-10 text-center">
                      <div class="text-white text-2xl mb-1 animate-pulse">ğŸŒŸ</div>
                      <div class="text-white/60 text-xs font-medium">å·²é€‰æ‹©</div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <div v-if="drawnCards.length === (selectedSpread?.positions.length || 3)" class="text-center mt-8">
            <button 
              @click="revealCards" 
              class="bg-gradient-to-r from-pink-600 to-red-600 text-white text-xl font-bold py-4 px-12 rounded-full shadow-lg hover:shadow-2xl transform hover:scale-105 transition-all duration-300 mystical-glow"
            >
              âœ¨ æ­ç¤ºå‘½è¿
            </button>
          </div>
        </div>
      </div>

      <!-- é˜¶æ®µ4: ç¿»ç‰Œå’Œè§£è¯» -->
      <div v-if="currentStage === 'reveal'" class="max-w-6xl mx-auto">
        <div class="bg-black/30 backdrop-blur-md rounded-3xl p-8 border border-purple-500/30 shadow-2xl">
          <h1 class="text-white text-5xl text-center">ğŸ´ å‘½è¿è§£è¯»</h1>
          <p class="text-white text-center mt-4">æ‚¨çš„å¡”ç½—ç‰Œå·²ç»æ­ç¤ºï¼Œè®©æˆ‘ä»¬æ¥è§£è¯»å‘½è¿çš„å¯ç¤º...</p>
          
          <!-- LLMåŠ è½½çŠ¶æ€æ˜¾ç¤º -->
          <div v-if="llmLoading" class="mt-8 mb-8">
            <div class="bg-gradient-to-r from-purple-600/20 to-indigo-600/20 rounded-2xl p-6 border border-purple-400/30">
              <div class="flex items-center justify-center mb-4">
                <div class="w-8 h-8 border-4 border-purple-400 border-t-transparent rounded-full animate-spin mr-3"></div>
                <h3 class="text-xl font-bold text-white">æ­£åœ¨ç”Ÿæˆä¸“ä¸šè§£è¯»...</h3>
              </div>
              <div class="text-center">
                <p class="text-purple-200 mb-2">{{ llmLoadingMessage }}</p>
                <div class="w-full bg-purple-900/30 rounded-full h-2">
                  <div class="bg-gradient-to-r from-purple-500 to-pink-500 h-2 rounded-full transition-all duration-500" 
                       :class="{
                         'w-1/4': llmLoadingStage === 'preparing',
                         'w-2/4': llmLoadingStage === 'calling', 
                         'w-3/4': llmLoadingStage === 'processing',
                         'w-full': llmLoadingStage === 'completed'
                       }"></div>
                </div>
                <p class="text-purple-300 text-sm mt-2">è¯·è€å¿ƒç­‰å¾…ï¼ŒAIæ­£åœ¨ä¸ºæ‚¨é‡èº«å®šåˆ¶æ·±åº¦è§£è¯»</p>
              </div>
            </div>
          </div>
          
          <!-- é—®é¢˜å›é¡¾ -->
          <div class="mt-6 text-center">
            <div class="inline-block bg-gradient-to-r from-purple-600/30 to-pink-600/30 backdrop-blur-sm rounded-2xl px-6 py-3 border border-purple-400/30">
              <span class="text-purple-200 text-sm">æ‚¨çš„é—®é¢˜ï¼š</span>
              <span class="text-white font-medium ml-2">{{ userQuestion }}</span>
            </div>
          </div>
          
          <!-- æ˜¾ç¤ºæŠ½åˆ°çš„ç‰Œ -->
          <div class="mt-8" v-if="interpretationResult">
            <h2 class="text-2xl font-bold text-white text-center mb-6">æ‚¨æŠ½åˆ°çš„ç‰Œ</h2>
            
            <!-- æ ¹æ®ç‰Œé˜µç±»å‹è°ƒæ•´å¸ƒå±€ -->
            <div v-if="selectedSpread?.name === 'Love Pyramid Spread'" class="relative max-w-4xl mx-auto">
              <!-- æ‹äººé‡‘å­—å¡”ç‰¹æ®Šå¸ƒå±€ -->
              <div class="flex flex-col items-center space-y-6">
                <!-- ç¬¬ä¸€å±‚ï¼šä½ çš„å†…å¿ƒ -->
                <div class="flex justify-center">
                  <div class="card-container" v-if="interpretationResult.cards[0]">
                    <!-- ç‰Œä½æ ‡é¢˜ - ç§»åˆ°å¡ç‰Œä¸Šæ–¹ -->
                    <div class="position-title-header mb-3 text-center">
                      <div class="inline-block bg-gradient-to-r from-purple-600/80 to-indigo-600/80 backdrop-blur-sm rounded-full px-4 py-2 border border-purple-400/40">
                        <span class="text-white font-bold text-sm">{{ interpretationResult.cards[0].position }}</span>
                      </div>
                    </div>
                    
                    <div class="tarot-card-container relative" :class="[
                      interpretationResult.cards[0].category === 'major' ? 'major-arcana' : 'minor-arcana',
                      `element-${interpretationResult.cards[0].element}`
                    ]">
                      <!-- å¡ç‰Œå›¾ç‰‡å®¹å™¨ - ç§»é™¤ä½ç½®è¦†ç›–å±‚ -->
                      <div class="card-image-container mb-4 relative">
                        <img 
                          :src="interpretationResult.cards[0].imageUrl" 
                          :alt="interpretationResult.cards[0].name" 
                          class="tarot-card-image w-full h-48 object-cover rounded-lg"
                          @error="handleImageError"
                        />
                        <!-- å…ƒç´ æ ‡è®° -->
                        <div class="element-badge" :class="`element-${interpretationResult.cards[0].element}`">
                          {{ getElementSymbol(interpretationResult.cards[0].element) }}
                        </div>
                      </div>
                      
                      <!-- å¡ç‰ŒåŸºæœ¬ä¿¡æ¯ -->
                      <div class="card-info text-center">
                        <div class="text-purple-200 mb-2 font-semibold">{{ interpretationResult.cards[0].name }}</div>
                        <div class="text-sm text-purple-300 mb-3">{{ interpretationResult.cards[0].englishName }}</div>
                        <div class="text-xs text-purple-200 mb-2">
                          å…³é”®è¯: {{ getDisplayKeywords(interpretationResult.cards[0].keywords) }}
                        </div>
                        <!-- å¡ç‰Œè§£è¯»æ‚¬åœæ˜¾ç¤º -->
                        <div class="text-xs text-purple-300 cursor-help hover:text-purple-100 transition-colors duration-200" 
                             @mouseenter="showCardTooltip($event, interpretationResult.cards[0])"
                             @mouseleave="hideCardTooltip">
                          ğŸ“– å¡ç‰Œè§£è¯»
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                
                <!-- ç¬¬äºŒå±‚ï¼šå¯¹æ–¹å†…å¿ƒ + å…³ç³»åŸºç¡€ -->
                <div class="flex justify-center space-x-8">
                  <div class="card-container" v-if="interpretationResult.cards[1]">
                    <!-- ç‰Œä½æ ‡é¢˜ - ç§»åˆ°å¡ç‰Œä¸Šæ–¹ -->
                    <div class="position-title-header mb-3 text-center">
                      <div class="inline-block bg-gradient-to-r from-purple-600/80 to-indigo-600/80 backdrop-blur-sm rounded-full px-4 py-2 border border-purple-400/40">
                        <span class="text-white font-bold text-sm">{{ interpretationResult.cards[1].position }}</span>
                      </div>
                    </div>
                    
                    <div class="tarot-card-container relative" :class="[
                      interpretationResult.cards[1].category === 'major' ? 'major-arcana' : 'minor-arcana',
                      `element-${interpretationResult.cards[1].element}`
                    ]">
                      <div class="card-image-container mb-4 relative">
                        <img 
                          :src="interpretationResult.cards[1].imageUrl" 
                          :alt="interpretationResult.cards[1].name" 
                          class="tarot-card-image w-full h-48 object-cover rounded-lg"
                          @error="handleImageError"
                        />
                        <div class="element-badge" :class="`element-${interpretationResult.cards[1].element}`">
                          {{ getElementSymbol(interpretationResult.cards[1].element) }}
                        </div>
                      </div>
                      <div class="card-info text-center">
                        <div class="text-purple-200 mb-2 font-semibold">{{ interpretationResult.cards[1].name }}</div>
                        <div class="text-sm text-purple-300 mb-3">{{ interpretationResult.cards[1].englishName }}</div>
                        <div class="text-xs text-purple-200 mb-2">
                          å…³é”®è¯: {{ getDisplayKeywords(interpretationResult.cards[1].keywords) }}
                        </div>
                        <!-- å¡ç‰Œè§£è¯»æ‚¬åœæ˜¾ç¤º -->
                        <div class="text-xs text-purple-300 cursor-help hover:text-purple-100 transition-colors duration-200" 
                             @mouseenter="showCardTooltip($event, interpretationResult.cards[1])"
                             @mouseleave="hideCardTooltip">
                          ğŸ“– å¡ç‰Œè§£è¯»
                        </div>
                      </div>
                    </div>
                  </div>
                  
                  <div class="card-container" v-if="interpretationResult.cards[2]">
                    <!-- ç‰Œä½æ ‡é¢˜ - ç§»åˆ°å¡ç‰Œä¸Šæ–¹ -->
                    <div class="position-title-header mb-3 text-center">
                      <div class="inline-block bg-gradient-to-r from-purple-600/80 to-indigo-600/80 backdrop-blur-sm rounded-full px-4 py-2 border border-purple-400/40">
                        <span class="text-white font-bold text-sm">{{ interpretationResult.cards[2].position }}</span>
                      </div>
                    </div>
                    
                    <div class="tarot-card-container relative" :class="[
                      interpretationResult.cards[2].category === 'major' ? 'major-arcana' : 'minor-arcana',
                      `element-${interpretationResult.cards[2].element}`
                    ]">
                      <div class="card-image-container mb-4 relative">
                        <img 
                          :src="interpretationResult.cards[2].imageUrl" 
                          :alt="interpretationResult.cards[2].name" 
                          class="tarot-card-image w-full h-48 object-cover rounded-lg"
                          @error="handleImageError"
                        />
                        <div class="element-badge" :class="`element-${interpretationResult.cards[2].element}`">
                          {{ getElementSymbol(interpretationResult.cards[2].element) }}
                        </div>
                      </div>
                      <div class="card-info text-center">
                        <div class="text-purple-200 mb-2 font-semibold">{{ interpretationResult.cards[2].name }}</div>
                        <div class="text-sm text-purple-300 mb-3">{{ interpretationResult.cards[2].englishName }}</div>
                        <div class="text-xs text-purple-200 mb-2">
                          å…³é”®è¯: {{ getDisplayKeywords(interpretationResult.cards[2].keywords) }}
                        </div>
                        <!-- å¡ç‰Œè§£è¯»æ‚¬åœæ˜¾ç¤º -->
                        <div class="text-xs text-purple-300 cursor-help hover:text-purple-100 transition-colors duration-200" 
                             @mouseenter="showCardTooltip($event, interpretationResult.cards[2])"
                             @mouseleave="hideCardTooltip">
                          ğŸ“– å¡ç‰Œè§£è¯»
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                
                <!-- ç¬¬ä¸‰å±‚ï¼šå…³ç³»æœªæ¥ -->
                <div class="flex justify-center">
                  <div class="card-container" v-if="interpretationResult.cards[3]">
                    <!-- ç‰Œä½æ ‡é¢˜ - ç§»åˆ°å¡ç‰Œä¸Šæ–¹ -->
                    <div class="position-title-header mb-3 text-center">
                      <div class="inline-block bg-gradient-to-r from-purple-600/80 to-indigo-600/80 backdrop-blur-sm rounded-full px-4 py-2 border border-purple-400/40">
                        <span class="text-white font-bold text-sm">{{ interpretationResult.cards[3].position }}</span>
                      </div>
                    </div>
                    
                    <div class="tarot-card-container relative" :class="[
                      interpretationResult.cards[3].category === 'major' ? 'major-arcana' : 'minor-arcana',
                      `element-${interpretationResult.cards[3].element}`
                    ]">
                      <div class="card-image-container mb-4 relative">
                        <img 
                          :src="interpretationResult.cards[3].imageUrl" 
                          :alt="interpretationResult.cards[3].name" 
                          class="tarot-card-image w-full h-48 object-cover rounded-lg"
                          @error="handleImageError"
                        />
                        <div class="element-badge" :class="`element-${interpretationResult.cards[3].element}`">
                          {{ getElementSymbol(interpretationResult.cards[3].element) }}
                        </div>
                      </div>
                      <div class="card-info text-center">
                        <div class="text-purple-200 mb-2 font-semibold">{{ interpretationResult.cards[3].name }}</div>
                        <div class="text-sm text-purple-300 mb-3">{{ interpretationResult.cards[3].englishName }}</div>
                        <div class="text-xs text-purple-200 mb-2">
                          å…³é”®è¯: {{ getDisplayKeywords(interpretationResult.cards[3].keywords) }}
                        </div>
                        <!-- å¡ç‰Œè§£è¯»æ‚¬åœæ˜¾ç¤º -->
                        <div class="text-xs text-purple-300 cursor-help hover:text-purple-100 transition-colors duration-200" 
                             @mouseenter="showCardTooltip($event, interpretationResult.cards[3])"
                             @mouseleave="hideCardTooltip">
                          ğŸ“– å¡ç‰Œè§£è¯»
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- å…¶ä»–ç‰Œé˜µçš„ä¼˜åŒ–å¸ƒå±€ -->
            <div v-else class="grid gap-6" :class="getCardLayoutClass(interpretationResult.cards.length)">
              <div 
                v-for="(card, index) in interpretationResult.cards" 
                :key="index"
                class="text-center"
              >
                <!-- ç‰Œä½æ ‡é¢˜ - ç§»åˆ°å¡ç‰Œä¸Šæ–¹ -->
                <div class="position-title-header mb-3 text-center">
                  <div class="inline-block bg-gradient-to-r from-purple-600/80 to-indigo-600/80 backdrop-blur-sm rounded-full px-4 py-2 border border-purple-400/40">
                    <span class="text-white font-bold text-sm">{{ card.position }}</span>
                  </div>
                </div>
                
                <div class="tarot-card-container relative" :class="[
                  card.category === 'major' ? 'major-arcana' : 'minor-arcana',
                  `element-${card.element}`
                ]">
                  <!-- å¡ç‰Œå›¾ç‰‡å®¹å™¨ - ç§»é™¤ä½ç½®è¦†ç›–å±‚ -->
                  <div class="card-image-container mb-4 relative">
                    <img 
                      :src="card.imageUrl" 
                      :alt="card.name" 
                      :class="getCardImageClass(interpretationResult.cards.length)"
                      @error="handleImageError"
                    />
                    <!-- å…ƒç´ æ ‡è®° -->
                    <div class="element-badge" :class="`element-${card.element}`">
                      {{ getElementSymbol(card.element) }}
                    </div>
                  </div>
                  
                  <!-- å¡ç‰ŒåŸºæœ¬ä¿¡æ¯ -->
                  <div class="card-info text-center">
                    <div class="text-purple-200 mb-2 font-semibold">{{ card.name }}</div>
                    <div class="text-sm text-purple-300 mb-3">{{ card.englishName }}</div>
                    <div class="text-xs text-purple-200 mb-2">
                      å…³é”®è¯: {{ getDisplayKeywords(card.keywords) }}
                    </div>
                    <!-- å¡ç‰Œè§£è¯»æ‚¬åœæ˜¾ç¤º -->
                    <div class="text-xs text-purple-300 cursor-help hover:text-purple-100 transition-colors duration-200" 
                         @mouseenter="showCardTooltip($event, card)"
                         @mouseleave="hideCardTooltip">
                      ğŸ“– å¡ç‰Œè§£è¯»
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <!-- å¡ç‰Œè¯¦ç»†ä¿¡æ¯æ‚¬åœæç¤ºæ¡† -->
          <div 
            v-if="tooltipVisible" 
            ref="cardTooltip"
            class="card-tooltip"
            :style="tooltipStyle"
          >
            <div class="tooltip-content">
              <h4 class="font-bold text-white mb-2">{{ tooltipCard?.name }}</h4>
              <p class="text-sm text-purple-200 mb-3 leading-relaxed">{{ tooltipCard?.meaning || 'è¿™å¼ ç‰Œè•´å«ç€æ·±åˆ»çš„æ™ºæ…§ä¸æŒ‡å¼•' }}</p>
              <div class="text-xs text-purple-300">
                å…³é”®è¯: {{ tooltipCard?.keywords || 'ç¥ç§˜, æ™ºæ…§, æŒ‡å¼•' }}
              </div>
            </div>
          </div>
          
          <!-- æ•´ä½“è§£è¯» -->
          <div class="mt-12" v-if="interpretationResult">
            <div class="bg-gradient-to-br from-indigo-900/40 to-purple-900/40 backdrop-blur-sm rounded-2xl p-6 border border-indigo-400/30 shadow-xl space-y-8">
              
              <!-- Overall Interpretation -->
              <div v-if="interpretationResult.overallInterpretation" class="bg-black/20 rounded-xl p-5 border border-purple-400/20">
                <h3 class="text-2xl font-bold text-white mb-4 text-center">ğŸ”® {{ interpretationResult.overallInterpretation.title }}</h3>
                <p class="text-lg text-gray-200 leading-relaxed whitespace-pre-wrap">{{ interpretationResult.overallInterpretation.content }}</p>
              </div>

              <!-- Card by Card Interpretation -->
              <div v-if="interpretationResult.cardInterpretations && interpretationResult.cardInterpretations.length > 0">
                <h4 class="text-xl font-bold text-white mb-4 text-center">ğŸƒ å•ç‰Œè§£è¯»</h4>
                <div class="space-y-4">
                  <div v-for="(card, index) in interpretationResult.cardInterpretations" :key="index" class="bg-black/20 rounded-xl p-4 border border-purple-400/20">
                    <h5 class="font-bold text-purple-300">{{ card.position }}: {{ card.cardName }}</h5>
                    <p class="text-gray-300 leading-relaxed whitespace-pre-wrap">{{ card.interpretation }}</p>
                  </div>
                </div>
              </div>

              <!-- Guidance -->
              <div v-if="interpretationResult.guidance" class="bg-black/20 rounded-xl p-5 border border-purple-400/20">
                <h4 class="text-xl font-bold text-white mb-4 text-center">ğŸ’¡ {{ interpretationResult.guidance.title }}</h4>
                <p class="text-lg text-gray-200 leading-relaxed whitespace-pre-wrap">{{ interpretationResult.guidance.content }}</p>
              </div>

              <!-- Summary -->
              <div v-if="interpretationResult.summary" class="bg-black/20 rounded-xl p-5 border border-purple-400/20">
                <h4 class="text-xl font-bold text-white mb-4 text-center">âœ¨ {{ interpretationResult.summary.title }}</h4>
                <p class="text-lg text-gray-200 leading-relaxed whitespace-pre-wrap">{{ interpretationResult.summary.content }}</p>
              </div>

            </div>
          </div>

          <!-- å»ºè®®æŒ‡å¯¼ -->
          <div class="mt-8" v-if="interpretationResult">
            <div class="bg-gradient-to-br from-purple-900/40 to-pink-900/40 backdrop-blur-sm rounded-2xl p-6 border border-purple-400/30 shadow-xl">
              <h3 class="text-2xl font-bold text-white mb-6 text-center">ğŸ’¡ å»ºè®®æŒ‡å¯¼</h3>
              <div class="bg-black/20 rounded-xl p-5 border border-purple-400/20">
                <p class="interpretation-text">{{ interpretationResult.guidance.content }}</p>
              </div>
            </div>
          </div>

          <!-- å åœæ€»ç»“ -->
          <div class="mt-8" v-if="interpretationResult">
            <div class="bg-gradient-to-br from-indigo-900/50 to-purple-900/50 backdrop-blur-sm rounded-2xl p-6 border border-indigo-400/40 shadow-xl">
              <h3 class="text-2xl font-bold text-white mb-6 text-center">ğŸ“‹ å åœæ€»ç»“</h3>
              <div class="bg-black/30 rounded-xl p-5 border border-purple-400/30">
                <p class="interpretation-text">{{ interpretationResult.summary.content }}</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, nextTick, onUnmounted } from 'vue';
import { storyTarotDeck, type StoryTarotCard } from '../utils/storyTarotData';
import { classicSpreads, type TarotSpread } from '../utils/tarotInterpretation';
import { LLMService } from '../../../services/LLMService';

// åœ¨ç»„ä»¶é¡¶éƒ¨é¢„å…ˆå¯¼å…¥LLMServiceï¼Œé¿å…åŠ¨æ€å¯¼å…¥çš„å»¶è¿Ÿé—®é¢˜

// è§£è¯»ç»“æœç±»å‹å®šä¹‰
interface TarotInterpretationResult {
  cards: Array<{
    name: string;
    englishName: string;
    position: string;
    meaning: string;
    keywords: string;
    imageUrl: string;
    category: string;
    element: string;
  }>;
  overallInterpretation: {
    title: string;
    content: string;
  };
  cardInterpretations: Array<{
    position: string;
    cardName: string;
    interpretation: string;
  }>;
  guidance: {
    title: string;
    content: string;
  };
  summary: {
    title: string;
    content: string;
  };
}

// é˜¶æ®µç®¡ç†
type Stage = 'intro' | 'spreadSelection' | 'shuffling' | 'drawing' | 'reveal';
const currentStage = ref<Stage>('intro');

// ç‰Œé˜µç›¸å…³
const selectedSpread = ref<TarotSpread | null>(null);

// åŸºç¡€æ•°æ®
const userQuestion = ref('');
const positions = ref<string[]>(['è¿‡å»', 'ç°åœ¨', 'æœªæ¥']);
const drawnCards = ref<StoryTarotCard[]>([]);
const revealedCards = ref<boolean[]>([false, false, false]);

// å¼¹å¹•ç›¸å…³
const barrageArea = ref<HTMLElement | null>(null);
const questionInput = ref<HTMLTextAreaElement | null>(null);

// å®šä¹‰å¼¹å¹•é¡¹ç±»å‹
interface BarrageItem {
  el: HTMLDivElement;
  text: string;
  likes: number;
  row: number;
  x: number;
  y: number;
  width: number;
  speed: number;
  paused: boolean;
}

const barrageItems = ref<BarrageItem[]>([]);
let animationFrame: number | null = null;

// é«˜é¢‘é—®é¢˜æ•°æ®
const suggestions = ref([
  { text: 'æˆ‘çš„äº‹ä¸šå‘å±•å¦‚ä½•ï¼Ÿ', likes: 2 },
  { text: 'æˆ‘çš„æ„Ÿæƒ…è¿åŠ¿æ€æ ·ï¼Ÿ', likes: 5 },
  { text: 'è¿‘æœŸè´¢è¿å¦‚ä½•ï¼Ÿ', likes: 1 },
  { text: 'æˆ‘è¯¥å¦‚ä½•é¢å¯¹å½“å‰çš„å›°å¢ƒï¼Ÿ', likes: 3 },
  { text: 'æœªæ¥ä¸‰ä¸ªæœˆä¼šæœ‰ä»€ä¹ˆæ–°æœºä¼šï¼Ÿ', likes: 0 },
  { text: 'æˆ‘ä¸æŸæŸçš„å…³ç³»ä¼šå¦‚ä½•å‘å±•ï¼Ÿ', likes: 1 },
  { text: 'éœ€è¦æ³¨æ„å“ªäº›å¥åº·é—®é¢˜ï¼Ÿ', likes: 0 },
  { text: 'ç›®å‰çš„é€‰æ‹©æ˜¯å¦æ­£ç¡®ï¼Ÿ', likes: 0 },
  { text: 'æˆ‘çš„å­¦ä¸šè¿åŠ¿å¦‚ä½•ï¼Ÿ', likes: 2 },
  { text: 'ä»€ä¹ˆæ—¶å€™ä¼šé‡åˆ°çœŸçˆ±ï¼Ÿ', likes: 4 },
  { text: 'æˆ‘é€‚åˆæ¢å·¥ä½œå—ï¼Ÿ', likes: 1 },
  { text: 'å®¶åº­å…³ç³»å¦‚ä½•æ”¹å–„ï¼Ÿ', likes: 0 },
  { text: 'æŠ•èµ„ç†è´¢è¦æ³¨æ„ä»€ä¹ˆï¼Ÿ', likes: 1 },
  { text: 'æˆ‘çš„äººé™…å…³ç³»æ€æ ·ï¼Ÿ', likes: 0 },
  { text: 'å¦‚ä½•æå‡ä¸ªäººè¿åŠ¿ï¼Ÿ', likes: 2 },
  { text: 'ä»Šå¹´ä¼šæœ‰ä»€ä¹ˆé‡å¤§å˜åŒ–ï¼Ÿ', likes: 1 }
]);

// å¼¹å¹•é…ç½® - ä¼˜åŒ–é€Ÿåº¦åŸºå‡†
const BARRAGE_ROWS = 4; // å¼¹å¹•è¡Œæ•°
const BARRAGE_HEIGHT = 120; // å¼¹å¹•åŒºåŸŸæ€»é«˜åº¦
const ROW_HEIGHT = 30; // æ¯è¡Œé«˜åº¦
const SPEED_MIN = 40; // æœ€å°é€Ÿåº¦ (px/s)
const SPEED_MAX = 65; // æœ€å¤§é€Ÿåº¦ (px/s)

// éŸ³æ•ˆæ§åˆ¶
const soundEnabled = ref(true);

// LLMåŠ è½½çŠ¶æ€
const llmLoading = ref(false);
const llmLoadingMessage = ref('');
const llmLoadingStage = ref<'preparing' | 'calling' | 'processing' | 'completed' | 'error'>('preparing');

// è§£è¯»ç»“æœ
const interpretationResult = ref<TarotInterpretationResult | null>(null);

// æ–¹æ³•å®šä¹‰
function goToSpreadSelection() {
  currentStage.value = 'spreadSelection';
}

function goBackToIntro() {
  currentStage.value = 'intro';
}

function selectSpread(spread: TarotSpread) {
  selectedSpread.value = spread;
  positions.value = spread.positions.map(p => p.chineseName);
  revealedCards.value = new Array(spread.positions.length).fill(false);
}

function getSpreadIcon(spreadName: string): string {
  const icons: Record<string, string> = {
    'Three Card Spread': 'ğŸ”®',
    'Celtic Cross': 'âœ¨',
    'Love Pyramid Spread': 'ğŸ’•',
    'Career Path Spread': 'ğŸŒŸ',
    'Decision Making Spread': 'âš–ï¸',
    'Past Present Future': 'ğŸ•°ï¸',
    'Relationship Spread': 'ğŸ’–'
  };
  return icons[spreadName] || 'ğŸ´';
}

// å¼¹å¹•ç›¸å…³æ–¹æ³•
function initBarrage() {
  if (!barrageArea.value) return;
  
  // å¯åŠ¨å¼¹å¹•åŠ¨ç”»
  startBarrageAnimation();
  
  // å®šæœŸæ·»åŠ æ–°å¼¹å¹• - æ›´é¢‘ç¹çš„ç”Ÿæˆ
  setInterval(() => {
    if (barrageItems.value.length < 12) { // é™åˆ¶åŒæ—¶æ˜¾ç¤ºçš„å¼¹å¹•æ•°é‡
      addBarrageItem();
    }
  }, 1500); // 1.ç§’é—´éš”
}

function startBarrageAnimation() {
  let lastTime = performance.now();
  
  function animate(currentTime: number) {
    const deltaTime = currentTime - lastTime;
    lastTime = currentTime;
    
    // ä½¿ç”¨å€’åºéå†é¿å…æ•°ç»„ç´¢å¼•æ··ä¹±
    for (let i = barrageItems.value.length - 1; i >= 0; i--) {
      const item = barrageItems.value[i];
      
      if (!item.paused) {
        // åŸºäºæ—¶é—´çš„ç§»åŠ¨è®¡ç®—
        item.x -= (item.speed * deltaTime) / 1000;
        
        // å¦‚æœå¼¹å¹•å®Œå…¨ç§»å‡ºå±å¹•ï¼Œç§»é™¤å®ƒ
        if (item.x + item.width < 0) {
          item.el.remove();
          barrageItems.value.splice(i, 1);
          continue;
        }
        
        // æ›´æ–°ä½ç½® - ä½¿ç”¨transformç¡®ä¿å¹³æ»‘ç§»åŠ¨
        item.el.style.transform = `translateX(${item.x}px)`;
      }
    }
    
    animationFrame = requestAnimationFrame(animate);
  }
  
  animate(lastTime);
}

function addBarrageItem() {
  if (!barrageArea.value) return;
  
  const suggestion = suggestions.value[Math.floor(Math.random() * suggestions.value.length)];
  const row = Math.floor(Math.random() * BARRAGE_ROWS); // éšæœºé€‰æ‹©è¡Œ
  
  const el = document.createElement('div');
  el.className = 'barrage-item absolute whitespace-nowrap cursor-pointer transition-all duration-200 hover:scale-105 select-none flex items-center gap-3';
  
  // é¢„è®¾æ ·å¼ï¼Œé¿å…é—ªç°
  const containerWidth = barrageArea.value.offsetWidth;
  const initialX = containerWidth + 20;
  
  el.style.cssText = `
    top: ${row * ROW_HEIGHT}px;
    font-size: 16px;
    line-height: ${ROW_HEIGHT}px;
    height: ${ROW_HEIGHT - 4}px;
    color: rgba(196, 181, 253, 0.95);
    text-shadow: 0 0 6px rgba(147, 51, 234, 0.6);
    z-index: 10;
    padding: 6px 12px;
    background: rgba(0, 0, 0, 0.25);
    border-radius: 20px;
    border: 1px solid rgba(147, 51, 234, 0.4);
    backdrop-filter: blur(4px);
    will-change: transform;
    transform: translateX(${initialX}px);
  `;
  
  // åˆ›å»ºé—®é¢˜æ–‡æœ¬
  const textSpan = document.createElement('span');
  textSpan.textContent = suggestion.text;
  textSpan.className = 'barrage-text flex-1';
  
  // åˆ›å»ºTwitteré£æ ¼çš„ç‚¹èµæŒ‰é’®
  const likeButton = document.createElement('button');
  likeButton.className = 'like-button flex items-center gap-1 px-2 py-1 rounded-full transition-all duration-200 hover:bg-red-500/20 hover:scale-110';
  likeButton.innerHTML = `
    <svg class="w-4 h-4 transition-all duration-200 ${suggestion.likes > 0 ? 'text-red-500' : 'text-gray-400'}" 
         fill="${suggestion.likes > 0 ? 'currentColor' : 'none'}" 
         stroke="currentColor" 
         viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
            d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>
    </svg>
    <span class="text-xs font-medium ${suggestion.likes > 0 ? 'text-red-500' : 'text-gray-400'}">${suggestion.likes}</span>
  `;
  
  el.appendChild(textSpan);
  el.appendChild(likeButton);
  
  // æ·»åŠ åˆ°DOMåè·å–å®½åº¦
  barrageArea.value.appendChild(el);
  const width = el.offsetWidth;
  
  const item: BarrageItem = {
    el,
    text: suggestion.text,
    likes: suggestion.likes,
    row,
    x: initialX,
    y: row * ROW_HEIGHT,
    width,
    speed: SPEED_MIN + Math.random() * (SPEED_MAX - SPEED_MIN),
    paused: false
  };
  
  // æ·»åŠ äº‹ä»¶ç›‘å¬
  let pausedX = 0;
  el.addEventListener('mouseenter', () => {
    item.paused = true;
    pausedX = item.x; // ä¿å­˜æš‚åœæ—¶çš„ä½ç½®
    el.style.backgroundColor = 'rgba(147, 51, 234, 0.5)';
    el.style.transform = `translateX(${pausedX}px) scale(1.05)`;
    el.style.boxShadow = '0 4px 20px rgba(147, 51, 234, 0.4)';
  });
  
  el.addEventListener('mouseleave', () => {
    item.paused = false;
    el.style.backgroundColor = 'rgba(0, 0, 0, 0.25)';
    el.style.transform = `translateX(${pausedX}px) scale(1)`;
    el.style.boxShadow = 'none';
  });
  
  // ç‚¹å‡»æ–‡æœ¬å¡«å……åˆ°è¾“å…¥æ¡†
  textSpan.addEventListener('click', (e) => {
    e.stopPropagation();
    userQuestion.value = item.text;
    if (questionInput.value) {
      questionInput.value.focus();
    }
    
    // ç§»é™¤å¼¹å¹•
    item.el.remove();
    const itemIndex = barrageItems.value.indexOf(item);
    if (itemIndex !== -1) {
      barrageItems.value.splice(itemIndex, 1);
    }
  });
  
  // ç‚¹å‡»ç‚¹èµæŒ‰é’®
  likeButton.addEventListener('click', (e) => {
    e.stopPropagation();
    
    // å¢åŠ ç‚¹èµæ•°
    const suggestionIndex = suggestions.value.findIndex(s => s.text === item.text);
    if (suggestionIndex !== -1) {
      suggestions.value[suggestionIndex].likes++;
      item.likes = suggestions.value[suggestionIndex].likes;
      
      // æ›´æ–°æ˜¾ç¤º - Twitteré£æ ¼åŠ¨ç”»
      const likeCount = likeButton.querySelector('span');
      const heartIcon = likeButton.querySelector('svg');
      if (likeCount && heartIcon) {
        likeCount.textContent = item.likes.toString();
        likeCount.className = 'text-xs font-medium text-red-500';
        
        heartIcon.setAttribute('fill', 'currentColor');
        heartIcon.setAttribute('class', 'w-4 h-4 transition-all duration-200 text-red-500');
        
        // Twitteré£æ ¼çš„ç‚¹èµåŠ¨ç”»
        likeButton.style.transform = 'scale(1.3)';
        heartIcon.style.transform = 'scale(1.2)';
        
        setTimeout(() => {
          likeButton.style.transform = 'scale(1)';
          heartIcon.style.transform = 'scale(1)';
        }, 200);
        
        // æ·»åŠ å°å¿ƒå¿ƒé£å‡ºæ•ˆæœ
        const flyHeart = document.createElement('div');
        flyHeart.innerHTML = 'â¤ï¸';
        flyHeart.style.cssText = `
          position: absolute;
          font-size: 12px;
          pointer-events: none;
          animation: fly-heart 1s ease-out forwards;
          left: 50%;
          top: 50%;
          transform: translate(-50%, -50%);
        `;
        likeButton.appendChild(flyHeart);
        
        setTimeout(() => {
          flyHeart.remove();
        }, 1000);
      }
    }
  });
  
  // æ·»åŠ åˆ°å¼¹å¹•åˆ—è¡¨
  barrageItems.value.push(item);
}

async function startReading() {
  if (!selectedSpread.value) {
    selectedSpread.value = classicSpreads[0];
    positions.value = selectedSpread.value.positions.map(p => p.chineseName);
    revealedCards.value = new Array(selectedSpread.value.positions.length).fill(false);
  }
  
  currentStage.value = 'shuffling';
  
  if (soundEnabled.value) {
    playSound('shuffle');
  }

  await new Promise(resolve => setTimeout(resolve, 3000));
  
  currentStage.value = 'drawing';
}

async function drawCard(deckIndex: number) {
  const maxCards = selectedSpread.value?.positions.length || 3;
  if (drawnCards.value.length >= maxCards) return;

  if (soundEnabled.value) {
    playSound('draw');
  }

  const availableCards = storyTarotDeck.filter((card: StoryTarotCard) => 
    !drawnCards.value.some((drawn: StoryTarotCard) => drawn.id === card.id)
  );
  const randomCard = availableCards[Math.floor(Math.random() * availableCards.length)];
  
  drawnCards.value.push(randomCard);
}

async function revealCards() {
  if (!userQuestion.value.trim()) {
    alert('è¯·å…ˆè¾“å…¥ä½ æƒ³è¦å’¨è¯¢çš„é—®é¢˜');
    return;
  }
  
  if (!selectedSpread.value) {
    alert('è¯·é€‰æ‹©ä¸€ä¸ªç‰Œé˜µ');
    return;
  }
  
  currentStage.value = 'reveal';
  
  if (soundEnabled.value) {
    playSound('reveal');
  }

  try {
    // ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - ç°åœ¨æ˜¯å¼‚æ­¥çš„
    interpretationResult.value = await generateInterpretation(drawnCards.value, selectedSpread.value, userQuestion.value);
  } catch (error) {
    console.error('ç”Ÿæˆå¡”ç½—è§£è¯»å¤±è´¥:', error);
    alert('ç”Ÿæˆè§£è¯»æ—¶å‡ºç°é”™è¯¯ï¼Œè¯·é‡è¯•');
  }
}

function toggleSound() {
  soundEnabled.value = !soundEnabled.value;
}

function playSound(type: string) {
  console.log(`æ’­æ”¾éŸ³æ•ˆ: ${type}`);
}

// ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯» - å¼‚æ­¥ç‰ˆæœ¬ï¼Œé›†æˆLLM API
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<TarotInterpretationResult> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // å†æ¬¡ç¡®ä¿é…ç½®æ˜¯æœ€æ–°çš„
    loadLLMConfig();
    
    // éªŒè¯å½“å‰é…ç½®
    const currentConfig = LLMService.getConfig();
    console.log('ğŸ” éªŒè¯å½“å‰LLMServiceé…ç½®:', {
      provider: currentConfig.provider,
      hasApiKey: !!currentConfig.apiKey,
      baseURL: currentConfig.baseURL,
      model: currentConfig.model
    });
    
    // è°ƒç”¨LLMæœåŠ¡è·å–è§£è¯»
    const llmResult = await LLMService.getTarotInterpretation(cards, spread, question);
    
    // æ„å»ºå¡ç‰Œä¿¡æ¯æ•°ç»„ç”¨äºæ˜¾ç¤º
    const cardInfos = cards.map((card, index) => {
      const position = spread.positions[index];
      const keywords = Array.isArray(card.keywords) ? card.keywords.join(', ') : card.keywords;
      const llmCardInterpretation = llmResult.cardInterpretations.find(
        (ci: any) => ci.cardName === card.name || ci.cardName === card.chineseName
      );
      
      return {
        name: card.chineseName,
        englishName: card.name,
        position: position.chineseName,
        meaning: llmCardInterpretation?.interpretation || getBasicCardMeaning(card, position),
        keywords,
        imageUrl: card.imageUrl,
        category: card.category,
        element: card.element
      };
    });

    console.log('âœ… LLMè§£è¯»ç”ŸæˆæˆåŠŸ');
    
    return {
      cards: cardInfos,
      overallInterpretation: llmResult.overallInterpretation,
      cardInterpretations: llmResult.cardInterpretations.map((ci: any) => ({
        position: ci.position,
        cardName: ci.cardName,
        interpretation: ci.interpretation
      })),
      guidance: llmResult.guidance,
      summary: llmResult.summary
    };
  } catch (error) {
    console.error('âŒ LLMè§£è¯»å¤±è´¥ï¼Œä½¿ç”¨æœ¬åœ°å¤‡ç”¨è§£è¯»:', error);
    
    // å¦‚æœLLMè°ƒç”¨å¤±è´¥ï¼Œä½¿ç”¨æœ¬åœ°è§£è¯»ä½œä¸ºå¤‡ç”¨
    const cardInfos = cards.map((card, index) => {
      const position = spread.positions[index];
      const keywords = Array.isArray(card.keywords) ? card.keywords.join(', ') : card.keywords;
      const baseMeaning = getBasicCardMeaning(card, position);
      
      return {
        name: card.chineseName,
        englishName: card.name,
        position: position.chineseName,
        meaning: baseMeaning,
        keywords,
        imageUrl: card.imageUrl,
        category: card.category,
        element: card.element
      };
    });

    // ä½¿ç”¨æœ¬åœ°è§£è¯»ç”Ÿæˆå®Œæ•´ç»“æœ
    const overallInterpretation = generateOverallInterpretation(cardInfos, spread, question);
    const cardInterpretations = generateCardInterpretations(cardInfos, spread, question);
    const guidance = generateGuidance(cardInfos, question);
    const summary = generateSummary(cardInfos, spread);
    
    return {
      cards: cardInfos,
      overallInterpretation,
      cardInterpretations,
      guidance,
      summary
    };
  }
}

// è·å–åŸºç¡€å¡ç‰Œå«ä¹‰
function getBasicCardMeaning(card: StoryTarotCard, position: any): string {
  const baseMeaning = card.storyInterpretation || 'è¿™å¼ ç‰Œè•´å«ç€æ·±åˆ»çš„æ™ºæ…§';
  if (card.category === 'major') {
    return `åœ¨"${position.chineseName}"çš„ä½ç½®ä¸Šï¼Œ${card.chineseName}å‘Šè¯‰æˆ‘ä»¬ï¼š${baseMeaning} ${position.meaning}`;
  } else {
    const suitName = getSuitChineseName(card.suit || '');
    return `åœ¨"${position.chineseName}"çš„ä½ç½®ä¸Šï¼Œ${card.chineseName}å¸¦æ¥${suitName}çš„èƒ½é‡ã€‚${baseMeaning} ${position.meaning}`;
  }
}

// è·å–èŠ±è‰²ä¸­æ–‡å
function getSuitChineseName(suit: string): string {
  const suitMap: Record<string, string> = {
    'wands': 'ç«å…ƒç´ æƒæ–',
    'cups': 'æ°´å…ƒç´ åœ£æ¯',
    'swords': 'é£å…ƒç´ å®å‰‘',
    'pentacles': 'åœŸå…ƒç´ æ˜Ÿå¸'
  };
  return suitMap[suit.toLowerCase()] || 'ç¥ç§˜';
}

// ç”Ÿæˆå»ºè®®æŒ‡å¯¼
function generateAdvice(cards: any[], question: string): string {
  const advice = [
    "ä¿æŒå†…å¿ƒçš„å¹³é™ä¸ä¸“æ³¨ï¼Œå€¾å¬ç›´è§‰çš„å£°éŸ³ã€‚",
    "å‹‡æ•¢é¢å¯¹æŒ‘æˆ˜ï¼Œç›¸ä¿¡è‡ªå·±çš„èƒ½åŠ›å’Œæ™ºæ…§ã€‚",
    "æ³¨æ„å¹³è¡¡ç”Ÿæ´»çš„å„ä¸ªæ–¹é¢ï¼Œé¿å…è¿‡åº¦åé‡æŸä¸€é¢†åŸŸã€‚",
    "ä¸ä»–äººçœŸè¯šäº¤æµï¼Œå¯»æ±‚æ”¯æŒå’Œç†è§£ã€‚",
    "å…³æ³¨å½“ä¸‹çš„æœºä¼šï¼Œé€‚æ—¶é‡‡å–è¡ŒåŠ¨ã€‚",
    "å­¦ä¼šé‡Šæ”¾è¿‡å»çš„åŒ…è¢±ï¼Œæ‹¥æŠ±æœªæ¥çš„å¯èƒ½ã€‚",
    "åŸ¹å…»è€å¿ƒï¼Œæœ‰äº›äº‹æƒ…éœ€è¦æ—¶é—´æ¥å‘å±•ã€‚",
    "ç›¸ä¿¡ç›´è§‰ï¼Œå®ƒå¾€å¾€èƒ½æŒ‡å¼•æ­£ç¡®çš„æ–¹å‘ã€‚"
  ];
  
  // æ ¹æ®å¡ç‰Œç‰¹å¾é€‰æ‹©åˆé€‚çš„å»ºè®®
  const majorCards = cards.filter(card => card.category === 'major');
  if (majorCards.length > 0) {
    return "å¤§é˜¿å°”å¡çº³çš„å‡ºç°è¡¨æ˜è¿™æ˜¯äººç”Ÿçš„é‡è¦æ—¶åˆ»ã€‚" + advice[Math.floor(Math.random() * advice.length)];
  }
  
  return advice[Math.floor(Math.random() * advice.length)];
}

// ç”Ÿæˆæ€»ç»“
function generateSummary(cards: any[], spread: TarotSpread): { title: string; content: string } {
  const cardCount = cards.length;
  const majorCount = cards.filter(card => card.category === 'major').length;
  
  let summary = `é€šè¿‡${spread.chineseName}çš„æŒ‡å¼•ï¼Œ${cardCount}å¼ ç‰Œä¸ºæ‚¨çš„é—®é¢˜æ­ç¤ºäº†é‡è¦çš„æ´å¯Ÿã€‚`;
  
  if (majorCount > 0) {
    summary += `å…¶ä¸­${majorCount}å¼ å¤§é˜¿å°”å¡çº³ç‰Œçš„å‡ºç°ï¼Œè¡¨æ˜è¿™ä¸ªé—®é¢˜æ¶‰åŠäººç”Ÿçš„é‡è¦è¯¾é¢˜ã€‚`;
  }
  
  summary += "ç›¸ä¿¡å¡”ç½—ç‰Œçš„æ™ºæ…§ï¼Œå®ƒå°†å¸®åŠ©æ‚¨åœ¨äººç”Ÿçš„é“è·¯ä¸Šåšå‡ºæ›´æ˜æ™ºçš„é€‰æ‹©ã€‚";
  
  return {
    title: 'å åœæ€»ç»“',
    content: summary
  };
}

// é‡æ–°å¼€å§‹å åœ
function resetReading() {
  currentStage.value = 'intro';
  selectedSpread.value = null;
  userQuestion.value = '';
  drawnCards.value = [];
  revealedCards.value = [false, false, false];
  interpretationResult.value = null;
  positions.value = ['è¿‡å»', 'ç°åœ¨', 'æœªæ¥'];
}

// å¤„ç†å›¾ç‰‡åŠ è½½é”™è¯¯
function handleImageError(event: Event) {
  const img = event.target as HTMLImageElement;
  img.src = '/static/tarot/- 00_fool_jpg (æ„šè€…).png'; // ä½¿ç”¨æ„šè€…ç‰Œä½œä¸ºé»˜è®¤å›¾ç‰‡
}

// è·å–å…ƒç´ ç¬¦å·
function getElementSymbol(element: string): string {
  const symbols: Record<string, string> = {
    fire: 'ğŸ”¥',
    water: 'ğŸ’§',
    air: 'ğŸ’¨',
    earth: 'ğŸŒ'
  };
  return symbols[element] || 'âœ¨';
}

// å¡ç‰Œè¯¦ç»†ä¿¡æ¯æ‚¬åœæç¤ºæ¡†
const tooltipVisible = ref(false);
const tooltipCard = ref<{ name: string; meaning: string; keywords: string } | null>(null);
const tooltipStyle = ref<{ left: string; top: string }>({ left: '0px', top: '0px' });

 function showCardTooltip(event: MouseEvent, card: any) {
   tooltipVisible.value = true;
   // æ„å»ºå®Œæ•´çš„æç¤ºæ¡†æ•°æ®
   tooltipCard.value = {
     name: card.name || card.chineseName,
     meaning: card.meaning || card.interpretation || 'è¿™å¼ ç‰Œè•´å«ç€æ·±åˆ»çš„æ™ºæ…§ä¸æŒ‡å¼•',
     keywords: card.keywords || 'ç¥ç§˜, æ™ºæ…§, æŒ‡å¼•'
   };
   const target = event.target as HTMLElement;
   if (target) {
     const rect = target.getBoundingClientRect();
     
     // ä¼˜åŒ–å®šä½é€»è¾‘ï¼Œç¡®ä¿æç¤ºæ¡†åœ¨è§†å£å†…
     const viewportWidth = window.innerWidth;
     const viewportHeight = window.innerHeight;
     const tooltipWidth = 280; // é¢„ä¼°æç¤ºæ¡†å®½åº¦
     const tooltipHeight = 120; // é¢„ä¼°æç¤ºæ¡†é«˜åº¦
     
     let left = rect.left + rect.width / 2 - tooltipWidth / 2;
     let top = rect.top - tooltipHeight - 10;
     
     // æ°´å¹³è¾¹ç•Œæ£€æŸ¥
     if (left < 10) left = 10;
     if (left + tooltipWidth > viewportWidth - 10) left = viewportWidth - tooltipWidth - 10;
     
     // å‚ç›´è¾¹ç•Œæ£€æŸ¥ï¼Œå¦‚æœä¸Šæ–¹ç©ºé—´ä¸è¶³ï¼Œæ˜¾ç¤ºåœ¨ä¸‹æ–¹
     if (top < 10) {
       top = rect.bottom + 10;
     }
     
     tooltipStyle.value = {
       left: `${left}px`,
       top: `${top}px`
     };
   }
 }

function hideCardTooltip() {
  tooltipVisible.value = false;
  tooltipCard.value = null;
  tooltipStyle.value = { left: '0px', top: '0px' };
}

function getDisplayKeywords(keywords: string | string[]): string {
  if (Array.isArray(keywords)) {
    return keywords.join(', ');
  } else if (typeof keywords === 'string') {
    return keywords;
  } else {
    return '';
  }
}

// è·å–å¡ç‰Œå¸ƒå±€ç±»
function getCardLayoutClass(cardCount: number): string {
  switch (cardCount) {
    case 1:
      return 'grid-cols-1';
    case 2:
      return 'grid-cols-1 md:grid-cols-2';
    case 3:
      return 'grid-cols-1 md:grid-cols-3';
    case 4:
      return 'grid-cols-1 md:grid-cols-2 lg:grid-cols-4';
    case 5:
      return 'grid-cols-1 md:grid-cols-2 lg:grid-cols-3';
    default:
      return 'grid-cols-1 md:grid-cols-2 lg:grid-cols-3';
  }
}

// è·å–å¡ç‰Œå›¾ç‰‡å°ºå¯¸ç±»
function getCardImageClass(cardCount: number): string {
  const baseClass = 'tarot-card-image w-full object-cover rounded-lg';
  switch (cardCount) {
    case 1:
    case 2:
    case 3:
      return `${baseClass} h-48`;
    case 4:
      return `${baseClass} h-40 lg:h-36`;
    case 5:
    case 6:
      return `${baseClass} h-36`;
    default:
      return `${baseClass} h-32`;
  }
}

// ç»„ä»¶æŒ‚è½½æ—¶é¢„åŠ è½½LLMé…ç½®
onMounted(() => {
  // é¢„åŠ è½½LLMé…ç½®
  loadLLMConfig();
  
  // åˆå§‹åŒ–å¼¹å¹•
  nextTick(() => {
    initBarrage();
  });
});

// é¢„åŠ è½½LLMé…ç½®å‡½æ•°
function loadLLMConfig() {
  try {
    const saved = localStorage.getItem('llm-config');
    if (saved) {
      const config = JSON.parse(saved);
      console.log('ğŸš€ é¢„åŠ è½½LLMé…ç½®:', {
        provider: config.provider,
        hasApiKey: !!config.apiKey,
        baseURL: config.baseURL
      });
      LLMService.setConfig(config);
    } else {
      console.log('ğŸ“ æœªæ‰¾åˆ°LLMé…ç½®ï¼Œå°†ä½¿ç”¨é»˜è®¤æœ¬åœ°è§£è¯»');
    }
  } catch (error) {
    console.error('âŒ é¢„åŠ è½½LLMé…ç½®å¤±è´¥:', error);
  }
}
async function generateInterpretation(cards: StoryTarotCard[], spread: TarotSpread, question: string): Promise<TarotInterpretationResult> {
  try {
    console.log('ğŸ¯ å¼€å§‹ç”Ÿæˆå¡”ç½—ç‰Œè§£è¯»...', { cardCount: cards.length, spreadName: spread.name, question });
    
    // å†æ¬¡ç¡®ä¿é…ç½®æ˜¯æœ€æ–°çš„
    loadLLMConfig();
    
    // éªŒè¯å½“å‰é…ç½®
    const currentConfig = LLMService.getConfig();
    console.log('ğŸ” éªŒè¯å½“å‰LLMServiceé…ç½®:', {
      provider: currentConfig.provider,
      hasApiKey: !!currentConfig.apiKey,
      baseURL: currentConfig.baseURL,
      model: currentConfig.model
    });
    
    // è°ƒç”¨LLMæœåŠ¡è·å–è§£è¯»
    const llmResult = await LLMService.getTarotInterpretation(cards, spread, question);
    
    // æ„å»ºå¡ç‰Œä¿¡æ¯æ•°ç»„ç”¨äºæ˜¾ç¤º
    const cardInfos = cards.map((card, index) => {
      const position = spread.positions[index];
      const keywords = Array.isArray(card.keywords) ? card.keywords.join(', ') : card.keywords;
      const llmCardInterpretation = llmResult.cardInterpretations.find(
        (ci: any) => ci.cardName === card.name || ci.cardName === card.chineseName
      );
      
      return {
        name: card.chineseName,
        englishName: card.name,
        position: position.chineseName,
        meaning: llmCardInterpretation?.interpretation || getBasicCardMeaning(card, position),
        keywords,
        imageUrl: card.imageUrl,
        category: card.category,
        element: card.element
      };
    });

    console.log('âœ… LLMè§£è¯»ç”ŸæˆæˆåŠŸ');
    
    return {
      cards: cardInfos,
      overallInterpretation: llmResult.overallInterpretation,
      cardInterpretations: llmResult.cardInterpretations.map((ci: any) => ({
        position: ci.position,
        cardName: ci.cardName,
        interpretation: ci.interpretation
      })),
      guidance: llmResult.guidance,
      summary: llmResult.summary
    };
  } catch (error) {
    console.error('âŒ LLMè§£è¯»å¤±è´¥ï¼Œä½¿ç”¨æœ¬åœ°å¤‡ç”¨è§£è¯»:', error);
    
    // å¦‚æœLLMè°ƒç”¨å¤±è´¥ï¼Œä½¿ç”¨æœ¬åœ°è§£è¯»ä½œä¸ºå¤‡ç”¨
    const cardInfos = cards.map((card, index) => {
      const position = spread.positions[index];
      const keywords = Array.isArray(card.keywords) ? card.keywords.join(', ') : card.keywords;
      const baseMeaning = getBasicCardMeaning(card, position);
      
      return {
        name: card.chineseName,
        englishName: card.name,
        position: position.chineseName,
        meaning: baseMeaning,
        keywords,
        imageUrl: card.imageUrl,
        category: card.category,
        element: card.element
      };
    });

    // ä½¿ç”¨æœ¬åœ°è§£è¯»ç”Ÿæˆå®Œæ•´ç»“æœ
    const overallInterpretation = generateOverallInterpretation(cardInfos, spread, question);
    const cardInterpretations = generateCardInterpretations(cardInfos, spread, question);
    const guidance = generateGuidance(cardInfos, question);
    const summary = generateSummary(cardInfos, spread);
    
    return {
      cards: cardInfos,
      overallInterpretation,
      cardInterpretations,
      guidance,
      summary
    };
  }
}

// ç”Ÿæˆæ•´ä½“è§£è¯»
function generateOverallInterpretation(cards: any[], spread: TarotSpread, question: string): { title: string; content: string } {
  const cardCount = cards.length;
  let reading = '';
  
  // åŸºäºç‰Œé˜µç±»å‹ç”Ÿæˆè§£è¯»
  switch (spread.chineseName) {
    case 'ä¸‰å¼ ç‰Œå åœæ³•':
      reading = `é€šè¿‡ä¸‰å¼ ç‰Œçš„æ—¶é—´çº¿å¸ƒå±€ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†ä½ çš„å®Œæ•´æ•…äº‹è„‰ç»œã€‚è¿‡å»çš„ç»å†å¦‚ä½•å¡‘é€ ç°åœ¨ï¼Œç°åœ¨çš„é€‰æ‹©åˆå°†å¦‚ä½•å½±å“æœªæ¥ã€‚è¿™ä¸‰å¼ ç‰Œå…±åŒç¼–ç»‡å‡ºä¸€ä¸ªå…³äº"${question}"çš„å®Œæ•´ç­”æ¡ˆã€‚`;
      break;
    case 'æ‹äººé‡‘å­—å¡”':
      reading = `æ‹äººé‡‘å­—å¡”ä¸ºä½ æ­ç¤ºäº†æ„Ÿæƒ…çš„å…¨è²Œï¼šä»å…³ç³»çš„æ ¹åŸºåˆ°åŒæ–¹çš„å†…å¿ƒä¸–ç•Œï¼Œå†åˆ°æœªæ¥çš„å‘å±•æ–¹å‘ã€‚è¿™å››å¼ ç‰Œä¸ºä½ çš„æ„Ÿæƒ…é—®é¢˜"${question}"æä¾›äº†å…¨æ–¹ä½çš„æ´å¯Ÿã€‚`;
      break;
    case 'äºŒé€‰ä¸€ç‰Œé˜µ':
      reading = `é¢å¯¹é€‰æ‹©çš„åå­—è·¯å£ï¼Œäº”å¼ ç‰Œä¸ºä½ ç…§äº®äº†å‰è¿›çš„é“è·¯ã€‚ä»å½“å‰çŠ¶å†µåˆ°ä¸¤ä¸ªé€‰æ‹©çš„å¯¹æ¯”ï¼Œå†åˆ°éšè—çš„å½±å“å› ç´ å’Œæœ€ä½³è·¯å¾„ï¼Œè¿™ä¸ªç‰Œé˜µä¸º"${question}"æä¾›äº†å…¨é¢çš„æŒ‡å¯¼ã€‚`;
      break;
    case 'è´¢å¯Œä¹‹æ ‘':
      reading = `è´¢å¯Œä¹‹æ ‘ä¸ºä½ å±•ç°äº†é‡‘é’±èƒ½é‡çš„å®Œæ•´æµåŠ¨ã€‚ä»æ ¹åŸºåˆ°æˆé•¿ï¼Œä»éšœç¢åˆ°æœºé‡ï¼Œæœ€ç»ˆåˆ°æ”¶è·ï¼Œè¿™äº”å¼ ç‰Œæ­ç¤ºäº†å…³äº"${question}"çš„è´¢å¯Œå¯†ç ã€‚`;
      break;
    case 'å…­èŠ’æ˜Ÿç‰Œé˜µ':
      reading = `å…­èŠ’æ˜Ÿçš„ç¥åœ£å‡ ä½•ä¸ºä½ æ‰“å¼€äº†å¤šç»´åº¦çš„è§†è§’ã€‚ä»æ„è¯†åˆ°æ½œæ„è¯†ï¼Œä»è¿‡å»åˆ°æœªæ¥ï¼Œä»å†…åœ¨åˆ°å¤–åœ¨ï¼Œè¿™ä¸ƒå¼ ç‰Œä¸º"${question}"æä¾›äº†æ·±å±‚æ¬¡çš„å…¨æ–¹ä½è§£è¯»ã€‚`;
      break;
    case 'å‡¯å°”ç‰¹ç‰Œé˜µ':
      reading = `å¤è€çš„å‡¯å°”ç‰¹åå­—ä¸ºä½ å±•å¼€äº†å‘½è¿çš„å…¨æ™¯å›¾ã€‚åå¼ ç‰Œä»æ ¸å¿ƒé—®é¢˜å‡ºå‘ï¼Œå±‚å±‚å‰–æå½±å“å› ç´ ï¼Œæœ€ç»ˆæŒ‡å‘ç»“æœã€‚è¿™æ˜¯å¯¹"${question}"æœ€æ·±å…¥ã€æœ€å…¨é¢çš„æ¢ç´¢ã€‚`;
      break;
    default:
      reading = `è¿™${cardCount}å¼ ç‰Œçš„ç»„åˆä¸ºä½ çš„é—®é¢˜"${question}"æä¾›äº†å¤šç»´åº¦çš„è§£ç­”ã€‚æ¯å¼ ç‰Œéƒ½åœ¨å…¶ç‰¹å®šçš„ä½ç½®ä¸Šå‘æŒ¥ç€ç‹¬ç‰¹çš„ä½œç”¨ï¼Œå…±åŒæ„æˆäº†ä¸€ä¸ªå®Œæ•´çš„æŒ‡å¯¼ä½“ç³»ã€‚`;
  }
  
  // åˆ†æç‰Œé¢çš„æ•´ä½“èƒ½é‡
  const majorCount = cards.filter(card => card.category === 'major').length;
  const minorCount = cards.filter(card => card.category === 'minor').length;
  
  if (majorCount > minorCount) {
    reading += ` å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œå¤§é˜¿å°”å¡çº³ç‰Œå ä¸»å¯¼åœ°ä½ï¼Œè¿™è¡¨æ˜å®‡å®™çš„é‡å¤§åŠ›é‡æ­£åœ¨å½±å“è¿™ä¸ªæƒ…å†µï¼Œè¿™æ˜¯ä¸€ä¸ªå…·æœ‰æ·±è¿œæ„ä¹‰çš„è½¬æŠ˜ç‚¹ã€‚`;
  } else if (minorCount > majorCount) {
    reading += ` å°é˜¿å°”å¡çº³ç‰Œçš„ä¸»å¯¼åœ°ä½è¡¨æ˜ï¼Œè¿™ä¸ªæƒ…å†µæ›´å¤šåœ°ä¸æ—¥å¸¸ç”Ÿæ´»çš„å…·ä½“ç»†èŠ‚å’Œå®é™…è¡ŒåŠ¨ç›¸å…³ã€‚`;
  } else {
    reading += ` å¤§å°é˜¿å°”å¡çº³çš„å¹³è¡¡åˆ†å¸ƒæ˜¾ç¤ºäº†ç²¾ç¥å±‚é¢å’Œç‰©è´¨å±‚é¢çš„å’Œè°ç»Ÿä¸€ã€‚`;
  }
  
  return {
    title: 'æ•´ä½“è§£è¯»',
    content: reading
  };
}

// ç”Ÿæˆå•ç‰Œè§£è¯»
function generateCardInterpretations(cards: any[], spread: TarotSpread, question: string): { position: string; cardName: string; interpretation: string }[] {
  return cards.map((card, index) => {
    const position = spread.positions[index];
    
    return {
      position: position.chineseName,
      cardName: card.name,
      interpretation: card.meaning
    };
  });
}

// ç”Ÿæˆå»ºè®®æŒ‡å¯¼
function generateGuidance(cards: any[], question: string): { title: string; content: string } {
  const advice = generateAdvice(cards, question);
  
  return {
    title: 'å»ºè®®æŒ‡å¯¼',
    content: advice
  };
}

// ç»„ä»¶å¸è½½æ—¶æ¸…ç†
onUnmounted(() => {
  if (animationFrame) {
    cancelAnimationFrame(animationFrame);
  }
});

// è·å–ç‰Œé˜µæ´å¯Ÿ
function getSpreadInsight() {
  return `é€šè¿‡${selectedSpread.value?.chineseName}ï¼Œå¡”ç½—ç‰Œä¸ºæ‚¨çš„é—®é¢˜æä¾›äº†æ·±å…¥çš„æ´å¯Ÿã€‚`;
}

// è·å–èƒ½é‡åˆ†æ
function getEnergyAnalysis() {
  const cards = drawnCards.value;
  const majorCount = cards.filter(card => card.category === 'major').length;
  const minorCount = cards.filter(card => card.category === 'minor').length;
  
  if (majorCount > minorCount) {
    return `å¤§é˜¿å°”å¡çº³ç‰Œå ä¸»å¯¼åœ°ä½ï¼Œè¿™è¡¨æ˜å®‡å®™çš„é‡å¤§åŠ›é‡æ­£åœ¨å½±å“è¿™ä¸ªæƒ…å†µï¼Œè¿™æ˜¯ä¸€ä¸ªå…·æœ‰æ·±è¿œæ„ä¹‰çš„è½¬æŠ˜ç‚¹ã€‚`;
  } else if (minorCount > majorCount) {
    return `å°é˜¿å°”å¡çº³ç‰Œçš„ä¸»å¯¼åœ°ä½è¡¨æ˜ï¼Œè¿™ä¸ªæƒ…å†µæ›´å¤šåœ°ä¸æ—¥å¸¸ç”Ÿæ´»çš„å…·ä½“ç»†èŠ‚å’Œå®é™…è¡ŒåŠ¨ç›¸å…³ã€‚`;
  } else {
    return `å¤§å°é˜¿å°”å¡çº³çš„å¹³è¡¡åˆ†å¸ƒæ˜¾ç¤ºäº†ç²¾ç¥å±‚é¢å’Œç‰©è´¨å±‚é¢çš„å’Œè°ç»Ÿä¸€ã€‚`;
  }
}

// è·å–æ ¸å¿ƒä¿¡æ¯
function getCoreMessage() {
  if (!interpretationResult.value) return '';
  const question = userQuestion.value;
  const spreadName = selectedSpread.value?.chineseName || '';
  
  if (question.includes('æ„Ÿæƒ…') || question.includes('çˆ±æƒ…')) {
    return `æœ¬æ¬¡å åœçš„æ ¸å¿ƒä¸»é¢˜æ˜¯æ„Ÿæƒ…å…³ç³»çš„æ¢ç´¢ä¸å‘å±•ã€‚é€šè¿‡${spreadName}ï¼Œå¡”ç½—ç‰Œä¸ºæ‚¨æ­ç¤ºäº†æ„Ÿæƒ…é“è·¯ä¸Šçš„å…³é”®ä¿¡æ¯ã€‚`;
  } else if (question.includes('äº‹ä¸š') || question.includes('å·¥ä½œ')) {
    return `æœ¬æ¬¡å åœçš„æ ¸å¿ƒä¸»é¢˜æ˜¯äº‹ä¸šå‘å±•ä¸èŒä¸šè§„åˆ’ã€‚${spreadName}ä¸ºæ‚¨æŒ‡æ˜äº†èŒä¸šé“è·¯ä¸Šçš„æœºé‡ä¸æŒ‘æˆ˜ã€‚`;
  } else if (question.includes('è´¢è¿') || question.includes('é‡‘é’±')) {
    return `æœ¬æ¬¡å åœçš„æ ¸å¿ƒä¸»é¢˜æ˜¯è´¢å¯Œç§¯ç´¯ä¸ç†è´¢è§„åˆ’ã€‚é€šè¿‡${spreadName}ï¼Œæ‚¨å°†äº†è§£è´¢è¿çš„å˜åŒ–è¶‹åŠ¿ã€‚`;
  }
  return `æœ¬æ¬¡å åœå›´ç»•æ‚¨çš„äººç”Ÿé—®é¢˜å±•å¼€ï¼Œ${spreadName}ä¸ºæ‚¨æä¾›äº†å…¨é¢çš„æŒ‡å¯¼ä¸å¯ç¤ºã€‚`;
}

// è·å–å…³é”®å¡ç‰Œ
function getKeyCards() {
  if (!drawnCards.value.length) return [];
  
  return drawnCards.value.slice(0, 2).map((card, index) => ({
    name: card.chineseName,
    position: selectedSpread.value?.positions[index]?.chineseName || '',
    significance: card.category === 'major' 
      ? 'å¤§é˜¿å°”å¡çº³ç‰Œï¼Œä»£è¡¨é‡è¦çš„äººç”Ÿè½¬æŠ˜å’Œæ·±å±‚å½±å“'
      : 'å°é˜¿å°”å¡çº³ç‰Œï¼Œæç¤ºå…·ä½“çš„è¡ŒåŠ¨æ–¹å‘å’Œæ—¥å¸¸å½±å“'
  }));
}

// è·å–æ—¶é—´æ¡†æ¶
function getTimeframe() {
  const majorCount = drawnCards.value.filter(card => card.category === 'major').length;
  
  if (majorCount >= 2) {
    return '3-6ä¸ªæœˆå†…å°†çœ‹åˆ°é‡è¦å˜åŒ–ï¼Œè¿™æ˜¯ä¸€ä¸ªå…³é”®çš„è½¬æŠ˜æœŸ';
  } else {
    return '1-3ä¸ªæœˆå†…ä¼šæœ‰æ˜æ˜¾è¿›å±•ï¼Œå»ºè®®ä¿æŒè€å¿ƒå’ŒæŒç»­åŠªåŠ›';
  }
}

// è·å–ä¸‹ä¸€æ­¥è¡ŒåŠ¨
function getNextSteps() {
  const question = userQuestion.value;
  
  if (question.includes('æ„Ÿæƒ…')) {
    return 'ä¸»åŠ¨æ²Ÿé€šï¼Œè¡¨è¾¾çœŸå®æƒ³æ³•ï¼Œåˆ›é€ æ›´å¤šç›¸å¤„æœºä¼š';
  } else if (question.includes('äº‹ä¸š')) {
    return 'åˆ¶å®šæ˜ç¡®ç›®æ ‡ï¼Œæå‡ä¸“ä¸šæŠ€èƒ½ï¼Œç§¯æå¯»æ‰¾å‘å±•æœºä¼š';
  } else if (question.includes('è´¢è¿')) {
    return 'åˆ¶å®šç†è´¢è®¡åˆ’ï¼Œæ§åˆ¶æ”¯å‡ºï¼Œå¯»æ‰¾å¢æ”¶æ¸ é“';
  }
  return 'ä¿æŒç§¯æå¿ƒæ€ï¼Œåˆ¶å®šå…·ä½“è®¡åˆ’ï¼Œå¾ªåºæ¸è¿›åœ°å®ç°ç›®æ ‡';
}

// è·å–æœ€ç»ˆå¯ç¤º
function getFinalRevelation() {
  const cardNames = drawnCards.value.map(card => card.chineseName).join('ã€');
  return `${cardNames}å…±åŒä¼ è¾¾çš„ä¿¡æ¯æ˜¯ï¼šå‘½è¿æŒæ¡åœ¨æ‚¨è‡ªå·±æ‰‹ä¸­ã€‚å¡”ç½—ç‰Œåªæ˜¯æ™ºæ…§çš„æŒ‡å¼•ï¼Œæœ€ç»ˆçš„é€‰æ‹©å’Œè¡ŒåŠ¨éƒ½éœ€è¦æ‚¨è‡ªå·±å»å®Œæˆã€‚ç›¸ä¿¡å†…å¿ƒçš„å£°éŸ³ï¼Œå‹‡æ•¢åœ°èµ°å‘å±äºæ‚¨çš„æœªæ¥ã€‚`;
}
</script>

<style scoped>
.mystical-glow {
  text-shadow: 0 0 20px rgba(147, 51, 234, 0.8);
}

.stars-background {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
  pointer-events: none;
}

.stars {
  position: absolute;
  font-size: 1rem;
  animation: twinkle 3s ease-in-out infinite;
}

@keyframes twinkle {
  0%, 100% { opacity: 0.3; transform: scale(1); }
  50% { opacity: 1; transform: scale(1.2); }
}

.loading-dots {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 8px;
}

.loading-dots span {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: linear-gradient(45deg, #8b5cf6, #ec4899);
  animation: loading 1.4s ease-in-out infinite both;
}

.loading-dots span:nth-child(1) { animation-delay: -0.32s; }
.loading-dots span:nth-child(2) { animation-delay: -0.16s; }

@keyframes loading {
  0%, 80%, 100% { transform: scale(0); }
  40% { transform: scale(1); }
}

.animate-flip-in {
  animation: flipIn 0.6s ease-out;
}

@keyframes flipIn {
  from {
    transform: perspective(400px) rotateY(90deg);
    opacity: 0;
  }
  to {
    transform: perspective(400px) rotateY(0deg);
    opacity: 1;
  }
}

.spread-card.selected {
  transform: scale(1.05) translateY(-5px) !important;
  filter: brightness(1.2);
  box-shadow: 0 15px 40px rgba(147, 51, 234, 0.6);
}

.spread-card.selected > div {
  border-color: #8b5cf6;
  background: linear-gradient(135deg, rgba(139, 92, 246, 0.3), rgba(99, 102, 241, 0.3));
}

/* å¼¹å¹•æ ·å¼ */
.barrage-area {
  position: relative;
  overflow: hidden;
  height: 120px; /* åŒ¹é…BARRAGE_HEIGHT */
}

.barrage-item {
  font-weight: 500;
  text-shadow: 0 0 4px rgba(147, 51, 234, 0.5);
  user-select: none;
  backdrop-filter: blur(8px);
  transition: background-color 0.3s ease, box-shadow 0.3s ease, transform 0.2s ease;
  will-change: transform;
}

.barrage-item:hover {
  color: rgba(255, 255, 255, 0.95) !important;
  text-shadow: 0 0 8px rgba(147, 51, 234, 0.8);
  backdrop-filter: blur(12px);
}

/* Twitteré£æ ¼ç‚¹èµæŒ‰é’®æ ·å¼ */
.like-button {
  position: relative;
  overflow: hidden;
}

.like-button:hover svg {
  transform: scale(1.1);
}

.like-button:active {
  transform: scale(0.95);
}

/* ç‚¹èµé£å¿ƒåŠ¨ç”» */
@keyframes fly-heart {
  0% {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
  }
  50% {
    opacity: 0.8;
    transform: translate(-50%, -80px) scale(1.2);
  }
  100% {
    opacity: 0;
    transform: translate(-50%, -120px) scale(0.8);
  }
}

/* å¼¹å¹•æ–‡æœ¬æ ·å¼ */
.barrage-item .barrage-text {
  max-width: 300px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/* å¼¹å¹•æ‚¬åœæ•ˆæœå¢å¼º */
.barrage-item:hover {
  z-index: 20 !important;
  box-shadow: 0 8px 32px rgba(147, 51, 234, 0.4);
}

/* ç‚¹èµæŒ‰é’®æ¸å˜æ•ˆæœ */
.like-button:hover {
  background: linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(220, 38, 127, 0.2));
}

/* å¼¹å¹•åŒºåŸŸèƒŒæ™¯ä¼˜åŒ– */
.barrage-area::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(90deg, 
    rgba(147, 51, 234, 0.05) 0%, 
    rgba(147, 51, 234, 0.02) 50%, 
    rgba(147, 51, 234, 0.05) 100%);
  pointer-events: none;
}

/* æ‹äººé‡‘å­—å¡”å¸ƒå±€æ ·å¼ */
.love-pyramid-layout {
  position: relative;
}

.love-pyramid-layout::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 2px;
  height: 100px;
  background: linear-gradient(to bottom, rgba(147, 51, 234, 0.3), transparent);
  transform: translateX(-50%);
  z-index: 0;
}

.pyramid-top,
.pyramid-bottom {
  position: relative;
  z-index: 1;
}

/* é‡‘å­—å¡”è¿æ¥çº¿æ•ˆæœ */
.love-pyramid-layout .pyramid-top::after {
  content: '';
  position: absolute;
  bottom: -40px;
  left: 50%;
  width: 200px;
  height: 1px;
  background: linear-gradient(to right, transparent, rgba(147, 51, 234, 0.3), transparent);
  transform: translateX(-50%);
}

.love-pyramid-layout .pyramid-bottom::before {
  content: '';
  position: absolute;
  top: -40px;
  left: 50%;
  width: 300px;
  height: 1px;
  background: linear-gradient(to right, transparent, rgba(147, 51, 234, 0.3), transparent);
  transform: translateX(-50%);
}

/* å¡”ç½—ç‰Œæ ·å¼ */
.tarot-card-container {
  background: linear-gradient(135deg, rgba(139, 92, 246, 0.3), rgba(99, 102, 241, 0.3));
  backdrop-filter: blur(8px);
  border-radius: 16px;
  padding: 16px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
  position: relative;
  border: 2px solid;
  transition: all 0.3s ease;
}

.tarot-card-container.major-arcana {
  background: linear-gradient(135deg, rgba(245, 158, 11, 0.3), rgba(251, 191, 36, 0.3));
  border-color: #f59e0b;
  box-shadow: 0 0 20px rgba(245, 158, 11, 0.3);
}

.tarot-card-container.minor-arcana {
  background: linear-gradient(135deg, rgba(139, 92, 246, 0.3), rgba(99, 102, 241, 0.3));
  border-color: #8b5cf6;
  box-shadow: 0 0 20px rgba(139, 92, 246, 0.3);
}

.card-image-container {
  position: relative;
  overflow: hidden;
  border-radius: 8px;
}

.tarot-card-image {
  transition: transform 0.3s ease;
}

.tarot-card-image:hover {
  transform: scale(1.05);
}

.element-badge {
  position: absolute;
  top: 8px;
  right: 8px;
  width: 32px;
  height: 32px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  font-weight: bold;
  backdrop-filter: blur(8px);
}

.element-badge.element-fire {
  background: rgba(239, 68, 68, 0.8);
  color: white;
}

.element-badge.element-water {
  background: rgba(59, 130, 246, 0.8);
  color: white;
}

.element-badge.element-air {
  background: rgba(245, 158, 11, 0.8);
  color: white;
}

.element-badge.element-earth {
  background: rgba(34, 197, 94, 0.8);
  color: white;
}

 .card-info {
   text-align: center;
 }

 /* å¡ç‰Œè¯¦ç»†ä¿¡æ¯æ‚¬åœæç¤ºæ¡†æ ·å¼ */
 .card-tooltip {
   position: fixed;
   background: linear-gradient(135deg, rgba(139, 92, 246, 0.95), rgba(99, 102, 241, 0.95));
   backdrop-filter: blur(12px);
   border: 1px solid rgba(139, 92, 246, 0.3);
   border-radius: 12px;
   padding: 16px;
   max-width: 300px;
   z-index: 1000;
   box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
   pointer-events: none;
 }
 
 .tooltip-content h4 {
   color: white;
   font-size: 16px;
   font-weight: bold;
   margin-bottom: 8px;
 }
 
 .tooltip-content p {
   color: rgba(255, 255, 255, 0.9);
   font-size: 14px;
   line-height: 1.4;
   margin-bottom: 8px;
   word-wrap: break-word;
   overflow-wrap: break-word;
 }
 
 .tooltip-content div {
   color: rgba(255, 255, 255, 0.7);
   font-size: 12px;
 }
.interpretation-text {
  color: #e9d5ff; /* purple-100 */
  line-height: 1.75; /* leading-relaxed */
  font-size: 1rem; /* text-base */
  white-space: pre-wrap; /* ä¿æŒLLMè¾“å‡ºçš„æ¢è¡Œ */
  word-wrap: break-word;
  overflow-wrap: break-word;
}
</style> 