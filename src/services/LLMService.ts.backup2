import type { Hexagram } from '../features/dilemma/types';
import type { StoryTarotCard } from '../features/tarot/utils/storyTarotData';
import type { TarotSpread } from '../features/tarot/utils/tarotInterpretation';
import { EnvConfigManager } from '../utils/envConfig';

export type TarotIntent = 
  | 'Prediction' 
  | 'Advice' 
  | 'Diagnosis' 
  | 'Relationship' 
  | 'Decision' 
  | 'Self-Exploration';

export interface InterpretationSection {
    title: string;
    content: string;
  icon: string;
}

export type StructuredTarotInterpretation = InterpretationSection[];

export interface LLMConfig {
  provider: 'openai' | 'claude' | 'deepseek' | 'qianwen' | 'custom';
  apiKey: string;
  baseURL?: string;
  model?: string;
  temperature?: number;
  maxTokens?: number;
}

export interface LLMResponse {
  content: string;
  usage?: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
}

export interface LLMLoadingState {
  isLoading: boolean;
  progress: string;
  stage: 'preparing' | 'calling' | 'processing' | 'completed' | 'error';
}

const DEFAULT_CONFIG: LLMConfig = {
  provider: 'deepseek',
  apiKey: EnvConfigManager.getEnvVar('VITE_LLM_API_KEY', ''),
  baseURL: EnvConfigManager.getEnvVar('VITE_LLM_BASE_URL', ''),
  model: 'deepseek-chat',
  temperature: 0.7,
  maxTokens: 4000
};

console.log('ğŸ”§ LLM Service åˆå§‹åŒ–é…ç½®:', {
  provider: DEFAULT_CONFIG.provider,
  hasApiKey: !!DEFAULT_CONFIG.apiKey,
  baseURL: DEFAULT_CONFIG.baseURL || 'ä½¿ç”¨é»˜è®¤',
  model: DEFAULT_CONFIG.model
});

export class LLMService {
  private static config: LLMConfig = DEFAULT_CONFIG;
  private static loadingCallbacks: ((state: LLMLoadingState) => void)[] = [];
  
  static setConfig(config: Partial<LLMConfig>) {
    this.config = { ...this.config, ...config };
    console.log('ğŸ”§ LLMé…ç½®å·²æ›´æ–°:', {
      provider: this.config.provider,
      hasApiKey: !!this.config.apiKey,
      model: this.config.model
    });
  }
  
  static getConfig(): LLMConfig {
    return { ...this.config };
  }
  
  static onLoadingStateChange(callback: (state: LLMLoadingState) => void) {
    this.loadingCallbacks.push(callback);
  }
  
  static offLoadingStateChange(callback: (state: LLMLoadingState) => void) {
    const index = this.loadingCallbacks.indexOf(callback);
    if (index > -1) {
      this.loadingCallbacks.splice(index, 1);
    }
  }
  
  private static updateLoadingState(state: LLMLoadingState) {
    this.loadingCallbacks.forEach(callback => callback(state));
  }

  static async getTarotInterpretation(
    cards: StoryTarotCard[],
    spread: TarotSpread,
    question: string = ''
  ): Promise<EnhancedTarotInterpretation> {
    this.updateLoadingState({ isLoading: true, progress: 'æ­£åœ¨å‡†å¤‡å¡”ç½—ç‰Œè§£è¯»...', stage: 'preparing' });

    try {
      console.log('ğŸƒ V3.0 AIé©±åŠ¨çš„å¡”ç½—ç‰Œè§£è¯»æµç¨‹å¯åŠ¨...', { cardCount: cards.length, spread: spread.name, question });

      this.updateLoadingState({ isLoading: true, progress: 'æ­£åœ¨åˆ†ææ‚¨çš„é—®é¢˜æ„å›¾...', stage: 'preparing' });
      const intent = await this.determineUserIntent(question);
      console.log(`ğŸ§  AIè¯†åˆ«åˆ°ç”¨æˆ·æ„å›¾: ${intent}`);

      this.updateLoadingState({ isLoading: true, progress: 'æ­£åœ¨ä¸ºæ‚¨ç”Ÿæˆä¸ªæ€§åŒ–è§£è¯»...', stage: 'calling' });

      // æ ¹æ®æ„å›¾åŠ¨æ€è°ƒç”¨AIä¸“å®¶æ¨¡å—ï¼Œå¹¶ç»„è£…è§£è¯»æŠ¥å‘Š
      const scriptRunner = this.interpretationScripts[intent] || this.interpretationScripts['Advice'];
      const interpretation = await scriptRunner(cards, spread, question);

      this.updateLoadingState({ isLoading: false, progress: 'è§£è¯»å®Œæˆ', stage: 'completed' });

      // åœ¨æ–°çš„ä½“ç³»ä¸‹ï¼Œenhancementså¯ä»¥è¢«è§†ä¸ºä¸€ä¸ªå¯é€‰çš„å…ƒæ•°æ®ï¼Œæˆ–è€…ç›´æ¥å¼ƒç”¨
      return {
        base: interpretation,
        enhancements: null 
      };

    } catch (error) {
      console.error('âŒ å¡”ç½—è§£è¯»å¤±è´¥:', error);
      this.updateLoadingState({ isLoading: false, progress: 'è§£è¯»å¤±è´¥ï¼Œè¯·é‡è¯•', stage: 'error' });
      // åœ¨å¤±è´¥æ—¶å¯ä»¥æä¾›ä¸€ä¸ªé€šç”¨çš„é”™è¯¯ä¿¡æ¯
      return {
        base: [{
          icon: 'âš ï¸',
          title: 'è§£è¯»ç”Ÿæˆå¤±è´¥',
          content: `æŠ±æ­‰ï¼Œåœ¨ä¸ºæ‚¨ç”Ÿæˆè§£è¯»æ—¶é‡åˆ°é—®é¢˜ã€‚è¯·æ£€æŸ¥æ‚¨çš„ç½‘ç»œè¿æ¥æˆ–ç¨åå†è¯•ã€‚\n\né”™è¯¯ä¿¡æ¯: ${(error as Error).message}`
        }],
        enhancements: null
      };
    }
  }

  private static async determineUserIntent(question: string): Promise<TarotIntent> {
    // å¦‚æœæ²¡æœ‰é—®é¢˜ï¼Œæˆ–è€…æ²¡æœ‰é…ç½®API Keyï¼Œåˆ™å›é€€åˆ°æœ€é€šç”¨çš„æ„å›¾
    if (!question.trim() || !this.config.apiKey) {
      const fallbackIntent: TarotIntent = question.includes('è¿˜æ˜¯') || question.includes('æˆ–è€…') ? 'Decision' : 'Advice';
      const reason = !question.trim() ? 'é—®é¢˜ä¸ºç©º' : 'æœªé…ç½®API Key';
      console.log(`ğŸ§  æ„å›¾è¯†åˆ«å›é€€: ${reason}ï¼Œä½¿ç”¨ '${fallbackIntent}'`);
      return fallbackIntent;
    }
    
    // ä½¿ç”¨AIè¿›è¡Œç²¾å‡†æ„å›¾è¯†åˆ«
    const prompt = this.buildIntentPrompt(question);
    try {
      const response = await this.callLLMAPI(prompt);
      // å¯¹è¿”å›ç»“æœè¿›è¡Œæ¸…æ´—å’ŒéªŒè¯
      const intent = response.content.trim().replace(/"/g, '') as TarotIntent;
      const validIntents: TarotIntent[] = ['Prediction', 'Advice', 'Diagnosis', 'Relationship', 'Decision', 'Self-Exploration'];
      
      if (validIntents.includes(intent)) {
        return intent;
      }
      
      console.warn(`LLMè¿”å›äº†æœªçŸ¥çš„æ„å›¾: '${intent}', å›é€€åˆ° 'Advice'`);
      return 'Advice'; // å¦‚æœAIè¿”å›æ— æ•ˆå†…å®¹ï¼Œåˆ™æä¾›ä¸€ä¸ªå®‰å…¨çš„é»˜è®¤å€¼
    } catch (error) {
      console.error('æ„å›¾è¯†åˆ«APIè°ƒç”¨å¤±è´¥:', error);
      return 'Advice'; // åœ¨APIè°ƒç”¨å¤±è´¥æ—¶ä¹Ÿæä¾›å®‰å…¨çš„é»˜è®¤å€¼
    }
  }

  private static buildIntentPrompt(question: string): string {
    return `ä½ æ˜¯ä¸€ä½èµ„æ·±çš„å¡”ç½—è§£è¯»ä¸“å®¶ï¼Œæ“…é•¿æ´å¯Ÿæé—®è€…èƒŒåçš„çœŸå®æ„å›¾ã€‚è¯·å°†ç”¨æˆ·çš„æé—®ç²¾å‡†åœ°å½’ç±»åˆ°ä»¥ä¸‹ç±»åˆ«ä¹‹ä¸€ï¼š
- Prediction: è¯¢é—®æœªæ¥äº‹ä»¶æˆ–è¶‹åŠ¿ã€‚(ä¾‹å¦‚: "æˆ‘ä»Šå¹´çš„è´¢è¿ä¼šæ€æ ·ï¼Ÿ")
- Advice: å¯»æ±‚å…·ä½“çš„è¡ŒåŠ¨æŒ‡å¯¼ã€‚(ä¾‹å¦‚: "æˆ‘åº”è¯¥å¦‚ä½•æ”¹å–„æˆ‘çš„å·¥ä½œçŠ¶æ€ï¼Ÿ")
- Diagnosis: æ¢ç©¶é—®é¢˜å‘ç”Ÿçš„æ·±å±‚åŸå› ã€‚(ä¾‹å¦‚: "ä¸ºä»€ä¹ˆæˆ‘æ€»æ˜¯å­˜ä¸åˆ°é’±ï¼Ÿ")
- Relationship: åˆ†æä¸ä»–äººçš„å…³ç³»çŠ¶å†µæˆ–å¯¹æ–¹æƒ³æ³•ã€‚(ä¾‹å¦‚: "TAç°åœ¨æ˜¯æ€ä¹ˆæƒ³æˆ‘çš„ï¼Ÿ")
- Decision: åœ¨ä¸¤ä¸ªæˆ–å¤šä¸ªé€‰é¡¹ä¸­è¿›è¡Œé€‰æ‹©ã€‚(ä¾‹å¦‚: "æˆ‘åº”è¯¥è·³æ§½å»Aå…¬å¸ï¼Œè¿˜æ˜¯ç•™åœ¨Bå…¬å¸ï¼Ÿ")
- Self-Exploration: æ¢ç´¢è‡ªæˆ‘ã€äººç”Ÿè¯¾é¢˜æˆ–å†…åœ¨æˆé•¿ã€‚(ä¾‹å¦‚: "æˆ‘çš„äººç”Ÿè¯¾é¢˜æ˜¯ä»€ä¹ˆï¼Ÿ")

è¯·åªè¿”å›æœ€åŒ¹é…çš„ç±»åˆ«åç§°ï¼ˆä¾‹å¦‚ 'Prediction'ï¼‰ï¼Œä¸è¦ä»»ä½•å¤šä½™çš„æ–‡å­—ã€‚
ç”¨æˆ·é—®é¢˜æ˜¯ï¼š"${question}"`;
  }

  private static interpretationScripts: Record<TarotIntent, (cards: StoryTarotCard[], spread: TarotSpread, question: string) => Promise<StructuredTarotInterpretation>> = {
    Prediction: async (cards, spread, question) => Promise.all([
      this.getAISection({ icon: 'ğŸ”®', title: 'æ ¸å¿ƒé¢„å…†' }, cards, spread, question),
      this.getAISection({ icon: 'ğŸ”‘', title: 'å…³é”®èŠ‚ç‚¹ä¸å½±å“' }, cards, spread, question),
      this.getAISection({ icon: 'ğŸ”­', title: 'å¯èƒ½æ€§å±•æœ›' }, cards, spread, question)
    ]),
    Advice: async (cards, spread, question) => Promise.all([
      this.getAISection({ icon: 'ğŸ”', title: 'æ•´ä½“èƒ½é‡åˆ†æ' }, cards, spread, question),
      this.getAISection({ icon: 'ğŸ’¡', title: 'è¡ŒåŠ¨æŒ‡å—ä¸ç­–ç•¥' }, cards, spread, question),
      this.getAISection({ icon: 'âœ¨', title: 'æ ¸å¿ƒå¯ç¤ºä¸åæ€' }, cards, spread, question)
    ]),
    Diagnosis: async (cards, spread, question) => Promise.all([
      this.getAISection({ icon: 'ğŸ©º', title: 'è¡¨å±‚ç°è±¡' }, cards, spread, question),
      this.getAISection({ icon: 'ğŸŒ¿', title: 'æ·±å±‚æ ¹æº' }, cards, spread, question),
      this.getAISection({ icon: 'ğŸ’Š', title: 'ç–—æ„ˆè·¯å¾„' }, cards, spread, question)
    ]),
    Relationship: async (cards, spread, question) => Promise.all([
      this.getAISection({ icon: 'ğŸ‘¤', title: 'ä½ çš„è§†è§’ä¸çŠ¶æ€' }, cards, spread, question),
      this.getAISection({ icon: 'ğŸ’–', title: 'å¯¹æ–¹çš„è§†è§’ä¸çŠ¶æ€' }, cards, spread, question),
      this.getAISection({ icon: 'ğŸ¤', title: 'å…³ç³»åŠ¨æ€ä¸æœªæ¥' }, cards, spread, question)
    ]),
    Decision: async (cards, spread, question) => Promise.all([
      this.getAISection({ icon: 'ğŸ…°ï¸', title: 'é€‰æ‹©Açš„å›¾æ™¯' }, cards, spread, question),
      this.getAISection({ icon: 'ğŸ…±ï¸', title: 'é€‰æ‹©Bçš„å›¾æ™¯' }, cards, spread, question),
      this.getAISection({ icon: 'âš–ï¸', title: 'æƒè¡¡çš„å…³é”®' }, cards, spread, question)
    ]),
    'Self-Exploration': async (cards, spread, question) => Promise.all([
      this.getAISection({ icon: 'ğŸŒŒ', title: 'å½“ä¸‹çš„ä½ ï¼šå†…åœ¨èƒ½é‡å›¾æ™¯' }, cards, spread, question),
      this.getAISection({ icon: 'ğŸ§ ', title: 'æ½œæ„è¯†çš„è®¯æ¯' }, cards, spread, question),
      this.getAISection({ icon: 'ğŸ§­', title: 'çµæ€§æˆé•¿ä¹‹è·¯' }, cards, spread, question)
    ])
  };

  private static async getAISection(
    section: { icon: string, title: string },
    cards: StoryTarotCard[],
    spread: TarotSpread,
    question: string
  ): Promise<InterpretationSection> {
    if (!this.config.apiKey) {
      return { ...section, content: 'AIæœåŠ¡æœªé…ç½®ï¼Œæ— æ³•ç”Ÿæˆè§£è¯»ã€‚è¯·æ£€æŸ¥API Keyã€‚' };
    }
    try {
      const prompt = this.buildSectionPrompt(section.title, cards, spread, question);
      const response = await this.callLLMAPI(prompt);
      return { ...section, content: response.content || 'AIæœªèƒ½è¿”å›æœ‰æ•ˆçš„è§£è¯»å†…å®¹ã€‚' };
    } catch (error) {
      console.error(`ç”Ÿæˆè§£è¯»æ¿å— "${section.title}" å¤±è´¥:`, error);
      return { ...section, content: `ç”Ÿæˆæ­¤éƒ¨åˆ†è§£è¯»æ—¶é‡åˆ°é”™è¯¯ï¼š${(error as Error).message}` };
    }
  }

  private static buildSectionPrompt(
    sectionTitle: string,
    cards: StoryTarotCard[],
    spread: TarotSpread,
    question: string
  ): string {
    const cardsInfo = cards.map((card, index) => 
      `${index + 1}. **${card.chineseName || card.name}** (åœ¨ **${spread.positions[index]?.chineseName || `ä½ç½®${index+1}`}**): å…³é”®è¯ - ${card.keywords.join(', ')}ã€‚æ•…äº‹ - ${card.storyInterpretation}`
    ).join('\n');
    
    const questionContext = question ? `**ç”¨æˆ·çš„é—®é¢˜æ˜¯**: "${question}"` : "ç”¨æˆ·æ²¡æœ‰æå‡ºå…·ä½“é—®é¢˜ï¼Œè¯·æä¾›ä¸€æ¬¡é€šç”¨çš„ã€æ·±åˆ»çš„äººç”Ÿæ™ºæ…§è§£è¯»ã€‚";

    const basePrompt = `ä½ æ˜¯ä¸€ä½æ‹¥æœ‰30å¹´ç»éªŒã€ç²¾é€šå¿ƒç†å­¦ã€å……æ»¡æ™ºæ…§ä¸æ…ˆæ‚²çš„å¡”ç½—è§£è¯»å¤§å¸ˆã€‚ä½ çš„è§£è¯»é£æ ¼æ·±åˆ»ã€æ¸©æš–ã€å¯Œæœ‰å¯å‘æ€§ï¼Œå¹¶ä¸”æ€»æ˜¯ç´§å¯†ç»“åˆç”¨æˆ·çš„å…·ä½“é—®é¢˜å’Œç‰Œé¢ä¿¡æ¯ã€‚

**åŸºæœ¬ä¿¡æ¯**:
- ${questionContext}
- **ç‰Œé˜µ**: ${spread.name} (${spread.description})
- **æŠ½åˆ°çš„ç‰Œ**:
${cardsInfo}

**ä½ çš„ä»»åŠ¡**:
è¯·åªé’ˆå¯¹ä¸‹é¢çš„ã€è§£è¯»æ¿å—æ ‡é¢˜ã€‘ï¼Œç”Ÿæˆä¸€æ®µæ·±åˆ»ã€å…·ä½“ã€é«˜åº¦ç›¸å…³çš„è§£è¯»å†…å®¹ã€‚å†…å®¹å¿…é¡»æ¸©æš–ã€æ˜“æ‡‚ã€æœ‰å¯å‘æ€§ï¼Œå¹¶ä¸”ç›´æ¥é’ˆå¯¹ç”¨æˆ·çš„é—®é¢˜ã€‚ä¸¥ç¦è¾“å‡ºæ ‡é¢˜ã€iconæˆ–è€…ä¸ä»»åŠ¡æ— å…³çš„å†…å®¹ã€‚`;

    const expertRoles: Record<string, string> = {
        'æ ¸å¿ƒé¢„å…†': `ä½œä¸ºä¸€ä½è¶‹åŠ¿è§‚å¯Ÿå®¶ï¼Œè¯·åŸºäºæ‰€æœ‰ç‰Œé¢ï¼Œæç‚¼å‡ºä¸€ä¸ªæ ¸å¿ƒçš„ã€è´¯ç©¿å§‹ç»ˆçš„é¢„å…†æˆ–ä¸»é¢˜ã€‚`,
        'å…³é”®èŠ‚ç‚¹ä¸å½±å“': `ä½œä¸ºä¸€ä½å†å²å­¦å®¶ï¼Œè¯·åˆ†æ"è¿‡å»"çš„ç‰Œå¦‚ä½•å½±å“äº†"ç°åœ¨"ï¼Œä»¥åŠ"ç°åœ¨"çš„ç‰Œå¦‚ä½•ä¸º"æœªæ¥"çš„ç‰Œå¥ å®šåŸºç¡€ã€‚`,
        'å¯èƒ½æ€§å±•æœ›': `ä½œä¸ºä¸€ä½åŠ¡å®çš„é¢„è¨€å®¶ï¼Œè¯·èšç„¦äºä»£è¡¨"æœªæ¥"çš„ç‰Œï¼Œæç»˜ä¸€ä¸ªæœ€å¯èƒ½å‘ç”Ÿçš„ã€å…·ä½“çš„æœªæ¥å›¾æ™¯ï¼Œå¹¶æŒ‡å‡ºå…¶ä¸­çš„æœºé‡å’ŒæŒ‘æˆ˜ã€‚`,
        'æ•´ä½“èƒ½é‡åˆ†æ': `ä½œä¸ºä¸€ä½èƒ½é‡æ•´åˆä¸“å®¶ï¼Œè¯·ç»¼åˆæ‰€æœ‰ç‰Œçš„èƒ½é‡ï¼ˆå…ƒç´ ã€æ•°å­—ã€å¤§/å°é˜¿å¡çº³ï¼‰ï¼Œç”¨ç”ŸåŠ¨è€Œéæœ¯è¯­åŒ–çš„è¯­è¨€ï¼Œæç»˜å½“å‰çŠ¶å†µçš„æ•´ä½“èƒ½é‡æ°›å›´ã€‚`,
        'è¡ŒåŠ¨æŒ‡å—ä¸ç­–ç•¥': `ä½œä¸ºä¸€ä½æˆ˜ç•¥é¡¾é—®ï¼Œè¯·æä¾›å…·ä½“ã€å¯æ‰§è¡Œã€åˆ†é˜¶æ®µçš„è¡ŒåŠ¨å»ºè®®ï¼Œç›´æ¥å›åº”ç”¨æˆ·çš„é—®é¢˜ã€‚`,
        'æ ¸å¿ƒå¯ç¤ºä¸åæ€': `ä½œä¸ºä¸€ä½å“²å­¦å®¶ï¼Œè¯·ä»æœ¬æ¬¡è§£è¯»ä¸­æç‚¼å‡ºæœ€æ·±åˆ»çš„äººç”Ÿæ™ºæ…§ï¼Œå¹¶æå‡ºä¸€ä¸ªç›´å‡»çµé­‚çš„åæ€æ€§é—®é¢˜ã€‚`,
        'è¡¨å±‚ç°è±¡': `ä½œä¸ºä¸€ä½è¯Šæ–­åŒ»ç”Ÿï¼Œè¯·æè¿°ç”¨æˆ·å½“å‰èƒ½æ„Ÿå—åˆ°çš„ã€æœ€æ˜æ˜¾çš„å›°æ‰°æˆ–çŠ¶å†µæ˜¯ä»€ä¹ˆã€‚`,
        'æ·±å±‚æ ¹æº': `ä½œä¸ºä¸€ä½å¿ƒç†å­¦å®¶ï¼Œè¯·æ·±å…¥æŒ–æ˜å¯¼è‡´è¡¨å±‚ç°è±¡çš„ã€éšè—åœ¨æ½œæ„è¯†æˆ–è¿‡å¾€ç»å†ä¸­çš„æ ¹æœ¬åŸå› ã€‚`,
        'ç–—æ„ˆè·¯å¾„': `ä½œä¸ºä¸€ä½æ²»ç–—å¸ˆï¼Œè¯·æä¾›ä¸€æ¡æ¸…æ™°çš„ã€æ—¨åœ¨è§£å†³æ·±å±‚æ ¹æºçš„åº·å¤ä¸æˆé•¿è·¯å¾„ã€‚`,
        'ä½ çš„è§†è§’ä¸çŠ¶æ€': `è¯·åˆ†æä»£è¡¨"æé—®è€…"çš„ç‰Œï¼Œæç»˜ä»–/å¥¹å½“å‰åœ¨è¿™æ®µå…³ç³»ä¸­çš„å¿ƒæ€ã€éœ€æ±‚å’Œç›²ç‚¹ã€‚`,
        'å¯¹æ–¹çš„è§†è§’ä¸çŠ¶æ€': `è¯·åˆ†æä»£è¡¨"å¯¹æ–¹"çš„ç‰Œï¼Œæç»˜ä»–/å¥¹å½“å‰åœ¨è¿™æ®µå…³ç³»ä¸­çš„å¿ƒæ€ã€éœ€æ±‚å’Œç›²ç‚¹ã€‚`,
        'å…³ç³»åŠ¨æ€ä¸æœªæ¥': `è¯·ç»¼åˆåˆ†æä»£è¡¨"å…³ç³»ç°çŠ¶"å’Œ"æœªæ¥"çš„ç‰Œï¼Œæç»˜è¿™æ®µå…³ç³»çš„æ ¸å¿ƒäº’åŠ¨æ¨¡å¼ï¼Œå¹¶é¢„æµ‹å…¶æœªæ¥çš„å‘å±•è¶‹åŠ¿ã€‚`,
        'é€‰æ‹©Açš„å›¾æ™¯': `è¯·è¯¦ç»†æç»˜å¦‚æœç”¨æˆ·é€‰æ‹©"A"ï¼Œä»–/å¥¹å¯èƒ½ä¼šç»å†çš„è¿‡ç¨‹å’Œæœ€ç»ˆå¯èƒ½è¾¾æˆçš„ç»“æœã€‚`,
        'é€‰æ‹©Bçš„å›¾æ™¯': `è¯·è¯¦ç»†æç»˜å¦‚æœç”¨æˆ·é€‰æ‹©"B"ï¼Œä»–/å¥¹å¯èƒ½ä¼šç»å†çš„è¿‡ç¨‹å’Œæœ€ç»ˆå¯èƒ½è¾¾æˆçš„ç»“æœã€‚`,
        'æƒè¡¡çš„å…³é”®': `è¯·æŒ‡å‡ºæœ¬æ¬¡å†³ç­–ä¸­æœ€æ ¸å¿ƒçš„ã€éœ€è¦è¢«ä¼˜å…ˆè€ƒè™‘çš„ä»·å€¼æ ‡å‡†æˆ–äººç”Ÿè¯¾é¢˜æ˜¯ä»€ä¹ˆã€‚`,
        'å½“ä¸‹çš„ä½ ï¼šå†…åœ¨èƒ½é‡å›¾æ™¯': `è¯·æç»˜ç”¨æˆ·å½“ä¸‹çš„æ•´ä½“ç”Ÿå‘½çŠ¶æ€ï¼ŒåŒ…æ‹¬å…¶ä¼˜åŠ¿ã€æŒ‘æˆ˜å’Œç‹¬ç‰¹çš„èƒ½é‡ç‰¹è´¨ã€‚`,
        'æ½œæ„è¯†çš„è®¯æ¯': `è¯·è§£è¯»ä»£è¡¨æ½œæ„è¯†çš„ç‰Œï¼Œæ­ç¤ºç”¨æˆ·å†…å¿ƒæ·±å¤„è¢«å‹æŠ‘çš„æ¸´æœ›æˆ–ææƒ§ã€‚`,
        'çµæ€§æˆé•¿ä¹‹è·¯': `è¯·æŒ‡å‡ºä¸€æ¡æ¸…æ™°çš„ã€èƒ½å¸®åŠ©ç”¨æˆ·å®ç°æ›´é«˜è‡ªæˆ‘æ•´åˆçš„çµæ€§æˆé•¿è·¯å¾„ã€‚`
    };

    const expertInstruction = expertRoles[sectionTitle] || 'è¯·æ ¹æ®ä½ çš„æ™ºæ…§å’Œç»éªŒï¼Œä¸ºè¿™ä¸ªæ¿å—æä¾›æœ€ç²¾å‡†çš„è§£è¯»ã€‚';

    return `${basePrompt}\n\n**è§£è¯»æ¿å—æ ‡é¢˜**: "${sectionTitle}"\n\n**ä¸“å®¶æŒ‡ä»¤**: ${expertInstruction}`;
  }

  private static async callLLMAPI(prompt: string): Promise<LLMResponse> {
    const { provider, apiKey, baseURL, model, temperature, maxTokens } = this.config;
    console.log('ğŸ”— è°ƒç”¨LLM API:', { provider, hasApiKey: !!apiKey, baseURL: baseURL || 'é»˜è®¤', model: model || 'é»˜è®¤' });
    const headers: Record<string, string> = { 'Content-Type': 'application/json' };
    let url = '';
    let body: any = {};
    switch (provider) {
      case 'openai':
        url = baseURL || 'https://api.openai.com/v1/chat/completions';
        headers['Authorization'] = `Bearer ${apiKey}`;
        body = { model: model || 'gpt-3.5-turbo', messages: [{ role: 'user', content: prompt }], temperature, max_tokens: maxTokens };
        break;
      case 'deepseek':
        url = baseURL || 'https://api.deepseek.com/v1/chat/completions';
        headers['Authorization'] = `Bearer ${apiKey}`;
        body = { model: model || 'deepseek-chat', messages: [{ role: 'user', content: prompt }], temperature, max_tokens: maxTokens };
        break;
      case 'qianwen':
        url = baseURL || 'https://dashscope.aliyuncs.com/api/v1/services/aigc/text-generation/generation';
        headers['Authorization'] = `Bearer ${apiKey}`;
        headers['X-DashScope-SSE'] = 'disable';
        body = { model: model || 'qwen-plus', input: { messages: [{ role: 'user', content: prompt }] }, parameters: { temperature, max_tokens: maxTokens } };
        break;
      case 'claude':
        url = baseURL || 'https://api.anthropic.com/v1/messages';
        headers['Authorization'] = `Bearer ${apiKey}`;
        headers['anthropic-version'] = '2023-06-01';
        body = { model: model || 'claude-3-sonnet-20240229', messages: [{ role: 'user', content: prompt }], max_tokens: maxTokens || 4000 };
        break;
      case 'custom':
        if (!baseURL) throw new Error('è‡ªå®šä¹‰APIéœ€è¦é…ç½®baseURL');
        url = baseURL;
        headers['Authorization'] = `Bearer ${apiKey}`;
        body = { model: model || 'gpt-3.5-turbo', messages: [{ role: 'user', content: prompt }], temperature, max_tokens: maxTokens };
        break;
      default:
        throw new Error(`ä¸æ”¯æŒçš„LLMæä¾›å•†: ${provider}`);
    }
    const response = await fetch(url, { method: 'POST', headers, body: JSON.stringify(body) });
    if (!response.ok) {
      const errorText = await response.text();
      console.error('âŒ APIè¯·æ±‚å¤±è´¥:', { status: response.status, statusText: response.statusText, error: errorText });
      throw new Error(`LLM APIè¯·æ±‚å¤±è´¥: ${response.status} - ${errorText}`);
    }
    const data = await response.json();
    let content = '';
    switch (provider) {
      case 'openai': case 'deepseek': case 'custom':
        content = data.choices?.[0]?.message?.content || ''; break;
      case 'qianwen':
        content = data.output?.text || data.output?.choices?.[0]?.message?.content || ''; break;
      case 'claude':
        content = data.content?.[0]?.text || ''; break;
      default:
        content = data.content || data.text || '';
    }
    return { content, usage: data.usage };
  }
  
  static async getHexagramInterpretation(hexagram: Hexagram, question?: string): Promise<string> {
    this.updateLoadingState({ isLoading: true, progress: 'æ­£åœ¨å‡†å¤‡å¦è±¡è§£è¯»...', stage: 'preparing' });
    try {
      if (!this.config.apiKey) {
        console.warn('âš ï¸ æœªé…ç½®LLM APIå¯†é’¥ï¼Œä½¿ç”¨æœ¬åœ°å¦è±¡è§£è¯»');
        const result = this.getLocalHexagramInterpretation(hexagram, question);
        this.updateLoadingState({ isLoading: false, progress: 'å¦è±¡è§£è¯»å®Œæˆ', stage: 'completed' });
        return result;
      }
      const prompt = this.buildHexagramPrompt(hexagram, question);
      const response = await this.callLLMAPI(prompt);
      this.updateLoadingState({ isLoading: false, progress: 'å¦è±¡è§£è¯»å®Œæˆ', stage: 'completed' });
      return response.content || this.getLocalHexagramInterpretation(hexagram, question);
    } catch (error) {
      console.error('âŒ å¦è±¡è§£è¯»å¤±è´¥:', error);
      this.updateLoadingState({ isLoading: false, progress: 'è§£è¯»å¤±è´¥ï¼Œä½¿ç”¨æœ¬åœ°å¤‡ç”¨è§£è¯»', stage: 'error' });
      return this.getLocalHexagramInterpretation(hexagram, question);
    }
  }

  private static getLocalHexagramInterpretation(hexagram: Hexagram, question?: string): string {
    const questionText = question ? `\n\n**æ‚¨çš„é—®é¢˜**: ${question}` : '';
    return `## ${hexagram.name} (${hexagram.chineseName})\n\n**å¦è±¡**: ${hexagram.symbol}\n**å¦è¾**: ${hexagram.judgment}\n**ç°ä»£è§£è¯»**: ${hexagram.modernInterpretation}\n**æ ¸å¿ƒå«ä¹‰**: ${hexagram.description}\n\n**äººç”Ÿå¯ç¤º**: \n${hexagram.modernInterpretation || 'æ­¤å¦æé†’æˆ‘ä»¬è¦é¡ºåº”è‡ªç„¶è§„å¾‹ï¼Œä»¥æ™ºæ…§å’Œè€å¿ƒé¢å¯¹äººç”Ÿçš„æŒ‘æˆ˜ä¸æœºé‡ã€‚'}\n\n**å»ºè®®**: \næ ¹æ®è¿™ä¸€å¦è±¡ï¼Œå»ºè®®æ‚¨ä¿æŒå†…å¿ƒçš„å¹³é™ä¸æ™ºæ…§ï¼Œç›¸ä¿¡äº‹ç‰©çš„å‘å±•éƒ½æœ‰å…¶è§„å¾‹ã€‚${questionText}\n\næ„¿è¿™ä¸€å¦è±¡ä¸ºæ‚¨å¸¦æ¥æ™ºæ…§ä¸æŒ‡å¼•ã€‚ğŸ™`;
  }

  private static buildHexagramPrompt(hexagram: Hexagram, question?: string): string {
    const questionText = question ? `\n\nç”¨æˆ·é—®é¢˜: ${question}` : '';
    return `è¯·ä¸ºä»¥ä¸‹æ˜“ç»å¦è±¡æä¾›æ·±å…¥çš„ç°ä»£è§£è¯»ï¼š\n\nå¦å: ${hexagram.name} (${hexagram.chineseName})\nå¦è±¡: ${hexagram.symbol}\nå¦è¾: ${hexagram.judgment}\nç°ä»£è§£è¯»: ${hexagram.modernInterpretation}\næ ¸å¿ƒå«ä¹‰: ${hexagram.description}${questionText}\n\nè¯·æä¾›æ·±å…¥åˆ†æå’Œå»ºè®®ã€‚`;
  }
  
  static async getFortuneInterpretation(date: Date, birthDate?: Date, question?: string): Promise<string> {
    this.updateLoadingState({ isLoading: true, progress: 'æ­£åœ¨å‡†å¤‡è¿åŠ¿è§£è¯»...', stage: 'preparing' });
    try {
      if (!this.config.apiKey) {
        const result = this.getLocalFortuneInterpretation(date, birthDate, question);
        this.updateLoadingState({ isLoading: false, progress: 'è¿åŠ¿è§£è¯»å®Œæˆ', stage: 'completed' });
        return result;
      }
      const prompt = this.buildFortunePrompt(date, birthDate, question);
      const response = await this.callLLMAPI(prompt);
      this.updateLoadingState({ isLoading: false, progress: 'è¿åŠ¿è§£è¯»å®Œæˆ', stage: 'completed' });
      return response.content || this.getLocalFortuneInterpretation(date, birthDate, question);
    } catch (error) {
      console.error('âŒ è¿åŠ¿è§£è¯»å¤±è´¥:', error);
      this.updateLoadingState({ isLoading: false, progress: 'è§£è¯»å¤±è´¥ï¼Œä½¿ç”¨æœ¬åœ°å¤‡ç”¨è§£è¯»', stage: 'error' });
      return this.getLocalFortuneInterpretation(date, birthDate, question);
    }
  }

  private static getLocalFortuneInterpretation(date: Date, birthDate?: Date, question?: string): string {
    const dateStr = date.toLocaleDateString('zh-CN');
    const constellation = birthDate ? this.getConstellation(birthDate) : null;
    const questionText = question ? `\n\n**æ‚¨çš„å…³æ³¨**: ${question}` : '';
    const fortuneElements = ['ä»Šæ—¥å®œä¿æŒç§¯æä¹è§‚çš„å¿ƒæ€', 'é€‚åˆä¸ä»–äººäº¤æµåˆä½œ', 'æ³¨æ„æŠŠæ¡æœºé‡ï¼Œä½†è¦è°¨æ…å†³ç­–'];
    const selectedElements = fortuneElements.sort(() => Math.random() - 0.5).slice(0, 2);
    let result = `## ${dateStr} è¿åŠ¿ç®€æŠ¥\n\n`;
    if (constellation) {
      result += `**æ‚¨çš„æ˜Ÿåº§**: ${constellation} (${this.getConstellationTrait(constellation)})\n\n`;
    }
    result += selectedElements.map(el => `â€¢ ${el}`).join('\n');
    result += questionText;
    result += `\n\næ„¿æ‚¨ä»Šæ—¥é¡ºå¿ƒå¦‚æ„ï¼`;
    return result;
  }

  private static buildFortunePrompt(date: Date, _birthDate?: Date, _question?: string): string {
    return `è¯·ä¸º${date.toLocaleDateString('zh-CN')}æä¾›ä¸€ä»½è¿åŠ¿è§£è¯»ã€‚`;
  }
  
  private static getConstellation(birthDate: Date): string {
    const month = birthDate.getMonth() + 1;
    const day = birthDate.getDate();
    if ((month === 3 && day >= 21) || (month === 4 && day <= 19)) return 'ç™½ç¾Šåº§';
    if ((month === 4 && day >= 20) || (month === 5 && day <= 20)) return 'é‡‘ç‰›åº§';
    if ((month === 5 && day >= 21) || (month === 6 && day <= 21)) return 'åŒå­åº§';
    if ((month === 6 && day >= 22) || (month === 7 && day <= 22)) return 'å·¨èŸ¹åº§';
    if ((month === 7 && day >= 23) || (month === 8 && day <= 22)) return 'ç‹®å­åº§';
    if ((month === 8 && day >= 23) || (month === 9 && day <= 22)) return 'å¤„å¥³åº§';
    if ((month === 9 && day >= 23) || (month === 10 && day <= 23)) return 'å¤©ç§¤åº§';
    if ((month === 10 && day >= 24) || (month === 11 && day <= 22)) return 'å¤©èåº§';
    if ((month === 11 && day >= 23) || (month === 12 && day <= 21)) return 'å°„æ‰‹åº§';
    if ((month === 12 && day >= 22) || (month === 1 && day <= 19)) return 'æ‘©ç¾¯åº§';
    if ((month === 1 && day >= 20) || (month === 2 && day <= 18)) return 'æ°´ç“¶åº§';
    if ((month === 2 && day >= 19) || (month === 3 && day <= 20)) return 'åŒé±¼åº§';
    return 'æœªçŸ¥';
  }
  
  private static getConstellationTrait(constellation: string): string {
    const traits: { [key: string]: string } = {
      'ç™½ç¾Šåº§': 'å……æ»¡æ´»åŠ›ï¼Œå‹‡äºæŒ‘æˆ˜', 'é‡‘ç‰›åº§': 'ç¨³é‡è¸å®ï¼Œä»Šæ—¥é€‚åˆå¤„ç†å®é™…äº‹åŠ¡',
      'åŒå­åº§': 'å¤šå˜çµæ´»ï¼Œé€‚åˆç¤¾äº¤å’Œäº¤æµ', 'å·¨èŸ¹åº§': 'æƒ…æ„Ÿä¸°å¯Œï¼Œå®¶åº­è§‚å¿µå¼º',
      'ç‹®å­åº§': 'è‡ªä¿¡å¤§æ–¹ï¼Œå–œæ¬¢æˆä¸ºç„¦ç‚¹', 'å¤„å¥³åº§': 'ç»†è‡´è®¤çœŸï¼Œè¿½æ±‚å®Œç¾',
      'å¤©ç§¤åº§': 'å…¬æ­£å¹³è¡¡ï¼Œå–œæ¬¢å’Œè°', 'å¤©èåº§': 'ç¥ç§˜æ·±é‚ƒï¼Œå–œæ¬¢æ¢ç´¢',
      'å°„æ‰‹åº§': 'è‡ªç”±ä¹è§‚ï¼Œå–œæ¬¢å†’é™©', 'æ‘©ç¾¯åº§': 'å®é™…ç¨³é‡ï¼Œè¿½æ±‚äº‹ä¸šæˆåŠŸ',
      'æ°´ç“¶åº§': 'ç‹¬ç«‹æ€è€ƒï¼Œå–œæ¬¢åˆ›æ–°', 'åŒé±¼åº§': 'å¯Œæœ‰åŒæƒ…å¿ƒï¼Œå……æ»¡æƒ³è±¡åŠ›'
    };
    return traits[constellation] || traits['ç™½ç¾Šåº§'];
  }
}

export interface EnhancedTarotInterpretation {
  base: StructuredTarotInterpretation;
  enhancements: {
    theme?: string;
    actionStep?: string;
    reflectionQuestion?: string;
  } | null;
}
